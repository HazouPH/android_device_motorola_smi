From 5d18877cbe37dadd9334d4f4ff3282cb91184134 Mon Sep 17 00:00:00 2001
From: Patrick Harbers <jgrharbers@gmail.com>
Date: Mon, 4 Nov 2013 15:04:59 +0100
Subject: [PATCH] Change path

---
 core/inc/khronos/openmax/include/OMX_Audio.h       | 1311 ++++++++++++++++++
 core/inc/khronos/openmax/include/OMX_Component.h   |  579 ++++++++
 core/inc/khronos/openmax/include/OMX_ContentPipe.h |  195 +++
 core/inc/khronos/openmax/include/OMX_Core.h        | 1431 ++++++++++++++++++++
 core/inc/khronos/openmax/include/OMX_IVCommon.h    |  953 +++++++++++++
 core/inc/khronos/openmax/include/OMX_Image.h       |  328 +++++
 core/inc/khronos/openmax/include/OMX_Index.h       |  259 ++++
 core/inc/khronos/openmax/include/OMX_IndexExt.h    |   98 ++
 .../khronos/openmax/include/OMX_IntelErrorTypes.h  |   24 +
 core/inc/khronos/openmax/include/OMX_Other.h       |  337 +++++
 core/inc/khronos/openmax/include/OMX_Types.h       |  347 +++++
 core/inc/khronos/openmax/include/OMX_Video.h       | 1079 +++++++++++++++
 core/inc/khronos/openmax/include/OMX_VideoExt.h    |  133 ++
 core/src/Android.mk                                |   26 +
 core/src/Makefile.am                               |   50 +
 core/src/ebuild.mk                                 |   21 +
 core/src/intel_m4v_config_parser.cpp               | 1316 ++++++++++++++++++
 core/src/intel_m4v_config_parser.h                 |  105 ++
 core/src/intel_omx_config_parser.cpp               |  164 +++
 core/src/intel_omx_config_parser.h                 |   35 +
 core/src/intel_video_config_parser.cpp             |  288 ++++
 core/src/intel_video_config_parser.h               |   33 +
 core/src/pv_omx_interface.cpp                      |   90 ++
 core/src/wrs_omxcore.cpp                           |  460 +++++++
 ilcore/inc/khronos/openmax/include/OMX_Audio.h     | 1311 ------------------
 ilcore/inc/khronos/openmax/include/OMX_Component.h |  579 --------
 .../inc/khronos/openmax/include/OMX_ContentPipe.h  |  195 ---
 ilcore/inc/khronos/openmax/include/OMX_Core.h      | 1431 --------------------
 ilcore/inc/khronos/openmax/include/OMX_IVCommon.h  |  953 -------------
 ilcore/inc/khronos/openmax/include/OMX_Image.h     |  328 -----
 ilcore/inc/khronos/openmax/include/OMX_Index.h     |  259 ----
 ilcore/inc/khronos/openmax/include/OMX_IndexExt.h  |   98 --
 .../khronos/openmax/include/OMX_IntelErrorTypes.h  |   24 -
 ilcore/inc/khronos/openmax/include/OMX_Other.h     |  337 -----
 ilcore/inc/khronos/openmax/include/OMX_Types.h     |  347 -----
 ilcore/inc/khronos/openmax/include/OMX_Video.h     | 1079 ---------------
 ilcore/inc/khronos/openmax/include/OMX_VideoExt.h  |  133 --
 ilcore/src/Android.mk                              |   25 -
 ilcore/src/Makefile.am                             |   50 -
 ilcore/src/ebuild.mk                               |   21 -
 ilcore/src/intel_m4v_config_parser.cpp             | 1316 ------------------
 ilcore/src/intel_m4v_config_parser.h               |  105 --
 ilcore/src/intel_omx_config_parser.cpp             |  164 ---
 ilcore/src/intel_omx_config_parser.h               |   35 -
 ilcore/src/intel_video_config_parser.cpp           |  288 ----
 ilcore/src/intel_video_config_parser.h             |   33 -
 ilcore/src/pv_omx_interface.cpp                    |   90 --
 ilcore/src/wrs_omxcore.cpp                         |  459 -------
 48 files changed, 9662 insertions(+), 9660 deletions(-)
 create mode 100644 core/inc/khronos/openmax/include/OMX_Audio.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_Component.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_ContentPipe.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_Core.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_IVCommon.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_Image.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_Index.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_IndexExt.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_IntelErrorTypes.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_Other.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_Types.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_Video.h
 create mode 100644 core/inc/khronos/openmax/include/OMX_VideoExt.h
 create mode 100644 core/src/Android.mk
 create mode 100644 core/src/Makefile.am
 create mode 100644 core/src/ebuild.mk
 create mode 100644 core/src/intel_m4v_config_parser.cpp
 create mode 100644 core/src/intel_m4v_config_parser.h
 create mode 100644 core/src/intel_omx_config_parser.cpp
 create mode 100644 core/src/intel_omx_config_parser.h
 create mode 100644 core/src/intel_video_config_parser.cpp
 create mode 100644 core/src/intel_video_config_parser.h
 create mode 100644 core/src/pv_omx_interface.cpp
 create mode 100644 core/src/wrs_omxcore.cpp
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_Audio.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_Component.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_ContentPipe.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_Core.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_IVCommon.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_Image.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_Index.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_IndexExt.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_IntelErrorTypes.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_Other.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_Types.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_Video.h
 delete mode 100644 ilcore/inc/khronos/openmax/include/OMX_VideoExt.h
 delete mode 100644 ilcore/src/Android.mk
 delete mode 100644 ilcore/src/Makefile.am
 delete mode 100644 ilcore/src/ebuild.mk
 delete mode 100644 ilcore/src/intel_m4v_config_parser.cpp
 delete mode 100644 ilcore/src/intel_m4v_config_parser.h
 delete mode 100644 ilcore/src/intel_omx_config_parser.cpp
 delete mode 100644 ilcore/src/intel_omx_config_parser.h
 delete mode 100644 ilcore/src/intel_video_config_parser.cpp
 delete mode 100644 ilcore/src/intel_video_config_parser.h
 delete mode 100644 ilcore/src/pv_omx_interface.cpp
 delete mode 100644 ilcore/src/wrs_omxcore.cpp

diff --git a/core/inc/khronos/openmax/include/OMX_Audio.h b/core/inc/khronos/openmax/include/OMX_Audio.h
new file mode 100644
index 0000000..9d084e8
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_Audio.h
@@ -0,0 +1,1311 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** @file OMX_Audio.h - OpenMax IL version 1.1.2
+ *  The structures needed by Audio components to exchange
+ *  parameters and configuration data with the componenmilts.
+ */
+
+#ifndef OMX_Audio_h
+#define OMX_Audio_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+
+#include <OMX_Core.h>
+
+/** @defgroup midi MIDI
+ * @ingroup audio
+ */
+
+/** @defgroup effects Audio effects
+ * @ingroup audio
+ */
+
+/** @defgroup audio OpenMAX IL Audio Domain
+ * Structures for OpenMAX IL Audio domain
+ * @{
+ */
+
+/** Enumeration used to define the possible audio codings.
+ *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must
+ *  be done in a vendor specific way.  Since this is for an audio
+ *  processing element this enum is relevant.  However, for another
+ *  type of component other enums would be in this area.
+ */
+typedef enum OMX_AUDIO_CODINGTYPE {
+    OMX_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
+    OMX_AUDIO_CodingAutoDetect,  /**< auto detection of audio format */
+    OMX_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
+    OMX_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
+    OMX_AUDIO_CodingAMR,         /**< Any variant of AMR encoded data */
+    OMX_AUDIO_CodingGSMFR,       /**< Any variant of GSM fullrate (i.e. GSM610) */
+    OMX_AUDIO_CodingGSMEFR,      /**< Any variant of GSM Enhanced Fullrate encoded data*/
+    OMX_AUDIO_CodingGSMHR,       /**< Any variant of GSM Halfrate encoded data */
+    OMX_AUDIO_CodingPDCFR,       /**< Any variant of PDC Fullrate encoded data */
+    OMX_AUDIO_CodingPDCEFR,      /**< Any variant of PDC Enhanced Fullrate encoded data */
+    OMX_AUDIO_CodingPDCHR,       /**< Any variant of PDC Halfrate encoded data */
+    OMX_AUDIO_CodingTDMAFR,      /**< Any variant of TDMA Fullrate encoded data (TIA/EIA-136-420) */
+    OMX_AUDIO_CodingTDMAEFR,     /**< Any variant of TDMA Enhanced Fullrate encoded data (TIA/EIA-136-410) */
+    OMX_AUDIO_CodingQCELP8,      /**< Any variant of QCELP 8kbps encoded data */
+    OMX_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
+    OMX_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
+    OMX_AUDIO_CodingSMV,         /**< Any variant of SMV encoded data */
+    OMX_AUDIO_CodingG711,        /**< Any variant of G.711 encoded data */
+    OMX_AUDIO_CodingG723,        /**< Any variant of G.723 dot 1 encoded data */
+    OMX_AUDIO_CodingG726,        /**< Any variant of G.726 encoded data */
+    OMX_AUDIO_CodingG729,        /**< Any variant of G.729 encoded data */
+    OMX_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data */
+    OMX_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
+    OMX_AUDIO_CodingSBC,         /**< Any variant of SBC encoded data */
+    OMX_AUDIO_CodingVORBIS,      /**< Any variant of VORBIS encoded data */
+    OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
+    OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
+    OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
+    OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CodingMax = 0x7FFFFFFF
+} OMX_AUDIO_CODINGTYPE;
+
+
+/** The PortDefinition structure is used to define all of the parameters
+ *  necessary for the compliant component to setup an input or an output audio
+ *  path.  If additional information is needed to define the parameters of the
+ *  port (such as frequency), additional structures must be sent such as the
+ *  OMX_AUDIO_PARAM_PCMMODETYPE structure to supply the extra parameters for the port.
+ */
+typedef struct OMX_AUDIO_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;            /**< MIME type of data for the port */
+    OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
+                                               for an output device,
+                                               otherwise this field is 0 */
+    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is
+                                          supported by the OMX component */
+    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this
+                                          port (e.g. PCM, AMR, MP3, etc) */
+} OMX_AUDIO_PORTDEFINITIONTYPE;
+
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct OMX_AUDIO_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_U32 nPortIndex;             /**< Indicates which port to set */
+    OMX_U32 nIndex;                 /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    OMX_AUDIO_CODINGTYPE eEncoding; /**< Type of data expected for this port (e.g. PCM, AMR, MP3, etc) */
+} OMX_AUDIO_PARAM_PORTFORMATTYPE;
+
+
+/** PCM mode type  */
+typedef enum OMX_AUDIO_PCMMODETYPE {
+    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */
+    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */
+    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */
+    OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_PCMModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_PCMModeMax = 0x7FFFFFFF
+} OMX_AUDIO_PCMMODETYPE;
+
+
+typedef enum OMX_AUDIO_CHANNELTYPE {
+    OMX_AUDIO_ChannelNone = 0x0,    /**< Unused or empty */
+    OMX_AUDIO_ChannelLF   = 0x1,    /**< Left front */
+    OMX_AUDIO_ChannelRF   = 0x2,    /**< Right front */
+    OMX_AUDIO_ChannelCF   = 0x3,    /**< Center front */
+    OMX_AUDIO_ChannelLS   = 0x4,    /**< Left surround */
+    OMX_AUDIO_ChannelRS   = 0x5,    /**< Right surround */
+    OMX_AUDIO_ChannelLFE  = 0x6,    /**< Low frequency effects */
+    OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
+    OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
+    OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
+    OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_ChannelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_ChannelMax  = 0x7FFFFFFF
+} OMX_AUDIO_CHANNELTYPE;
+
+#define OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
+#define OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */
+
+/** PCM format description */
+typedef struct OMX_AUDIO_PARAM_PCMMODETYPE {
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
+    OMX_U32 nPortIndex;               /**< port that this structure applies to */
+    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */
+    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */
+    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */
+    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for
+                                           non-interleaved data (e.g. block data) */
+    OMX_U32 nBitPerSample;            /**< Bit per sample */
+    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for
+                                           variable or unknown sampling rate. */
+    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */
+    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */
+
+} OMX_AUDIO_PARAM_PCMMODETYPE;
+
+
+/** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
+ * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC.
+ */
+typedef enum OMX_AUDIO_CHANNELMODETYPE {
+    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those
+                                          two channels changes accordingly to each channel information */
+    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between
+                                           2 channels for higher compression gain */
+    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half
+                                           the bitrate of the overall bitrate */
+    OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
+    OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_ChannelModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
+} OMX_AUDIO_CHANNELMODETYPE;
+
+
+typedef enum OMX_AUDIO_MP3STREAMFORMATTYPE {
+    OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_MP3StreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_MP3STREAMFORMATTYPE;
+
+/** MP3 params */
+typedef struct OMX_AUDIO_PARAM_MP3TYPE {
+    OMX_U32 nSize;                 /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    OMX_U32 nChannels;             /**< Number of channels */
+    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+    OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;  /**< MP3 stream format */
+} OMX_AUDIO_PARAM_MP3TYPE;
+
+
+typedef enum OMX_AUDIO_AACSTREAMFORMATTYPE {
+    OMX_AUDIO_AACStreamFormatMP2ADTS = 0, /**< AAC Audio Data Transport Stream 2 format */
+    OMX_AUDIO_AACStreamFormatMP4ADTS,     /**< AAC Audio Data Transport Stream 4 format */
+    OMX_AUDIO_AACStreamFormatMP4LOAS,     /**< AAC Low Overhead Audio Stream format */
+    OMX_AUDIO_AACStreamFormatMP4LATM,     /**< AAC Low overhead Audio Transport Multiplex */
+    OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
+    OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
+    OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
+    OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_AACStreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_AACSTREAMFORMATTYPE;
+
+
+/** AAC mode type.  Note that the term profile is used with the MPEG-2
+ * standard and the term object type and profile is used with MPEG-4 */
+typedef enum OMX_AUDIO_AACPROFILETYPE{
+  OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
+  OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
+  OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
+  OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
+  OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
+  OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
+  OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
+  OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
+  OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
+  OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
+  OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
+} OMX_AUDIO_AACPROFILETYPE;
+
+
+/** AAC tool usage (for nAACtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for encoder configuration and optional as decoder info output.
+ * For MP3, OMX_AUDIO_CHANNELMODETYPE is sufficient. */
+#define OMX_AUDIO_AACToolNone 0x00000000 /**< no AAC tools allowed (encoder config) or active (decoder info output) */
+#define OMX_AUDIO_AACToolMS   0x00000001 /**< MS: Mid/side joint coding tool allowed or active */
+#define OMX_AUDIO_AACToolIS   0x00000002 /**< IS: Intensity stereo tool allowed or active */
+#define OMX_AUDIO_AACToolTNS  0x00000004 /**< TNS: Temporal Noise Shaping tool allowed or active */
+#define OMX_AUDIO_AACToolPNS  0x00000008 /**< PNS: MPEG-4 Perceptual Noise substitution tool allowed or active */
+#define OMX_AUDIO_AACToolLTP  0x00000010 /**< LTP: MPEG-4 Long Term Prediction tool allowed or active */
+#define OMX_AUDIO_AACToolAll  0x7FFFFFFF /**< all AAC tools allowed or active (*/
+
+/** MPEG-4 AAC error resilience (ER) tool usage (for nAACERtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for ER encoder configuration and optional as decoder info output */
+#define OMX_AUDIO_AACERNone  0x00000000  /**< no AAC ER tools allowed/used */
+#define OMX_AUDIO_AACERVCB11 0x00000001  /**< VCB11: Virtual Code Books for AAC section data */
+#define OMX_AUDIO_AACERRVLC  0x00000002  /**< RVLC: Reversible Variable Length Coding */
+#define OMX_AUDIO_AACERHCR   0x00000004  /**< HCR: Huffman Codeword Reordering */
+#define OMX_AUDIO_AACERAll   0x7FFFFFFF  /**< all AAC ER tools allowed/used */
+
+
+/** AAC params */
+typedef struct OMX_AUDIO_PARAM_AACPROFILETYPE {
+    OMX_U32 nSize;                 /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< Port that this structure applies to */
+    OMX_U32 nChannels;             /**< Number of channels */
+    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    OMX_U32 nFrameLength;          /**< Frame length (in audio samples per channel) of the codec.
+                                        Can be 1024 or 960 (AAC-LC), 2048 (HE-AAC), 480 or 512 (AAC-LD).
+                                        Use 0 to let encoder decide */
+    OMX_U32 nAACtools;             /**< AAC tool usage */
+    OMX_U32 nAACERtools;           /**< MPEG-4 AAC error resilience tool usage */
+    OMX_AUDIO_AACPROFILETYPE eAACProfile;   /**< AAC profile enumeration */
+    OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat; /**< AAC stream format enumeration */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+} OMX_AUDIO_PARAM_AACPROFILETYPE;
+
+
+/** VORBIS params */
+typedef struct OMX_AUDIO_PARAM_VORBISTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nChannels;        /**< Number of channels */
+    OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
+                                   rate or unknown bit rates. Encoding is set to the
+                                   bitrate closest to specified  value (in bps) */
+    OMX_U32 nMinBitRate;      /**< Sets minimum bitrate (in bps). */
+    OMX_U32 nMaxBitRate;      /**< Sets maximum bitrate (in bps). */
+
+    OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
+                                   variable or unknown sampling rate. */
+    OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
+                                   limit the audio signal. Use 0 to let encoder decide */
+    OMX_S32 nQuality;		  /**< Sets encoding quality to n, between -1 (low) and 10 (high).
+                                   In the default mode of operation, teh quality level is 3.
+                                   Normal quality range is 0 - 10. */
+    OMX_BOOL bManaged;		  /**< Set  bitrate  management  mode. This turns off the
+                                   normal VBR encoding, but allows hard or soft bitrate
+                                   constraints to be enforced by the encoder. This mode can
+                                   be slower, and may also be lower quality. It is
+                                   primarily useful for streaming. */
+    OMX_BOOL bDownmix;		  /**< Downmix input from stereo to mono (has no effect on
+                                   non-stereo streams). Useful for lower-bitrate encoding. */
+} OMX_AUDIO_PARAM_VORBISTYPE;
+
+
+/** WMA Version */
+typedef enum OMX_AUDIO_WMAFORMATTYPE {
+  OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
+  OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
+  OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
+  OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
+  OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAFORMATTYPE;
+
+
+/** WMA Profile */
+typedef enum OMX_AUDIO_WMAPROFILETYPE {
+  OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
+  OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
+  OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
+  OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
+  OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAPROFILETYPE;
+
+
+/** WMA params */
+typedef struct OMX_AUDIO_PARAM_WMATYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U16 nChannels;        /**< Number of channels */
+    OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
+                                   rate or unknown bit rates */
+    OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
+	OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
+    OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
+    OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
+    OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
+    OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
+} OMX_AUDIO_PARAM_WMATYPE;
+
+/**
+ * RealAudio format
+ */
+typedef enum OMX_AUDIO_RAFORMATTYPE {
+    OMX_AUDIO_RAFormatUnused = 0, /**< Format unused or unknown */
+    OMX_AUDIO_RA8,                /**< RealAudio 8 codec */
+    OMX_AUDIO_RA9,                /**< RealAudio 9 codec */
+    OMX_AUDIO_RA10_AAC,           /**< MPEG-4 AAC codec for bitrates of more than 128kbps */
+    OMX_AUDIO_RA10_CODEC,         /**< RealAudio codec for bitrates less than 128 kbps */
+    OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
+    OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
+    OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
+    OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_RAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_RAFORMATTYPE;
+
+/** RA (Real Audio) params */
+typedef struct OMX_AUDIO_PARAM_RATYPE {
+    OMX_U32 nSize;              /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
+    OMX_U32 nChannels;          /**< Number of channels */
+    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */
+    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */
+    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */
+    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */
+    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */
+    OMX_U32 nNumRegions;        /**< is the number of regions value */
+    OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
+} OMX_AUDIO_PARAM_RATYPE;
+
+
+/** SBC Allocation Method Type */
+typedef enum OMX_AUDIO_SBCALLOCMETHODTYPE {
+  OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
+  OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
+  OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
+} OMX_AUDIO_SBCALLOCMETHODTYPE;
+
+
+/** SBC params */
+typedef struct OMX_AUDIO_PARAM_SBCTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_U32 nChannels;         /**< Number of channels */
+    OMX_U32 nBitRate;          /**< Bit rate of the input data.  Use 0 for variable
+                                    rate or unknown bit rates */
+    OMX_U32 nSampleRate;       /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+    OMX_U32 nBlocks;           /**< Number of blocks */
+    OMX_U32 nSubbands;         /**< Number of subbands */
+    OMX_U32 nBitPool;          /**< Bitpool value */
+    OMX_BOOL bEnableBitrate;   /**< Use bitrate value instead of bitpool */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode; /**< Channel mode enumeration */
+    OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;   /**< SBC Allocation method type */
+} OMX_AUDIO_PARAM_SBCTYPE;
+
+
+/** ADPCM stream format parameters */
+typedef struct OMX_AUDIO_PARAM_ADPCMTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not
+                                     necessarily the same as the number of channels
+                                     to be rendered. */
+    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */
+    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+} OMX_AUDIO_PARAM_ADPCMTYPE;
+
+
+/** G723 rate */
+typedef enum OMX_AUDIO_G723RATE {
+    OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
+    OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
+    OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
+    OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_G723ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
+} OMX_AUDIO_G723RATE;
+
+
+/** G723 - Sample rate must be 8 KHz */
+typedef struct OMX_AUDIO_PARAM_G723TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+    OMX_BOOL bPostFilter;         /**< Enable Post Filter */
+} OMX_AUDIO_PARAM_G723TYPE;
+
+
+/** ITU G726 (ADPCM) rate */
+typedef enum OMX_AUDIO_G726MODE {
+    OMX_AUDIO_G726ModeUnused = 0,  /**< G726 Mode unused / unknown */
+    OMX_AUDIO_G726Mode16,          /**< 16 kbps */
+    OMX_AUDIO_G726Mode24,          /**< 24 kbps */
+    OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
+    OMX_AUDIO_G726Mode40,          /**< 40 kbps */
+    OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_G726ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
+} OMX_AUDIO_G726MODE;
+
+
+/** G.726 stream format parameters - must be at 8KHz */
+typedef struct OMX_AUDIO_PARAM_G726TYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not
+                                     necessarily the same as the number of channels
+                                     to be rendered. */
+     OMX_AUDIO_G726MODE eG726Mode;
+} OMX_AUDIO_PARAM_G726TYPE;
+
+
+/** G729 coder type */
+typedef enum OMX_AUDIO_G729TYPE {
+    OMX_AUDIO_G729 = 0,           /**< ITU G.729  encoded data */
+    OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
+    OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
+    OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
+    OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_G729VendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G729Max = 0x7FFFFFFF
+} OMX_AUDIO_G729TYPE;
+
+
+/** G729 stream format parameters - fixed 6KHz sample rate */
+typedef struct OMX_AUDIO_PARAM_G729TYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nChannels;        /**< Number of channels in the data stream (not
+                                   necessarily the same as the number of channels
+                                   to be rendered. */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_AUDIO_G729TYPE eBitType;
+} OMX_AUDIO_PARAM_G729TYPE;
+
+
+/** AMR Frame format */
+typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE {
+    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance
+                                                   (Standard) Format */
+    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface
+                                                   Format 1 */
+    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface
+                                                   Format 2*/
+    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage
+                                                   Format */
+    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time
+                                                   Transport Protocol Payload Format */
+    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */
+    OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_AMRFrameFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_AMRFRAMEFORMATTYPE;
+
+
+/** AMR band mode */
+typedef enum OMX_AUDIO_AMRBANDMODETYPE {
+    OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
+    OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
+    OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
+    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */
+    OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
+    OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
+    OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
+    OMX_AUDIO_AMRBandModeNB6,                 /**< AMRNB Mode 6 = 10200 bps */
+    OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
+    OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
+    OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
+    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */
+    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */
+    OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
+    OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
+    OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
+    OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
+    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */
+    OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_AMRBandModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
+} OMX_AUDIO_AMRBANDMODETYPE;
+
+
+/** AMR Discontinuous Transmission mode */
+typedef enum OMX_AUDIO_AMRDTXMODETYPE {
+    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */
+    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using
+                                             Voice Activity Detector 1 (VAD1) is enabled */
+    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using
+                                             Voice Activity Detector 2 (VAD2) is enabled */
+    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between
+                                             Off, VAD1 or VAD2 modes */
+
+    OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */
+
+    OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_AMRDTXModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF
+} OMX_AUDIO_AMRDTXMODETYPE;
+
+
+/** AMR params */
+typedef struct OMX_AUDIO_PARAM_AMRTYPE {
+    OMX_U32 nSize;                          /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;               /**< OMX specification version information */
+    OMX_U32 nPortIndex;                     /**< port that this structure applies to */
+    OMX_U32 nChannels;                      /**< Number of channels */
+    OMX_U32 nBitRate;                       /**< Bit rate read only field */
+    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */
+    OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
+    OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
+} OMX_AUDIO_PARAM_AMRTYPE;
+
+
+/** GSM_FR (ETSI 06.10, 3GPP 46.010) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMFRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMFRTYPE;
+
+
+/** GSM-HR (ETSI 06.20, 3GPP 46.020) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMHRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMHRTYPE;
+
+
+/** GSM-EFR (ETSI 06.60, 3GPP 46.060) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMEFRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMEFRTYPE;
+
+
+/** TDMA FR (TIA/EIA-136-420, VSELP 7.95kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_TDMAFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_TDMAFRTYPE;
+
+
+/** TDMA EFR (TIA/EIA-136-410, ACELP 7.4kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_TDMAEFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_TDMAEFRTYPE;
+
+
+/** PDC FR ( RCR-27, VSELP 6.7kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCFRTYPE;
+
+
+/** PDC EFR ( RCR-27, ACELP 6.7kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCEFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCEFRTYPE;
+
+/** PDC HR ( RCR-27, PSI-CELP 3.45kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCHRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCHRTYPE;
+
+
+/** CDMA Rate types */
+typedef enum OMX_AUDIO_CDMARATETYPE {
+    OMX_AUDIO_CDMARateBlank = 0,          /**< CDMA encoded frame is blank */
+    OMX_AUDIO_CDMARateFull,               /**< CDMA encoded frame in full rate */
+    OMX_AUDIO_CDMARateHalf,               /**< CDMA encoded frame in half rate */
+    OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
+    OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
+    OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
+    OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_CDMARateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
+} OMX_AUDIO_CDMARATETYPE;
+
+
+/** QCELP8 (TIA/EIA-96, up to 8kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_QCELP8TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_U32 nBitRate;             /**< Bit rate of the input data.  Use 0 for variable
+                                       rate or unknown bit rates */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} OMX_AUDIO_PARAM_QCELP8TYPE;
+
+
+/** QCELP13 ( CDMA, EIA/TIA-733, 13.3kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_QCELP13TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} OMX_AUDIO_PARAM_QCELP13TYPE;
+
+
+/** EVRC ( CDMA, EIA/TIA-127, RCELP up to 8.55kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_EVRCTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< actual Frame rate */
+    OMX_BOOL bRATE_REDUCon;       /**< RATE_REDUCtion is requested for this frame */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter */
+    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter */
+} OMX_AUDIO_PARAM_EVRCTYPE;
+
+
+/** SMV ( up to 8.55kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_SMVTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_BOOL bRATE_REDUCon;           /**< RATE_REDUCtion is requested for this frame */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 ??*/
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 ??*/
+    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter ??*/
+    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter ??*/
+} OMX_AUDIO_PARAM_SMVTYPE;
+
+
+/** MIDI Format
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDIFORMATTYPE
+{
+    OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
+    OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
+    OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
+    OMX_AUDIO_MIDIFormatSMF2,        /**< Standard MIDI File Type 2 */
+    OMX_AUDIO_MIDIFormatSPMIDI,      /**< SP-MIDI */
+    OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
+    OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
+    OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
+    OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_MIDIFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDIFORMATTYPE;
+
+
+/** MIDI params
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_PARAM_MIDITYPE {
+    OMX_U32 nSize;                 /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire
+                                        MIDI file passed in, otherwise if 0x0, the MIDI data
+                                        is merged and streamed (instead of passed as an
+                                        entire MIDI file) */
+    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic
+                                        voices. A value of zero indicates that the default
+                                        polyphony of the device is used  */
+    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound
+                                        bank at initialization */
+    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */
+} OMX_AUDIO_PARAM_MIDITYPE;
+
+
+/** Type of the MIDI sound bank
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDISOUNDBANKTYPE {
+    OMX_AUDIO_MIDISoundBankUnused = 0,           /**< unused/unknown soundbank type */
+    OMX_AUDIO_MIDISoundBankDLS1,                 /**< DLS version 1 */
+    OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
+    OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
+    OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
+    OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_MIDISoundBankVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDISOUNDBANKTYPE;
+
+
+/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
+   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
+   OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
+   OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
+   OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
+   OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+   OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;
+
+
+/** MIDI params to load/unload user soundbank
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nDLSIndex;        /**< DLS file index to be loaded */
+    OMX_U32 nDLSSize;         /**< Size in bytes */
+    OMX_PTR pDLSData;         /**< Pointer to DLS file data */
+    OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;   /**< Midi sound bank type enumeration */
+    OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout; /**< Midi sound bank layout enumeration */
+} OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;
+
+
+/** Structure for Live MIDI events and MIP messages.
+ * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.)
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
+    OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
+                                   array for the MIP message buffer, where the size is
+                                   indicated by nMidiEventSize */
+} OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;
+
+
+/** MIDI sound bank/ program pair in a given channel
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
+    OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
+    OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
+    OMX_U16 nIDSoundBank;       /**< Sound bank ID */
+    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks
+                                     by index if multiple banks are present */
+} OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;
+
+
+/** MIDI control
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10
+                                       format based on JAVA MMAPI (JSR-135) requirement */
+    OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
+                                       number based on JSR-135 requirement */
+    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10
+                                       fixed-point number based on JSR-135 requirement */
+    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic
+                                       voices. A value of zero indicates that the default
+                                       polyphony of the device is used  */
+    OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
+    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback
+                                       will stop automatically.  Set to zero if not used */
+    OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
+    OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
+    OMX_U32 nTrack0031MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 0-31 */
+    OMX_U32 nTrack3263MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 32-63 */
+    OMX_U32 nTrack0031SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 0-31 */
+    OMX_U32 nTrack3263SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 32-63 */
+
+} OMX_AUDIO_CONFIG_MIDICONTROLTYPE;
+
+
+/** MIDI Playback States
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
+  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to
+  													other defined states */
+  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open.
+                                                    The MIDI engine is currently processing
+                                                    MIDI events. */
+  OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being
+                                                    primed. The MIDI engine is currently
+                                                    processing MIDI events. */
+  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but
+                                                    not playing. The MIDI engine is currently
+                                                    processing MIDI events. The transition to
+                                                    this state is only possible from the
+                                                    OMX_AUDIO_MIDIPlayBackStatePlaying state,
+                                                    when the 'playback head' reaches the end
+                                                    of media data or the playback stops due
+                                                    to stop time set.*/
+  OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
+                                                    playing. The MIDI engine is currently
+                                                    processing MIDI events.*/
+  OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
+                                                    resource constraints */
+  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
+                                                    SP-MIDI content constraints, there is
+                                                    no audible MIDI content during playback
+                                                    currently. The situation may change if
+                                                    resources are freed later.*/
+  OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDIPLAYBACKSTATETYPE;
+
+
+/** MIDI status
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field.
+                                     NOTE: May not return a meaningful value until the entire
+                                     file is parsed and buffered.  */
+    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource
+                                     in milliseconds. NOTE: May not return a meaningful value
+                                     until the entire file is parsed and buffered.  */
+    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played
+                                     in milliseconds */
+    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful
+                                     value until the entire file is parsed and buffered. */
+    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently
+                                     open MIDI resource. NOTE: May not return a meaningful value
+                                     until the entire file is parsed and buffered.  */
+    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing
+                                     MIDI resource. NOTE: May not return a meaningful value until
+                                     the entire file is parsed and buffered. */
+    OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
+} OMX_AUDIO_CONFIG_MIDISTATUSTYPE;
+
+
+/** MIDI Meta Event structure one per Meta Event.
+ *  MIDI Meta Events are like audio metadata, except that they are interspersed
+ *  with the MIDI content throughout the file and are not localized in the header.
+ *  As such, it is necessary to retrieve information about these Meta Events from
+ *  the engine, as it encounters these Meta Events within the MIDI content.
+ *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright,
+ *  author, default tempo, etc.) scattered throughout the file.
+ *  @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nIndex;           /**< Index of Meta Event */
+    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */
+    OMX_U32 nTrack;           /**< track number for the meta event */
+    OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
+} OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE;
+
+
+/** MIDI Meta Event Data structure - one per Meta Event.
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nIndex;           /**< Index of Meta Event */
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */
+    OMX_U8 nData[1];          /**< array of one or more bytes of meta data
+                                   as indicated by the nMetaEventSize field */
+} OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE;
+
+
+/** Audio Volume adjustment for a port */
+typedef struct OMX_AUDIO_CONFIG_VOLUMETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's volume.  Select the
+                                     output port to adjust the master
+                                     volume. */
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100)
+                                     or logarithmic scale (mB) */
+    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.  The values
+                                     for volume are in mB (millibels = 1/100 dB) relative
+                                     to a gain of 1 (e.g. the output is the same as the
+                                     input level).  Values are in mB from nMax
+                                     (maximum volume) to nMin mB (typically negative).
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+} OMX_AUDIO_CONFIG_VOLUMETYPE;
+
+
+/** Audio Volume adjustment for a channel */
+typedef struct OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's volume.  Select the
+                                     output port to adjust the master
+                                     volume. */
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1,
+                                     using OMX_ALL to apply volume settings
+                                     to all channels */
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or
+                                     logarithmic scale (mB) */
+    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.
+                                     The values for volume are in mB
+                                     (millibels = 1/100 dB) relative to a gain
+                                     of 1 (e.g. the output is the same as the
+                                     input level).  Values are in mB from nMax
+                                     (maximum volume) to nMin mB (typically negative).
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */
+} OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE;
+
+
+/** Audio balance setting */
+typedef struct OMX_AUDIO_CONFIG_BALANCETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's balance.  Select the
+                                     output port to adjust the master
+                                     balance. */
+    OMX_S32 nBalance;           /**< balance setting for this port
+                                     (-100 to 100, where -100 indicates
+                                     all left, and no right */
+} OMX_AUDIO_CONFIG_BALANCETYPE;
+
+
+/** Audio Port mute */
+typedef struct OMX_AUDIO_CONFIG_MUTETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's mute.  Select the
+                                     output port to adjust the master
+                                     mute. */
+    OMX_BOOL bMute;             /**< Mute setting for this port */
+} OMX_AUDIO_CONFIG_MUTETYPE;
+
+
+/** Audio Channel mute */
+typedef struct OMX_AUDIO_CONFIG_CHANNELMUTETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1,
+                                     using OMX_ALL to apply mute settings
+                                     to all channels */
+    OMX_BOOL bMute;             /**< Mute setting for this channel */
+    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */
+} OMX_AUDIO_CONFIG_CHANNELMUTETYPE;
+
+
+
+/** Enable / Disable for loudness control, which boosts bass and to a
+ *  smaller extent high end frequencies to compensate for hearing
+ *  ability at the extreme ends of the audio spectrum
+ */
+typedef struct OMX_AUDIO_CONFIG_LOUDNESSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bLoudness;        /**< Enable/disable for loudness */
+} OMX_AUDIO_CONFIG_LOUDNESSTYPE;
+
+
+/** Enable / Disable for bass, which controls low frequencies
+ */
+typedef struct OMX_AUDIO_CONFIG_BASSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for bass control */
+    OMX_S32 nBass;             /**< bass setting for the port, as a
+                                    continuous value from -100 to 100
+                                    (0 means no change in bass level)*/
+} OMX_AUDIO_CONFIG_BASSTYPE;
+
+
+/** Enable / Disable for treble, which controls high frequencies tones
+ */
+typedef struct OMX_AUDIO_CONFIG_TREBLETYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for treble control */
+    OMX_S32  nTreble;          /**< treble setting for the port, as a
+                                    continuous value from -100 to 100
+                                    (0 means no change in treble level) */
+} OMX_AUDIO_CONFIG_TREBLETYPE;
+
+
+/** An equalizer is typically used for two reasons: to compensate for an
+ *  sub-optimal frequency response of a system to make it sound more natural
+ *  or to create intentionally some unnatural coloring to the sound to create
+ *  an effect.
+ *  @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_EQUALIZERTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
+    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is
+                                    N-1, where N is the number of bands, lower limit is 0 */
+    OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
+                                    read only element and is used to determine
+                                    the lower, center and upper frequency of
+                                    this band.  */
+    OMX_BS32 sBandLevel;       /**< band level in millibels */
+} OMX_AUDIO_CONFIG_EQUALIZERTYPE;
+
+
+/** Stereo widening mode type
+ * @ingroup effects
+ */
+typedef enum OMX_AUDIO_STEREOWIDENINGTYPE {
+    OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
+    OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
+    OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_StereoWideningVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
+} OMX_AUDIO_STEREOWIDENINGTYPE;
+
+
+/** Control for stereo widening, which is a special 2-channel
+ *  case of the audio virtualizer effect. For example, for 5.1-channel
+ *  output, it translates to virtual surround sound.
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for stereo widening control */
+    OMX_AUDIO_STEREOWIDENINGTYPE eWideningType; /**< Stereo widening algorithm type */
+    OMX_U32  nStereoWidening;  /**< stereo widening setting for the port,
+                                    as a continuous value from 0 to 100  */
+} OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE;
+
+
+/** The chorus effect (or ``choralizer'') is any signal processor which makes
+ *  one sound source (such as a voice) sound like many such sources singing
+ *  (or playing) in unison. Since performance in unison is never exact, chorus
+ *  effects simulate this by making independently modified copies of the input
+ *  signal. Modifications may include (1) delay, (2) frequency shift, and
+ *  (3) amplitude modulation.
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_CHORUSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for chorus */
+    OMX_BU32 sDelay;           /**< average delay in milliseconds */
+    OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
+    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of
+                                    delay (i.e. 0 to 100) */
+    OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
+} OMX_AUDIO_CONFIG_CHORUSTYPE;
+
+
+/** Reverberation is part of the reflected sound that follows the early
+ *  reflections. In a typical room, this consists of a dense succession of
+ *  echoes whose energy decays exponentially. The reverberation effect structure
+ *  as defined here includes both (early) reflections as well as (late) reverberations.
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
+    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect
+                                       (i.e. both early reflections and late
+                                       reverberation) in millibels */
+    OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
+                                       relative to the intensity at low
+                                       frequencies in millibels */
+    OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
+                                       (relative to room value), in millibels */
+    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative
+                                       to the direct path, in milliseconds */
+    OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
+                                       relative to room level, in millibels */
+    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection
+                                       to the beginning of the late reverberation
+                                       section, in milliseconds */
+    OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
+                                       frequencies, in milliseconds */
+    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative
+                                       to low frequency decay time in percent  */
+    OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is
+                                       the frequency used as the reference for all
+                                       the high-frequency settings above */
+
+} OMX_AUDIO_CONFIG_REVERBERATIONTYPE;
+
+
+/** Possible settings for the Echo Cancelation structure to use
+ * @ingroup effects
+ */
+typedef enum OMX_AUDIO_ECHOCANTYPE {
+   OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
+   OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation -
+                                     echo from plastics and face */
+   OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for
+                                     Hands Free operation */
+   OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for
+                                     Car Kit (longer echo) */
+   OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+   OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
+} OMX_AUDIO_ECHOCANTYPE;
+
+
+/** Enable / Disable for echo cancelation, which removes undesired echo's
+ *  from the audio
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_AUDIO_ECHOCANTYPE eEchoCancelation; /**< Echo cancelation settings */
+} OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE;
+
+
+/** Enable / Disable for noise reduction, which undesired noise from
+ * the audio
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bNoiseReduction;  /**< Enable/disable for noise reduction */
+} OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/core/inc/khronos/openmax/include/OMX_Component.h b/core/inc/khronos/openmax/include/OMX_Component.h
new file mode 100644
index 0000000..8526f3a
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_Component.h
@@ -0,0 +1,579 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_Component.h - OpenMax IL version 1.1.2
+ *  The OMX_Component header file contains the definitions used to define
+ *  the public interface of a component.  This header file is intended to
+ *  be used by both the application and the component.
+ */
+
+#ifndef OMX_Component_h
+#define OMX_Component_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+
+#include <OMX_Audio.h>
+#include <OMX_Video.h>
+#include <OMX_Image.h>
+#include <OMX_Other.h>
+
+/** @ingroup comp */
+typedef enum OMX_PORTDOMAINTYPE {
+    OMX_PortDomainAudio,
+    OMX_PortDomainVideo,
+    OMX_PortDomainImage,
+    OMX_PortDomainOther,
+    OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_PortDomainVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_PortDomainMax = 0x7ffffff
+} OMX_PORTDOMAINTYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_PORTDEFINITIONTYPE {
+    OMX_U32 nSize;                 /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< Port number the structure applies to */
+    OMX_DIRTYPE eDir;              /**< Direction (input or output) of this port */
+    OMX_U32 nBufferCountActual;    /**< The actual number of buffers allocated on this port */
+    OMX_U32 nBufferCountMin;       /**< The minimum number of buffers this port requires */
+    OMX_U32 nBufferSize;           /**< Size, in bytes, for buffers to be used for this channel */
+    OMX_BOOL bEnabled;             /**< Ports default to enabled and are enabled/disabled by
+                                        OMX_CommandPortEnable/OMX_CommandPortDisable.
+                                        When disabled a port is unpopulated. A disabled port
+                                        is not populated with buffers on a transition to IDLE. */
+    OMX_BOOL bPopulated;           /**< Port is populated with all of its buffers as indicated by
+                                        nBufferCountActual. A disabled port is always unpopulated.
+                                        An enabled port is populated on a transition to OMX_StateIdle
+                                        and unpopulated on a transition to loaded. */
+    OMX_PORTDOMAINTYPE eDomain;    /**< Domain of the port. Determines the contents of metadata below. */
+    union {
+        OMX_AUDIO_PORTDEFINITIONTYPE audio;
+        OMX_VIDEO_PORTDEFINITIONTYPE video;
+        OMX_IMAGE_PORTDEFINITIONTYPE image;
+        OMX_OTHER_PORTDEFINITIONTYPE other;
+    } format;
+    OMX_BOOL bBuffersContiguous;
+    OMX_U32 nBufferAlignment;
+} OMX_PARAM_PORTDEFINITIONTYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_U32TYPE {
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
+    OMX_U32 nPortIndex;               /**< port that this structure applies to */
+    OMX_U32 nU32;                     /**< U32 value */
+} OMX_PARAM_U32TYPE;
+
+/** @ingroup rpm */
+typedef enum OMX_SUSPENSIONPOLICYTYPE {
+    OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
+    OMX_SuspensionEnabled,  /**< Suspension allowed */
+    OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_SuspensionPolicyMax = 0x7fffffff
+} OMX_SUSPENSIONPOLICYTYPE;
+
+/** @ingroup rpm */
+typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_SUSPENSIONPOLICYTYPE ePolicy;
+} OMX_PARAM_SUSPENSIONPOLICYTYPE;
+
+/** @ingroup rpm */
+typedef enum OMX_SUSPENSIONTYPE {
+    OMX_NotSuspended, /**< component is not suspended */
+    OMX_Suspended,    /**< component is suspended */
+    OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_SuspendMax = 0x7FFFFFFF
+} OMX_SUSPENSIONTYPE;
+
+/** @ingroup rpm */
+typedef struct OMX_PARAM_SUSPENSIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_SUSPENSIONTYPE eType;
+} OMX_PARAM_SUSPENSIONTYPE ;
+
+typedef struct OMX_CONFIG_BOOLEANTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bEnabled;
+} OMX_CONFIG_BOOLEANTYPE;
+
+/* Parameter specifying the content uri to use. */
+/** @ingroup cp */
+typedef struct OMX_PARAM_CONTENTURITYPE
+{
+    OMX_U32 nSize;                      /**< size of the structure in bytes, including
+                                             actual URI name */
+    OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
+    OMX_U8 contentURI[1];               /**< The URI name */
+} OMX_PARAM_CONTENTURITYPE;
+
+/* Parameter specifying the pipe to use. */
+/** @ingroup cp */
+typedef struct OMX_PARAM_CONTENTPIPETYPE
+{
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_HANDLETYPE hPipe;       /**< The pipe handle*/
+} OMX_PARAM_CONTENTPIPETYPE;
+
+/** @ingroup rpm */
+typedef struct OMX_RESOURCECONCEALMENTTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment
+                                            methods (like degrading algorithm quality to
+                                            lower resource consumption or functional bypass)
+                                            on a component as a resolution to resource conflicts. */
+} OMX_RESOURCECONCEALMENTTYPE;
+
+
+/** @ingroup metadata */
+typedef enum OMX_METADATACHARSETTYPE {
+    OMX_MetadataCharsetUnknown = 0,
+    OMX_MetadataCharsetASCII,
+    OMX_MetadataCharsetBinary,
+    OMX_MetadataCharsetCodePage1252,
+    OMX_MetadataCharsetUTF8,
+    OMX_MetadataCharsetJavaConformantUTF8,
+    OMX_MetadataCharsetUTF7,
+    OMX_MetadataCharsetImapUTF7,
+    OMX_MetadataCharsetUTF16LE,
+    OMX_MetadataCharsetUTF16BE,
+    OMX_MetadataCharsetGB12345,
+    OMX_MetadataCharsetHZGB2312,
+    OMX_MetadataCharsetGB2312,
+    OMX_MetadataCharsetGB18030,
+    OMX_MetadataCharsetGBK,
+    OMX_MetadataCharsetBig5,
+    OMX_MetadataCharsetISO88591,
+    OMX_MetadataCharsetISO88592,
+    OMX_MetadataCharsetISO88593,
+    OMX_MetadataCharsetISO88594,
+    OMX_MetadataCharsetISO88595,
+    OMX_MetadataCharsetISO88596,
+    OMX_MetadataCharsetISO88597,
+    OMX_MetadataCharsetISO88598,
+    OMX_MetadataCharsetISO88599,
+    OMX_MetadataCharsetISO885910,
+    OMX_MetadataCharsetISO885913,
+    OMX_MetadataCharsetISO885914,
+    OMX_MetadataCharsetISO885915,
+    OMX_MetadataCharsetShiftJIS,
+    OMX_MetadataCharsetISO2022JP,
+    OMX_MetadataCharsetISO2022JP1,
+    OMX_MetadataCharsetISOEUCJP,
+    OMX_MetadataCharsetSMS7Bit,
+    OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_MetadataCharsetVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
+} OMX_METADATACHARSETTYPE;
+
+/** @ingroup metadata */
+typedef enum OMX_METADATASCOPETYPE
+{
+    OMX_MetadataScopeAllLevels,
+    OMX_MetadataScopeTopLevel,
+    OMX_MetadataScopePortLevel,
+    OMX_MetadataScopeNodeLevel,
+    OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_MetadataScopeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MetadataScopeTypeMax = 0x7fffffff
+} OMX_METADATASCOPETYPE;
+
+/** @ingroup metadata */
+typedef enum OMX_METADATASEARCHMODETYPE
+{
+    OMX_MetadataSearchValueSizeByIndex,
+    OMX_MetadataSearchItemByIndex,
+    OMX_MetadataSearchNextItemByKey,
+    OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MetadataSearchTypeMax = 0x7fffffff
+} OMX_METADATASEARCHMODETYPE;
+/** @ingroup metadata */
+typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_METADATASCOPETYPE eScopeMode;
+    OMX_U32 nScopeSpecifier;
+    OMX_U32 nMetadataItemCount;
+} OMX_CONFIG_METADATAITEMCOUNTTYPE;
+
+/** @ingroup metadata */
+typedef struct OMX_CONFIG_METADATAITEMTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_METADATASCOPETYPE eScopeMode;
+    OMX_U32 nScopeSpecifier;
+    OMX_U32 nMetadataItemIndex;
+    OMX_METADATASEARCHMODETYPE eSearchMode;
+    OMX_METADATACHARSETTYPE eKeyCharset;
+    OMX_U8 nKeySizeUsed;
+    OMX_U8 nKey[128];
+    OMX_METADATACHARSETTYPE eValueCharset;
+    OMX_STRING sLanguageCountry;
+    OMX_U32 nValueMaxSize;
+    OMX_U32 nValueSizeUsed;
+    OMX_U8 nValue[1];
+} OMX_CONFIG_METADATAITEMTYPE;
+
+/* @ingroup metadata */
+typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bAllKeys;
+    OMX_U32 nParentNodeID;
+    OMX_U32 nNumNodes;
+} OMX_CONFIG_CONTAINERNODECOUNTTYPE;
+
+/** @ingroup metadata */
+typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bAllKeys;
+    OMX_U32 nParentNodeID;
+    OMX_U32 nNodeIndex;
+    OMX_U32 nNodeID;
+    OMX_STRING cNodeName;
+    OMX_BOOL bIsLeafType;
+} OMX_CONFIG_CONTAINERNODEIDTYPE;
+
+/** @ingroup metadata */
+typedef struct OMX_PARAM_METADATAFILTERTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bAllKeys;	/* if true then this structure refers to all keys and
+                         * the three key fields below are ignored */
+    OMX_METADATACHARSETTYPE eKeyCharset;
+    OMX_U32 nKeySizeUsed;
+    OMX_U8   nKey [128];
+    OMX_U32 nLanguageCountrySizeUsed;
+    OMX_U8 nLanguageCountry[128];
+    OMX_BOOL bEnabled;	/* if true then key is part of filter (e.g.
+                         * retained for query later). If false then
+                         * key is not part of filter */
+} OMX_PARAM_METADATAFILTERTYPE;
+
+/** The OMX_HANDLETYPE structure defines the component handle.  The component
+ *  handle is used to access all of the component's public methods and also
+ *  contains pointers to the component's private data area.  The component
+ *  handle is initialized by the OMX core (with help from the component)
+ *  during the process of loading the component.  After the component is
+ *  successfully loaded, the application can safely access any of the
+ *  component's public functions (although some may return an error because
+ *  the state is inappropriate for the access).
+ *
+ *  @ingroup comp
+ */
+typedef struct OMX_COMPONENTTYPE
+{
+    /** The size of this structure, in bytes.  It is the responsibility
+        of the allocator of this structure to fill in this value.  Since
+        this structure is allocated by the GetHandle function, this
+        function will fill in this value. */
+    OMX_U32 nSize;
+
+    /** nVersion is the version of the OMX specification that the structure
+        is built against.  It is the responsibility of the creator of this
+        structure to initialize this value and every user of this structure
+        should verify that it knows how to use the exact version of
+        this structure found herein. */
+    OMX_VERSIONTYPE nVersion;
+
+    /** pComponentPrivate is a pointer to the component private data area.
+        This member is allocated and initialized by the component when the
+        component is first loaded.  The application should not access this
+        data area. */
+    OMX_PTR pComponentPrivate;
+
+    /** pApplicationPrivate is a pointer that is a parameter to the
+        OMX_GetHandle method, and contains an application private value
+        provided by the IL client.  This application private data is
+        returned to the IL Client by OMX in all callbacks */
+    OMX_PTR pApplicationPrivate;
+
+    /** refer to OMX_GetComponentVersion in OMX_core.h or the OMX IL
+        specification for details on the GetComponentVersion method.
+     */
+    OMX_ERRORTYPE (*GetComponentVersion)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_OUT OMX_STRING pComponentName,
+            OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
+            OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
+            OMX_OUT OMX_UUIDTYPE* pComponentUUID);
+
+    /** refer to OMX_SendCommand in OMX_core.h or the OMX IL
+        specification for details on the SendCommand method.
+     */
+    OMX_ERRORTYPE (*SendCommand)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_COMMANDTYPE Cmd,
+            OMX_IN  OMX_U32 nParam1,
+            OMX_IN  OMX_PTR pCmdData);
+
+    /** refer to OMX_GetParameter in OMX_core.h or the OMX IL
+        specification for details on the GetParameter method.
+     */
+    OMX_ERRORTYPE (*GetParameter)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nParamIndex,
+            OMX_INOUT OMX_PTR pComponentParameterStructure);
+
+
+    /** refer to OMX_SetParameter in OMX_core.h or the OMX IL
+        specification for details on the SetParameter method.
+     */
+    OMX_ERRORTYPE (*SetParameter)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex,
+            OMX_IN  OMX_PTR pComponentParameterStructure);
+
+
+    /** refer to OMX_GetConfig in OMX_core.h or the OMX IL
+        specification for details on the GetConfig method.
+     */
+    OMX_ERRORTYPE (*GetConfig)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex,
+            OMX_INOUT OMX_PTR pComponentConfigStructure);
+
+
+    /** refer to OMX_SetConfig in OMX_core.h or the OMX IL
+        specification for details on the SetConfig method.
+     */
+    OMX_ERRORTYPE (*SetConfig)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex,
+            OMX_IN  OMX_PTR pComponentConfigStructure);
+
+
+    /** refer to OMX_GetExtensionIndex in OMX_core.h or the OMX IL
+        specification for details on the GetExtensionIndex method.
+     */
+    OMX_ERRORTYPE (*GetExtensionIndex)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_STRING cParameterName,
+            OMX_OUT OMX_INDEXTYPE* pIndexType);
+
+
+    /** refer to OMX_GetState in OMX_core.h or the OMX IL
+        specification for details on the GetState method.
+     */
+    OMX_ERRORTYPE (*GetState)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_OUT OMX_STATETYPE* pState);
+
+
+    /** The ComponentTunnelRequest method will interact with another OMX
+        component to determine if tunneling is possible and to setup the
+        tunneling.  The return codes for this method can be used to
+        determine if tunneling is not possible, or if tunneling is not
+        supported.
+
+        Base profile components (i.e. non-interop) do not support this
+        method and should return OMX_ErrorNotImplemented
+
+        The interop profile component MUST support tunneling to another
+        interop profile component with a compatible port parameters.
+        A component may also support proprietary communication.
+
+        If proprietary communication is supported the negotiation of
+        proprietary communication is done outside of OMX in a vendor
+        specific way. It is only required that the proper result be
+        returned and the details of how the setup is done is left
+        to the component implementation.
+
+        When this method is invoked when nPort in an output port, the
+        component will:
+        1.  Populate the pTunnelSetup structure with the output port's
+            requirements and constraints for the tunnel.
+
+        When this method is invoked when nPort in an input port, the
+        component will:
+        1.  Query the necessary parameters from the output port to
+            determine if the ports are compatible for tunneling
+        2.  If the ports are compatible, the component should store
+            the tunnel step provided by the output port
+        3.  Determine which port (either input or output) is the buffer
+            supplier, and call OMX_SetParameter on the output port to
+            indicate this selection.
+
+        The component will return from this call within 5 msec.
+
+        @param [in] hComp
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the OMX_GetHandle method.
+        @param [in] nPort
+            nPort is used to select the port on the component to be used
+            for tunneling.
+        @param [in] hTunneledComp
+            Handle of the component to tunnel with.  This is the component
+            handle returned by the call to the OMX_GetHandle method.  When
+            this parameter is 0x0 the component should setup the port for
+            communication with the application / IL Client.
+        @param [in] nPortOutput
+            nPortOutput is used indicate the port the component should
+            tunnel with.
+        @param [in] pTunnelSetup
+            Pointer to the tunnel setup structure.  When nPort is an output port
+            the component should populate the fields of this structure.  When
+            When nPort is an input port the component should review the setup
+            provided by the component with the output port.
+        @return OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+        @ingroup tun
+    */
+
+    OMX_ERRORTYPE (*ComponentTunnelRequest)(
+        OMX_IN  OMX_HANDLETYPE hComp,
+        OMX_IN  OMX_U32 nPort,
+        OMX_IN  OMX_HANDLETYPE hTunneledComp,
+        OMX_IN  OMX_U32 nTunneledPort,
+        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup);
+
+    /** refer to OMX_UseBuffer in OMX_core.h or the OMX IL
+        specification for details on the UseBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*UseBuffer)(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes,
+            OMX_IN OMX_U8* pBuffer);
+
+    /** refer to OMX_AllocateBuffer in OMX_core.h or the OMX IL
+        specification for details on the AllocateBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*AllocateBuffer)(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes);
+
+    /** refer to OMX_FreeBuffer in OMX_core.h or the OMX IL
+        specification for details on the FreeBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FreeBuffer)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_U32 nPortIndex,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** refer to OMX_EmptyThisBuffer in OMX_core.h or the OMX IL
+        specification for details on the EmptyThisBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*EmptyThisBuffer)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** refer to OMX_FillThisBuffer in OMX_core.h or the OMX IL
+        specification for details on the FillThisBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FillThisBuffer)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** The SetCallbacks method is used by the core to specify the callback
+        structure from the application to the component.  This is a blocking
+        call.  The component will return from this call within 5 msec.
+        @param [in] hComponent
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param [in] pCallbacks
+            pointer to an OMX_CALLBACKTYPE structure used to provide the
+            callback information to the component
+        @param [in] pAppData
+            pointer to an application defined value.  It is anticipated that
+            the application will pass a pointer to a data structure or a "this
+            pointer" in this area to allow the callback (in the application)
+            to determine the context of the call
+        @return OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+     */
+    OMX_ERRORTYPE (*SetCallbacks)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_CALLBACKTYPE* pCallbacks,
+            OMX_IN  OMX_PTR pAppData);
+
+    /** ComponentDeInit method is used to deinitialize the component
+        providing a means to free any resources allocated at component
+        initialization.  NOTE:  After this call the component handle is
+        not valid for further use.
+        @param [in] hComponent
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the GetHandle function.
+        @return OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+     */
+    OMX_ERRORTYPE (*ComponentDeInit)(
+            OMX_IN  OMX_HANDLETYPE hComponent);
+
+    /** @ingroup buf */
+    OMX_ERRORTYPE (*UseEGLImage)(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN void* eglImage);
+
+    OMX_ERRORTYPE (*ComponentRoleEnum)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+		OMX_OUT OMX_U8 *cRole,
+		OMX_IN OMX_U32 nIndex);
+
+} OMX_COMPONENTTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/core/inc/khronos/openmax/include/OMX_ContentPipe.h b/core/inc/khronos/openmax/include/OMX_ContentPipe.h
new file mode 100644
index 0000000..403ea55
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_ContentPipe.h
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_ContentPipe.h - OpenMax IL version 1.1.2
+ *  The OMX_ContentPipe header file contains the definitions used to define
+ *  the public interface for content piples.  This header file is intended to
+ *  be used by the component.
+ */
+
+#ifndef OMX_CONTENTPIPE_H
+#define OMX_CONTENTPIPE_H
+
+#ifndef KD_EACCES
+/* OpenKODE error codes. CPResult values may be zero (indicating success
+   or one of the following values) */
+#define KD_EACCES (1)
+#define KD_EADDRINUSE (2)
+#define KD_EAGAIN (5)
+#define KD_EBADF (7)
+#define KD_EBUSY (8)
+#define KD_ECONNREFUSED (9)
+#define KD_ECONNRESET (10)
+#define KD_EDEADLK (11)
+#define KD_EDESTADDRREQ (12)
+#define KD_ERANGE (35)
+#define KD_EEXIST (13)
+#define KD_EFBIG (14)
+#define KD_EHOSTUNREACH (15)
+#define KD_EINVAL (17)
+#define KD_EIO (18)
+#define KD_EISCONN (20)
+#define KD_EISDIR (21)
+#define KD_EMFILE (22)
+#define KD_ENAMETOOLONG (23)
+#define KD_ENOENT (24)
+#define KD_ENOMEM (25)
+#define KD_ENOSPC (26)
+#define KD_ENOSYS (27)
+#define KD_ENOTCONN (28)
+#define KD_EPERM (33)
+#define KD_ETIMEDOUT (36)
+#define KD_EILSEQ (19)
+#endif
+
+/** Map types from OMX standard types only here so interface is as generic as possible. */
+typedef OMX_U32    CPresult;
+typedef char *     CPstring;
+typedef void *     CPhandle;
+typedef OMX_U32    CPuint;
+typedef OMX_S32    CPint;
+typedef char       CPbyte;
+typedef OMX_BOOL   CPbool;
+
+/** enumeration of origin types used in the CP_PIPETYPE's Seek function
+ * @ingroup cp
+ */
+typedef enum CP_ORIGINTYPE {
+    CP_OriginBegin,
+    CP_OriginCur,
+    CP_OriginEnd,
+    CP_OriginKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    CP_OriginVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_OriginMax = 0X7FFFFFFF
+} CP_ORIGINTYPE;
+
+/** enumeration of contact access types used in the CP_PIPETYPE's Open function
+ * @ingroup cp
+ */
+typedef enum CP_ACCESSTYPE {
+    CP_AccessRead,
+    CP_AccessWrite,
+    CP_AccessReadWrite ,
+    CP_AccessKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    CP_AccessVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_AccessMax = 0X7FFFFFFF
+} CP_ACCESSTYPE;
+
+/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function
+ * @ingroup cp
+ */
+typedef enum CP_CHECKBYTESRESULTTYPE
+{
+    CP_CheckBytesOk,                    /**< There are at least the request number
+                                              of bytes available */
+    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes
+                                              and presently lacks sufficient bytes.
+                                              Client will be called when they are
+                                              sufficient bytes are available. */
+    CP_CheckBytesInsufficientBytes  ,     /**< The pipe has retrieved all bytes
+                                              but those available are less than those
+                                              requested */
+    CP_CheckBytesAtEndOfStream,         /**< The pipe has reached the end of stream
+                                              and no more bytes are available. */
+    CP_CheckBytesOutOfBuffers,          /**< All read/write buffers are currently in use. */
+    CP_CheckBytesKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    CP_CheckBytesVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_CheckBytesMax = 0X7FFFFFFF
+} CP_CHECKBYTESRESULTTYPE;
+
+/** enumeration of content pipe events sent to the client callback.
+ * @ingroup cp
+ */
+typedef enum CP_EVENTTYPE{
+    CP_BytesAvailable,      	    /** bytes requested in a CheckAvailableBytes call are now available*/
+    CP_Overflow,  		           /** enumeration of content pipe events sent to the client callback*/
+    CP_PipeDisconnected  ,  		    /** enumeration of content pipe events sent to the client callback*/
+    CP_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    CP_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_EventMax = 0X7FFFFFFF
+} CP_EVENTTYPE;
+
+/** content pipe definition
+ * @ingroup cp
+ */
+typedef struct CP_PIPETYPE
+{
+    /** Open a content stream for reading or writing. */
+    CPresult (*Open)( CPhandle* hContent, CPstring szURI, CP_ACCESSTYPE eAccess );
+
+    /** Close a content stream. */
+    CPresult (*Close)( CPhandle hContent );
+
+    /** Create a content source and open it for writing. */
+    CPresult (*Create)( CPhandle *hContent, CPstring szURI );
+
+    /** Check the that specified number of bytes are available for reading or writing (depending on access type).*/
+    CPresult (*CheckAvailableBytes)( CPhandle hContent, CPuint nBytesRequested, CP_CHECKBYTESRESULTTYPE *eResult );
+
+    /** Seek to certain position in the content relative to the specified origin. */
+    CPresult (*SetPosition)( CPhandle  hContent, CPint nOffset, CP_ORIGINTYPE eOrigin);
+
+    /** Retrieve the current position relative to the start of the content. */
+    CPresult (*GetPosition)( CPhandle hContent, CPuint *pPosition);
+
+    /** Retrieve data of the specified size from the content stream (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency reads. */
+    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize);
+
+    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes.
+       Buffer contains the next block of bytes, as specified by nSize, of the content. nSize also
+       returns the size of the block actually read. Content pointer advances the by the returned size.
+       Note: pipe provides pointer. This function is appropriate for large reads. The client must call
+       ReleaseReadBuffer when done with buffer.
+
+       In some cases the requested block may not reside in contiguous memory within the
+       pipe implementation. For instance if the pipe leverages a circular buffer then the requested
+       block may straddle the boundary of the circular buffer. By default a pipe implementation
+       performs a copy in this case to provide the block to the pipe client in one contiguous buffer.
+       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory
+       boundary. Here the client may retrieve the data in segments over successive calls. */
+    CPresult (*ReadBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint *nSize, CPbool bForbidCopy);
+
+    /** Release a buffer obtained by ReadBuffer back to the pipe. */
+    CPresult (*ReleaseReadBuffer)(CPhandle hContent, CPbyte *pBuffer);
+
+    /** Write data of the specified size to the content (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency writes. */
+    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize);
+
+    /** Retrieve a buffer allocated by the pipe used to write data to the content.
+       Client will fill buffer with output data. Note: pipe provides pointer. This function is appropriate
+       for large writes. The client must call WriteBuffer when done it has filled the buffer with data.*/
+    CPresult (*GetWriteBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint nSize);
+
+    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the
+       the contents of the buffer to content and advance content pointer by the size of the buffer */
+    CPresult (*WriteBuffer)( CPhandle hContent, CPbyte *pBuffer, CPuint nFilledSize);
+
+    /** Register a per-handle client callback with the content pipe. */
+    CPresult (*RegisterCallback)( CPhandle hContent, CPresult (*ClientCallback)(CP_EVENTTYPE eEvent, CPuint iParam));
+
+} CP_PIPETYPE;
+
+#endif
+
diff --git a/core/inc/khronos/openmax/include/OMX_Core.h b/core/inc/khronos/openmax/include/OMX_Core.h
new file mode 100644
index 0000000..6c858e4
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_Core.h
@@ -0,0 +1,1431 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_Core.h - OpenMax IL version 1.1.2
+ *  The OMX_Core header file contains the definitions used by both the
+ *  application and the component to access common items.
+ */
+
+#ifndef OMX_Core_h
+#define OMX_Core_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header shall include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+
+#include <OMX_Index.h>
+
+
+/** The OMX_COMMANDTYPE enumeration is used to specify the action in the
+ *  OMX_SendCommand macro.
+ *  @ingroup core
+ */
+typedef enum OMX_COMMANDTYPE
+{
+    OMX_CommandStateSet,    /**< Change the component state */
+    OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
+    OMX_CommandPortDisable, /**< Disable a port on a component. */
+    OMX_CommandPortEnable,  /**< Enable a port on a component. */
+    OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
+    OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_CommandMax = 0X7FFFFFFF
+} OMX_COMMANDTYPE;
+
+
+
+/** The OMX_STATETYPE enumeration is used to indicate or change the component
+ *  state.  This enumeration reflects the current state of the component when
+ *  used with the OMX_GetState macro or becomes the parameter in a state change
+ *  command when used with the OMX_SendCommand macro.
+ *
+ *  The component will be in the Loaded state after the component is initially
+ *  loaded into memory.  In the Loaded state, the component is not allowed to
+ *  allocate or hold resources other than to build it's internal parameter
+ *  and configuration tables.  The application will send one or more
+ *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
+ *  component and the component will record each of these parameter and
+ *  configuration changes for use later.  When the application sends the
+ *  Idle command, the component will acquire the resources needed for the
+ *  specified configuration and will transition to the idle state if the
+ *  allocation is successful.  If the component cannot successfully
+ *  transition to the idle state for any reason, the state of the component
+ *  shall be fully rolled back to the Loaded state (e.g. all allocated
+ *  resources shall be released).  When the component receives the command
+ *  to go to the Executing state, it shall begin processing buffers by
+ *  sending all input buffers it holds to the application.  While
+ *  the component is in the Idle state, the application may also send the
+ *  Pause command.  If the component receives the pause command while in the
+ *  Idle state, the component shall send all input buffers it holds to the
+ *  application, but shall not begin processing buffers.  This will allow the
+ *  application to prefill buffers.
+ *
+ *  @ingroup comp
+ */
+
+typedef enum OMX_STATETYPE
+{
+    OMX_StateInvalid,      /**< component has detected that it's internal data
+                                structures are corrupted to the point that
+                                it cannot determine it's state properly */
+    OMX_StateLoaded,      /**< component has been loaded but has not completed
+                                initialization.  The OMX_SetParameter macro
+                                and the OMX_GetParameter macro are the only
+                                valid macros allowed to be sent to the
+                                component in this state. */
+    OMX_StateIdle,        /**< component initialization has been completed
+                                successfully and the component is ready to
+                                to start. */
+    OMX_StateExecuting,   /**< component has accepted the start command and
+                                is processing data (if data is available) */
+    OMX_StatePause,       /**< component has received pause command */
+    OMX_StateWaitForResources, /**< component is waiting for resources, either after
+                                preemption or before it gets the resources requested.
+                                See specification for complete details. */
+    OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_StateMax = 0X7FFFFFFF
+} OMX_STATETYPE;
+
+/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These
+ *  errors should cover most of the common failure cases.  However,
+ *  vendors are free to add additional error messages of their own as
+ *  long as they follow these rules:
+ *  1.  Vendor error messages shall be in the range of 0x90000000 to
+ *      0x9000FFFF.
+ *  2.  Vendor error messages shall be defined in a header file provided
+ *      with the component.  No error messages are allowed that are
+ *      not defined.
+ */
+typedef enum OMX_ERRORTYPE
+{
+  OMX_ErrorNone = 0,
+
+  /** There were insufficient resources to perform the requested operation */
+  OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,
+
+  /** There was an error, but the cause of the error could not be determined */
+  OMX_ErrorUndefined = (OMX_S32) 0x80001001,
+
+  /** The component name string was not valid */
+  OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,
+
+  /** No component with the specified name string was found */
+  OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,
+
+  /** The component specified did not have a "OMX_ComponentInit" or
+      "OMX_ComponentDeInit entry point */
+  OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,
+
+  /** One or more parameters were not valid */
+  OMX_ErrorBadParameter = (OMX_S32) 0x80001005,
+
+  /** The requested function is not implemented */
+  OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,
+
+  /** The buffer was emptied before the next buffer was ready */
+  OMX_ErrorUnderflow = (OMX_S32) 0x80001007,
+
+  /** The buffer was not available when it was needed */
+  OMX_ErrorOverflow = (OMX_S32) 0x80001008,
+
+  /** The hardware failed to respond as expected */
+  OMX_ErrorHardware = (OMX_S32) 0x80001009,
+
+  /** The component is in the state OMX_StateInvalid */
+  OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,
+
+  /** Stream is found to be corrupt */
+  OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,
+
+  /** Ports being connected are not compatible */
+  OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,
+
+  /** Resources allocated to an idle component have been
+      lost resulting in the component returning to the loaded state */
+  OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,
+
+  /** No more indicies can be enumerated */
+  OMX_ErrorNoMore = (OMX_S32) 0x8000100E,
+
+  /** The component detected a version mismatch */
+  OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,
+
+  /** The component is not ready to return data at this time */
+  OMX_ErrorNotReady = (OMX_S32) 0x80001010,
+
+  /** There was a timeout that occurred */
+  OMX_ErrorTimeout = (OMX_S32) 0x80001011,
+
+  /** This error occurs when trying to transition into the state you are already in */
+  OMX_ErrorSameState = (OMX_S32) 0x80001012,
+
+  /** Resources allocated to an executing or paused component have been
+      preempted, causing the component to return to the idle state */
+  OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013,
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback)
+      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
+      on a port restart) when it deems that it has waited an unusually long time for the supplier
+      to send it an allocated buffer via a UseBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback)
+      during the deallocation of buffers (on a transition from the IDLE to LOADED state or
+      on a port stop) when it deems that it has waited an unusually long time for the supplier
+      to request the deallocation of a buffer header via a FreeBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,
+
+  /** A supplier port sends this error to the IL client (via the EventHandler callback)
+      during the stopping of a port (either on a transition from the IDLE to LOADED
+      state or a port stop) when it deems that it has waited an unusually long time for
+      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,
+
+  /** Attempting a state transtion that is not allowed */
+  OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,
+
+  /* Attempting a command that is not allowed during the present state. */
+  OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018,
+
+  /** The values encapsulated in the parameter or config structure are not supported. */
+  OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,
+
+  /** The parameter or config indicated by the given index is not supported. */
+  OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,
+
+  /** The port index supplied is incorrect. */
+  OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,
+
+  /** The port has lost one or more of its buffers and it thus unpopulated. */
+  OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,
+
+  /** Component suspended due to temporary loss of resources */
+  OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,
+
+  /** Component suspended due to an inability to acquire dynamic resources */
+  OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,
+
+  /** When the macroblock error reporting is enabled the component returns new error
+  for every frame that has errors */
+  OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,
+
+  /** A component reports this error when it cannot parse or determine the format of an input stream. */
+  OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020,
+
+  /** The content open operation failed. */
+  OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,
+
+  /** The content creation operation failed. */
+  OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,
+
+  /** Separate table information is being used */
+  OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,
+
+  /** Tunneling is unsupported by the component*/
+  OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,
+
+  OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_ErrorMax = 0x7FFFFFFF
+} OMX_ERRORTYPE;
+
+/** @ingroup core */
+typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);
+
+/** @ingroup core */
+typedef struct OMX_COMPONENTREGISTERTYPE
+{
+  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
+  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
+} OMX_COMPONENTREGISTERTYPE;
+
+/** @ingroup core */
+extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];
+
+/** @ingroup rpm */
+typedef struct OMX_PRIORITYMGMTTYPE {
+ OMX_U32 nSize;             /**< size of the structure in bytes */
+ OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+ OMX_U32 nGroupPriority;            /**< Priority of the component group */
+ OMX_U32 nGroupID;                  /**< ID of the component group */
+} OMX_PRIORITYMGMTTYPE;
+
+/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
+#define OMX_MAX_STRINGNAME_SIZE 128
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_COMPONENTROLETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
+} OMX_PARAM_COMPONENTROLETYPE;
+
+/** End of Stream Buffer Flag:
+  *
+  * A component sets EOS when it has no more data to emit on a particular
+  * output port. Thus an output port shall set EOS on the last buffer it
+  * emits. A component's determination of when an output port should
+  * cease sending data is implemenation specific.
+  * @ingroup buf
+  */
+
+#define OMX_BUFFERFLAG_EOS 0x00000001
+
+/** Start Time Buffer Flag:
+ *
+ * The source of a stream (e.g. a demux component) sets the STARTTIME
+ * flag on the buffer that contains the starting timestamp for the
+ * stream. The starting timestamp corresponds to the first data that
+ * should be displayed at startup or after a seek.
+ * The first timestamp of the stream is not necessarily the start time.
+ * For instance, in the case of a seek to a particular video frame,
+ * the target frame may be an interframe. Thus the first buffer of
+ * the stream will be the intra-frame preceding the target frame and
+ * the starttime will occur with the target frame (with any other
+ * required frames required to reconstruct the target intervening).
+ *
+ * The STARTTIME flag is directly associated with the buffer's
+ * timestamp ' thus its association to buffer data and its
+ * propagation is identical to the timestamp's.
+ *
+ * When a Sync Component client receives a buffer with the
+ * STARTTIME flag it shall perform a SetConfig on its sync port
+ * using OMX_ConfigTimeClientStartTime and passing the buffer's
+ * timestamp.
+ *
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_STARTTIME 0x00000002
+
+
+
+/** Decode Only Buffer Flag:
+ *
+ * The source of a stream (e.g. a demux component) sets the DECODEONLY
+ * flag on any buffer that should shall be decoded but should not be
+ * displayed. This flag is used, for instance, when a source seeks to
+ * a target interframe that requires the decode of frames preceding the
+ * target to facilitate the target's reconstruction. In this case the
+ * source would emit the frames preceding the target downstream
+ * but mark them as decode only.
+ *
+ * The DECODEONLY is associated with buffer data and propagated in a
+ * manner identical to the buffer timestamp.
+ *
+ * A component that renders data should ignore all buffers with
+ * the DECODEONLY flag set.
+ *
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_DECODEONLY 0x00000004
+
+
+/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_DATACORRUPT 0x00000008
+
+/* End of Frame: The buffer contains exactly one end of frame and no data
+ *  occurs after the end of frame. This flag is an optional hint. The absence
+ *  of this flag does not imply the absence of an end of frame within the buffer.
+ * @ingroup buf
+*/
+#define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
+
+/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame '
+ *  a frame that has no dependency on any other frame information
+ *  @ingroup buf
+ */
+#define OMX_BUFFERFLAG_SYNCFRAME 0x00000020
+
+/* Extra data present flag: there is extra data appended to the data stream
+ * residing in the buffer
+ * @ingroup buf
+ */
+#define OMX_BUFFERFLAG_EXTRADATA 0x00000040
+
+/** Codec Config Buffer Flag:
+* OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
+* output port when all bytes in the buffer form part or all of a set of
+* codec specific configuration data.  Examples include SPS/PPS nal units
+* for OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
+* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets
+* OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
+* with frame data in the same buffer, and shall send all buffers
+* containing codec configuration bytes before any buffers containing
+* frame data that those configurations bytes describe.
+* If the stream format for a particular codec has a frame specific
+* header at the start of each frame, for example OMX_AUDIO_CodingMP3 or
+* OMX_AUDIO_CodingAAC in ADTS mode, then these shall be presented as
+* normal without setting OMX_BUFFERFLAG_CODECCONFIG.
+ * @ingroup buf
+ */
+#define OMX_BUFFERFLAG_CODECCONFIG 0x00000080
+
+
+
+/** @ingroup buf */
+typedef struct OMX_BUFFERHEADERTYPE
+{
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U8* pBuffer;            /**< Pointer to actual block of memory
+                                     that is acting as the buffer */
+    OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
+    OMX_U32 nFilledLen;         /**< number of bytes currently in the
+                                     buffer */
+    OMX_U32 nOffset;            /**< start offset of valid data in bytes from
+                                     the start of the buffer */
+    OMX_PTR pAppPrivate;        /**< pointer to any data the application
+                                     wants to associate with this buffer */
+    OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
+                                     wants to associate with this buffer */
+    OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
+                                     wants to associate with this buffer */
+    OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
+                                     wants to associate with this buffer */
+    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a
+                                              mark event upon processing this buffer. */
+    OMX_PTR pMarkData;          /**< Application specific data associated with
+                                     the mark sent on a mark event to disambiguate
+                                     this mark from others. */
+    OMX_U32 nTickCount;         /**< Optional entry that the component and
+                                     application can update with a tick count
+                                     when they access the component.  This
+                                     value should be in microseconds.  Since
+                                     this is a value relative to an arbitrary
+                                     starting point, this value cannot be used
+                                     to determine absolute time.  This is an
+                                     optional entry and not all components
+                                     will update it.*/
+ OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample
+                                     starting at the first logical sample
+                                     boundary in the buffer. Timestamps of
+                                     successive samples within the buffer may
+                                     be inferred by adding the duration of the
+                                     of the preceding buffer to the timestamp
+                                     of the preceding buffer.*/
+  OMX_U32     nFlags;           /**< buffer specific flags */
+  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using
+                                     this buffer */
+  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
+                                     this buffer */
+} OMX_BUFFERHEADERTYPE;
+
+/** The OMX_EXTRADATATYPE enumeration is used to define the
+ * possible extra data payload types.
+ * NB: this enum is binary backwards compatible with the previous
+ * OMX_EXTRADATA_QUANT define.  This should be replaced with
+ * OMX_ExtraDataQuantization.
+ */
+typedef enum OMX_EXTRADATATYPE
+{
+   OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */
+   OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
+   OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+   OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_ExtraDataMax = 0x7FFFFFFF
+} OMX_EXTRADATATYPE;
+
+
+typedef struct OMX_OTHER_EXTRADATATYPE  {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_EXTRADATATYPE eType;       /* Extra Data type */
+    OMX_U32 nDataSize;   /* Size of the supporting data to follow */
+    OMX_U8  data[1];     /* Supporting data hint  */
+} OMX_OTHER_EXTRADATATYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PORT_PARAM_TYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPorts;             /**< The number of ports for this component */
+    OMX_U32 nStartPortNumber;   /** first port number for this type of port */
+} OMX_PORT_PARAM_TYPE;
+
+/** @ingroup comp */
+typedef enum OMX_EVENTTYPE
+{
+    OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
+    OMX_EventError,               /**< component has detected an error condition */
+    OMX_EventMark,                /**< component has detected a buffer mark */
+    OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
+    OMX_EventBufferFlag,          /**< component has detected an EOS */
+    OMX_EventResourcesAcquired,   /**< component has been granted resources and is
+                                       automatically starting the state change from
+                                       OMX_StateWaitForResources to OMX_StateIdle. */
+   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
+   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
+   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
+   OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+   OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_EventMax = 0x7FFFFFFF
+} OMX_EVENTTYPE;
+
+typedef struct OMX_CALLBACKTYPE
+{
+    /** The EventHandler method is used to notify the application when an
+        event of interest occurs.  Events are defined in the OMX_EVENTTYPE
+        enumeration.  Please see that enumeration for details of what will
+        be returned for each type of event. Callbacks should not return
+        an error to the component, so if an error occurs, the application
+        shall handle it internally.  This is a blocking call.
+
+        The application should return from this call within 5 msec to avoid
+        blocking the component for an excessively long period of time.
+
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application
+            can have a component specific context when receiving the callback.
+        @param eEvent
+            Event that the component wants to notify the application about.
+        @param nData1
+            nData will be the OMX_ERRORTYPE for an error event and will be
+            an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
+         @param nData2
+            nData2 will hold further information related to the event. Can be OMX_STATETYPE for
+            a OMX_CommandStateSet command or port index for a OMX_PortSettingsChanged event.
+            Default value is 0 if not used. )
+        @param pEventData
+            Pointer to additional event-specific data (see spec for meaning).
+      */
+
+   OMX_ERRORTYPE (*EventHandler)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_EVENTTYPE eEvent,
+        OMX_IN OMX_U32 nData1,
+        OMX_IN OMX_U32 nData2,
+        OMX_IN OMX_PTR pEventData);
+
+    /** The EmptyBufferDone method is used to return emptied buffers from an
+        input port back to the application for reuse.  This is a blocking call
+        so the application should not attempt to refill the buffers during this
+        call, but should queue them and refill them in another thread.  There
+        is no error return, so the application shall handle any errors generated
+        internally.
+
+        The application should return from this call within 5 msec.
+
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was emptied.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*EmptyBufferDone)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** The FillBufferDone method is used to return filled buffers from an
+        output port back to the application for emptying and then reuse.
+        This is a blocking call so the application should not attempt to
+        empty the buffers during this call, but should queue the buffers
+        and empty them in another thread.  There is no error return, so
+        the application shall handle any errors generated internally.  The
+        application shall also update the buffer header to indicate the
+        number of bytes placed into the buffer.
+
+        The application should return from this call within 5 msec.
+
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was filled.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FillBufferDone)(
+        OMX_OUT OMX_HANDLETYPE hComponent,
+        OMX_OUT OMX_PTR pAppData,
+        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
+
+} OMX_CALLBACKTYPE;
+
+/** The OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
+    preference when tunneling between two ports.
+    @ingroup tun buf
+*/
+typedef enum OMX_BUFFERSUPPLIERTYPE
+{
+    OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
+                                              or don't care */
+    OMX_BufferSupplyInput,             /**< input port supplies the buffers */
+    OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
+    OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_BufferSupplyMax = 0x7FFFFFFF
+} OMX_BUFFERSUPPLIERTYPE;
+
+
+/** buffer supplier parameter
+ * @ingroup tun
+ */
+typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
+    OMX_U32 nSize; /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex; /**< port that this structure applies to */
+    OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
+} OMX_PARAM_BUFFERSUPPLIERTYPE;
+
+
+/**< indicates that buffers received by an input port of a tunnel
+     may not modify the data in the buffers
+     @ingroup tun
+ */
+#define OMX_PORTTUNNELFLAG_READONLY 0x00000001
+
+
+/** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
+    port to an input port as part the two ComponentTunnelRequest calls
+    resulting from a OMX_SetupTunnel call from the IL Client.
+    @ingroup tun
+ */
+typedef struct OMX_TUNNELSETUPTYPE
+{
+    OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
+    OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
+} OMX_TUNNELSETUPTYPE;
+
+/* OMX Component headers is included to enable the core to use
+   macros for functions into the component for OMX release 1.0.
+   Developers should not access any structures or data from within
+   the component header directly */
+/* TO BE REMOVED - #include <OMX_Component.h> */
+
+/** GetComponentVersion will return information about the component.
+    This is a blocking call.  This macro will go directly from the
+    application to the component (via a core macro).  The
+    component will return from this call within 5 msec.
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [out] pComponentName
+        pointer to an empty string of length 128 bytes.  The component
+        will write its name into this string.  The name will be
+        terminated by a single zero byte.  The name of a component will
+        be 127 bytes or less to leave room for the trailing zero byte.
+        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
+    @param [out] pComponentVersion
+        pointer to an OMX Version structure that the component will fill
+        in.  The component will fill in a value that indicates the
+        component version.  NOTE: the component version is NOT the same
+        as the OMX Specification version (found in all structures).  The
+        component version is defined by the vendor of the component and
+        its value is entirely up to the component vendor.
+    @param [out] pSpecVersion
+        pointer to an OMX Version structure that the component will fill
+        in.  The SpecVersion is the version of the specification that the
+        component was built against.  Please note that this value may or
+        may not match the structure's version.  For example, if the
+        component was built against the 2.0 specification, but the
+        application (which creates the structure is built against the
+        1.0 specification the versions would be different.
+    @param [out] pComponentUUID
+        pointer to the UUID of the component which will be filled in by
+        the component.  The UUID is a unique identifier that is set at
+        RUN time for the component and is unique to each instantion of
+        the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetComponentVersion(                            \
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                                     \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetComponentVersion(  \
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                 /* Macro End */
+
+
+/** Send a command to the component.  This call is a non-blocking call.
+    The component should check the parameters and then queue the command
+    to the component thread to be executed.  The component thread shall
+    send the EventHandler() callback at the conclusion of the command.
+    This macro will go directly from the application to the component (via
+    a core macro).  The component will return from this call within 5 msec.
+
+    When the command is "OMX_CommandStateSet" the component will queue a
+    state transition to the new state idenfied in nParam.
+
+    When the command is "OMX_CommandFlush", to flush a port's buffer queues,
+    the command will force the component to return all buffers NOT CURRENTLY
+    BEING PROCESSED to the application, in the order in which the buffers
+    were received.
+
+    When the command is "OMX_CommandPortDisable" or
+    "OMX_CommandPortEnable", the component's port (given by the value of
+    nParam) will be stopped or restarted.
+
+    When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
+    pCmdData will point to a OMX_MARKTYPE structure containing the component
+    handle of the component to examine the buffer chain for the mark.  nParam1
+    contains the index of the port on which the buffer mark is applied.
+
+    Specification text for more details.
+
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [in] Cmd
+        Command for the component to execute
+    @param [in] nParam
+        Parameter for the command to be executed.  When Cmd has the value
+        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has
+        the value OMX_CommandFlush, value of nParam indicates which port(s)
+        to flush. -1 is used to flush all ports a single port index will
+        only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
+        or "OMX_CommandPortEnable", the component's port is given by
+        the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
+        the components pot is given by the value of nParam.
+    @param [in] pCmdData
+        Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
+        "OMX_CommandMarkBuffer".
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SendCommand(                                    \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                                          \
+     ((OMX_COMPONENTTYPE*)hComponent)->SendCommand(         \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                          /* Macro End */
+
+
+/** The OMX_GetParameter macro will get one of the current parameter
+    settings from the component.  This macro cannot only be invoked when
+    the component is in the OMX_StateInvalid state.  The nParamIndex
+    parameter is used to indicate which structure is being requested from
+    the component.  The application shall allocate the correct structure
+    and shall fill in the structure size and version information before
+    invoking this macro.  When the parameter applies to a port, the
+    caller shall fill in the appropriate nPortIndex value indicating the
+    port on which the parameter applies. If the component has not had
+    any settings changed, then the component should return a set of
+    valid DEFAULT  parameters for the component.  This is a blocking
+    call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nParamIndex
+        Index of the structure to be filled.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentParameterStructure
+        Pointer to application allocated structure to be filled by the
+        component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetParameter(         \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The OMX_SetParameter macro will send an initialization parameter
+    structure to a component.  Each structure shall be sent one at a time,
+    in a separate invocation of the macro.  This macro can only be
+    invoked when the component is in the OMX_StateLoaded state, or the
+    port is disabled (when the parameter applies to a port). The
+    nParamIndex parameter is used to indicate which structure is being
+    passed to the component.  The application shall allocate the
+    correct structure and shall fill in the structure size and version
+    information (as well as the actual data) before invoking this macro.
+    The application is free to dispose of this structure after the call
+    as the component is required to copy any data it shall retain.  This
+    is a blocking call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be sent.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in] pComponentParameterStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->SetParameter(         \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The OMX_GetConfig macro will get one of the configuration structures
+    from a component.  This macro can be invoked anytime after the
+    component has been loaded.  The nParamIndex call parameter is used to
+    indicate which structure is being requested from the component.  The
+    application shall allocate the correct structure and shall fill in the
+    structure size and version information before invoking this macro.
+    If the component has not had this configuration parameter sent before,
+    then the component should return a set of valid DEFAULT values for the
+    component.  This is a blocking call.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be filled.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentConfigStructure
+        pointer to application allocated structure to be filled by the
+        component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+*/
+#define OMX_GetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                           \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetConfig(            \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The OMX_SetConfig macro will send one of the configuration
+    structures to a component.  Each structure shall be sent one at a time,
+    each in a separate invocation of the macro.  This macro can be invoked
+    anytime after the component has been loaded.  The application shall
+    allocate the correct structure and shall fill in the structure size
+    and version information (as well as the actual data) before invoking
+    this macro.  The application is free to dispose of this structure after
+    the call as the component is required to copy any data it shall retain.
+    This is a blocking call.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nConfigIndex
+        Index of the structure to be sent.  This value is from the
+        OMX_INDEXTYPE enumeration above.
+    @param [in] pComponentConfigStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                           \
+    ((OMX_COMPONENTTYPE*)hComponent)->SetConfig(            \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The OMX_GetExtensionIndex macro will invoke a component to translate
+    a vendor specific configuration or parameter string into an OMX
+    structure index.  There is no requirement for the vendor to support
+    this command for the indexes already found in the OMX_INDEXTYPE
+    enumeration (this is done to save space in small components).  The
+    component shall support all vendor supplied extension indexes not found
+    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @param [in] cParameterName
+        OMX_STRING that shall be less than 128 characters long including
+        the trailing null byte.  This is the string that will get
+        translated by the component into a configuration index.
+    @param [out] pIndexType
+        a pointer to a OMX_INDEXTYPE to receive the index value.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetExtensionIndex(                              \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex(    \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                     /* Macro End */
+
+
+/** The OMX_GetState macro will invoke the component to get the current
+    state of the component and place the state value into the location
+    pointed to by pState.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] pState
+        pointer to the location to receive the state.  The value returned
+        is one of the OMX_STATETYPE members
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetState(                                       \
+        hComponent,                                         \
+        pState)                                             \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetState(             \
+        hComponent,                                         \
+        pState)                         /* Macro End */
+
+
+/** The OMX_UseBuffer macro will request that the component use
+    a buffer (and allocate its own buffer header) already allocated
+    by another component, or by the IL Client. This is a blocking
+    call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the
+        pointer to the buffer header
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+
+#define OMX_UseBuffer(                                      \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->UseBuffer(            \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)
+
+
+/** The OMX_AllocateBuffer macro will request that the component allocate
+    a new buffer and buffer header.  The component will allocate the
+    buffer and the buffer header and return a pointer to the buffer
+    header.  This is a blocking call.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive
+        the pointer to the buffer header
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the
+        buffer header structure.
+    @param [in] nSizeBytes
+        size of the buffer to allocate.  Used when bAllocateNew is true.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_AllocateBuffer(                                 \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->AllocateBuffer(       \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                     /* Macro End */
+
+
+/** The OMX_FreeBuffer macro will release a buffer header from the component
+    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If
+    the component allocated the buffer (see the OMX_UseBuffer macro) then
+    the component shall free the buffer and buffer header. This is a
+    blocking call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_FreeBuffer(                                     \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer(           \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an
+    input port of a component.  The buffer will be emptied by the component
+    and returned to the application via the EmptyBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then empty the buffer, later, at the proper
+    time.  As expected, this macro may be invoked only while the component
+    is in the OMX_StateExecuting.  If nPortIndex does not specify an input
+    port, the component shall return an error.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_EmptyThisBuffer(                                \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer(      \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The OMX_FillThisBuffer macro will send an empty buffer to an
+    output port of a component.  The buffer will be filled by the component
+    and returned to the application via the FillBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then fill the buffer, later, at the proper
+    time.  As expected, this macro may be invoked only while the component
+    is in the OMX_ExecutingState.  If nPortIndex does not specify an output
+    port, the component shall return an error.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_FillThisBuffer(                                 \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer(       \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+
+/** The OMX_UseEGLImage macro will request that the component use
+    a EGLImage provided by EGL (and allocate its own buffer header)
+    This is a blocking call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the
+        pointer to the buffer header.  Note that the memory location used
+        for this buffer is NOT visible to the IL Client.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the
+        buffer header structure.
+    @param [in] eglImage
+        eglImage contains the handle of the EGLImage to use as a buffer on the
+        specified port.  The component is expected to validate properties of
+        the EGLImage against the configuration of the port to ensure the component
+        can use the EGLImage as a buffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_UseEGLImage(                                    \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)                                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->UseEGLImage(          \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)
+
+/** The OMX_Init method is used to initialize the OMX core.  It shall be the
+    first call made into OMX and it should only be executed one time without
+    an interviening OMX_Deinit call.
+
+    The core should return from this call within 20 msec.
+
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);
+
+
+/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be
+    the last call made into OMX. In the event that the core determines that
+    thare are components loaded when this call is made, the core may return
+    with an error rather than try to unload the components.
+
+    The core should return from this call within 20 msec.
+
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void);
+
+
+/** The OMX_ComponentNameEnum method will enumerate through all the names of
+    recognised valid components in the system. This function is provided
+    as a means to detect all the components in the system run-time. There is
+    no strict ordering to the enumeration order of component names, although
+    each name will only be enumerated once.  If the OMX core supports run-time
+    installation of new components, it is only requried to detect newly
+    installed components when the first call to enumerate component names
+    is made (i.e. when nIndex is 0x0).
+
+    The core should return from this call in 20 msec.
+
+    @param [out] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are
+        assigned by the vendor, but shall start with "OMX." and then have
+        the Vendor designation next.
+    @param [in] nNameLength
+        number of characters in the cComponentName string.  With all
+        component name strings restricted to less than 128 characters
+        (including the trailing null) it is recomended that the caller
+        provide a input string for the cComponentName of 128 characters.
+    @param [in] nIndex
+        number containing the enumeration index for the component.
+        Multiple calls to OMX_ComponentNameEnum with increasing values
+        of nIndex will enumerate through the component names in the
+        system until OMX_ErrorNoMore is returned.  The value of nIndex
+        is 0 to (N-1), where N is the number of valid installed components
+        in the system.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  When the value of nIndex exceeds the number of
+        components in the system minus 1, OMX_ErrorNoMore will be
+        returned. Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
+    OMX_OUT OMX_STRING cComponentName,
+    OMX_IN  OMX_U32 nNameLength,
+    OMX_IN  OMX_U32 nIndex);
+
+
+/** The OMX_GetHandle method will locate the component specified by the
+    component name given, load that component into memory and then invoke
+    the component's methods to create an instance of the component.
+
+    The core should return from this call within 20 msec.
+
+    @param [out] pHandle
+        pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
+    @param [in] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are
+        assigned by the vendor, but shall start with "OMX." and then have
+        the Vendor designation next.
+    @param [in] pAppData
+        pointer to an application defined value that will be returned
+        during callbacks so that the application can identify the source
+        of the callback.
+    @param [in] pCallBacks
+        pointer to a OMX_CALLBACKTYPE structure that will be passed to the
+        component to initialize it with.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
+    OMX_OUT OMX_HANDLETYPE* pHandle,
+    OMX_IN  OMX_STRING cComponentName,
+    OMX_IN  OMX_PTR pAppData,
+    OMX_IN  OMX_CALLBACKTYPE* pCallBacks);
+
+
+/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle
+    method.  If the component reference count goes to zero, the component will
+    be unloaded from memory.
+
+    The core should return from this call within 20 msec when the component is
+    in the OMX_StateLoaded state.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
+    OMX_IN  OMX_HANDLETYPE hComponent);
+
+
+
+/** The OMX_SetupTunnel method will handle the necessary calls to the components
+    to setup the specified tunnel the two components.  NOTE: This is
+    an actual method (not a #define macro).  This method will make calls into
+    the component ComponentTunnelRequest method to do the actual tunnel
+    connection.
+
+    The ComponentTunnelRequest method on both components will be called.
+    This method shall not be called unless the component is in the
+    OMX_StateLoaded state except when the ports used for the tunnel are
+    disabled. In this case, the component may be in the OMX_StateExecuting,
+    OMX_StatePause, or OMX_StateIdle states.
+
+    The core should return from this call within 20 msec.
+
+    @param [in] hOutput
+        Handle of the component to be accessed.  Also this is the handle
+        of the component whose port, specified in the nPortOutput parameter
+        will be used the source for the tunnel. This is the component handle
+        returned by the call to the OMX_GetHandle function.  There is a
+        requirement that hOutput be the source for the data when
+        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
+        specified in hInput will have it's port specified in nPortInput
+        setup for communication with the application / IL client.
+    @param [in] nPortOutput
+        nPortOutput is used to select the source port on component to be
+        used in the tunnel.
+    @param [in] hInput
+        This is the component to setup the tunnel with. This is the handle
+        of the component whose port, specified in the nPortInput parameter
+        will be used the destination for the tunnel. This is the component handle
+        returned by the call to the OMX_GetHandle function.  There is a
+        requirement that hInput be the destination for the data when
+        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
+        specified in hOutput will have it's port specified in nPortPOutput
+        setup for communication with the application / IL client.
+    @param [in] nPortInput
+        nPortInput is used to select the destination port on component to be
+        used in the tunnel.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+        When OMX_ErrorNotImplemented is returned, one or both components is
+        a non-interop component and does not support tunneling.
+
+        On failure, the ports of both components are setup for communication
+        with the application / IL Client.
+    @ingroup core tun
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
+    OMX_IN  OMX_HANDLETYPE hOutput,
+    OMX_IN  OMX_U32 nPortOutput,
+    OMX_IN  OMX_HANDLETYPE hInput,
+    OMX_IN  OMX_U32 nPortInput);
+
+/** @ingroup cp */
+OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
+    OMX_OUT OMX_HANDLETYPE *hPipe,
+    OMX_IN OMX_STRING szURI);
+
+/** The OMX_GetComponentsOfRole method will return the number of components that support the given
+    role and (if the compNames field is non-NULL) the names of those components. The call will fail if
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the compNames field NULL to determine the number of component names
+        * second call this function with the compNames field pointing to an array of names allocated
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+
+    @param [in] role
+        This is generic standard component name consisting only of component class
+        name and the type within that class (e.g. 'audio_decoder.aac').
+    @param [inout] pNumComps
+        This is used both as input and output.
+
+        If compNames is NULL, the input is ignored and the output specifies how many components support
+        the given role.
+
+        If compNames is not NULL, on input it bounds the size of the input structure and
+        on output, it specifies the number of components string names listed within the compNames parameter.
+    @param [inout] compNames
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts
+        a list of the names of all physical components that implement the specified standard component name.
+        Each name is NULL terminated. numComps indicates the number of names.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole (
+	OMX_IN      OMX_STRING role,
+    OMX_INOUT   OMX_U32 *pNumComps,
+    OMX_INOUT   OMX_U8  **compNames);
+
+/** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
+    component and (if the roles field is non-NULL) the names of those roles. The call will fail if
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the roles field NULL to determine the number of role names
+        * second call this function with the roles field pointing to an array of names allocated
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+
+    @param [in] compName
+        This is the name of the component being queried about.
+    @param [inout] pNumRoles
+        This is used both as input and output.
+
+        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
+
+        If compNames is not NULL, on input it bounds the size of the input structure and
+        on output, it specifies the number of roles string names listed within the roles parameter.
+    @param [out] roles
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings
+        which accepts a list of the names of all standard components roles implemented on the
+        specified component name. numComps indicates the number of names.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent (
+	OMX_IN      OMX_STRING compName,
+    OMX_INOUT   OMX_U32 *pNumRoles,
+    OMX_OUT     OMX_U8 **roles);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/core/inc/khronos/openmax/include/OMX_IVCommon.h b/core/inc/khronos/openmax/include/OMX_IVCommon.h
new file mode 100644
index 0000000..c86baf1
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_IVCommon.h
@@ -0,0 +1,953 @@
+/**
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/**
+ * @file OMX_IVCommon.h - OpenMax IL version 1.1.2
+ *  The structures needed by Video and Image components to exchange
+ *  parameters and configuration data with the components.
+ */
+#ifndef OMX_IVCommon_h
+#define OMX_IVCommon_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/**
+ * Each OMX header must include all required header files to allow the header
+ * to compile without errors.  The includes below are required for this header
+ * file to compile successfully
+ */
+
+#include <OMX_Core.h>
+
+/** @defgroup iv OpenMAX IL Imaging and Video Domain
+ * Common structures for OpenMAX IL Imaging and Video domains
+ * @{
+ */
+
+
+/**
+ * Enumeration defining possible uncompressed image/video formats.
+ *
+ * ENUMS:
+ *  Unused                 : Placeholder value when format is N/A
+ *  Monochrome             : black and white
+ *  8bitRGB332             : Red 7:5, Green 4:2, Blue 1:0
+ *  12bitRGB444            : Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB4444          : Alpha 15:12, Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB1555          : Alpha 15, Red 14:10, Green 9:5, Blue 4:0
+ *  16bitRGB565            : Red 15:11, Green 10:5, Blue 4:0
+ *  16bitBGR565            : Blue 15:11, Green 10:5, Red 4:0
+ *  18bitRGB666            : Red 17:12, Green 11:6, Blue 5:0
+ *  18bitARGB1665          : Alpha 17, Red 16:11, Green 10:5, Blue 4:0
+ *  19bitARGB1666          : Alpha 18, Red 17:12, Green 11:6, Blue 5:0
+ *  24bitRGB888            : Red 24:16, Green 15:8, Blue 7:0
+ *  24bitBGR888            : Blue 24:16, Green 15:8, Red 7:0
+ *  24bitARGB1887          : Alpha 23, Red 22:15, Green 14:7, Blue 6:0
+ *  25bitARGB1888          : Alpha 24, Red 23:16, Green 15:8, Blue 7:0
+ *  32bitBGRA8888          : Blue 31:24, Green 23:16, Red 15:8, Alpha 7:0
+ *  32bitARGB8888          : Alpha 31:24, Red 23:16, Green 15:8, Blue 7:0
+ *  YUV411Planar           : U,Y are subsampled by a factor of 4 horizontally
+ *  YUV411PackedPlanar     : packed per payload in planar slices
+ *  YUV420Planar           : Three arrays Y,U,V.
+ *  YUV420PackedPlanar     : packed per payload in planar slices
+ *  YUV420SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YUV422Planar           : Three arrays Y,U,V.
+ *  YUV422PackedPlanar     : packed per payload in planar slices
+ *  YUV422SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YCbYCr                 : Organized as 16bit YUYV (i.e. YCbYCr)
+ *  YCrYCb                 : Organized as 16bit YVYU (i.e. YCrYCb)
+ *  CbYCrY                 : Organized as 16bit UYVY (i.e. CbYCrY)
+ *  CrYCbY                 : Organized as 16bit VYUY (i.e. CrYCbY)
+ *  YUV444Interleaved      : Each pixel contains equal parts YUV
+ *  RawBayer8bit           : SMIA camera output format
+ *  RawBayer10bit          : SMIA camera output format
+ *  RawBayer8bitcompressed : SMIA camera output format
+ */
+typedef enum OMX_COLOR_FORMATTYPE {
+    OMX_COLOR_FormatUnused,
+    OMX_COLOR_FormatMonochrome,
+    OMX_COLOR_Format8bitRGB332,
+    OMX_COLOR_Format12bitRGB444,
+    OMX_COLOR_Format16bitARGB4444,
+    OMX_COLOR_Format16bitARGB1555,
+    OMX_COLOR_Format16bitRGB565,
+    OMX_COLOR_Format16bitBGR565,
+    OMX_COLOR_Format18bitRGB666,
+    OMX_COLOR_Format18bitARGB1665,
+    OMX_COLOR_Format19bitARGB1666,
+    OMX_COLOR_Format24bitRGB888,
+    OMX_COLOR_Format24bitBGR888,
+    OMX_COLOR_Format24bitARGB1887,
+    OMX_COLOR_Format25bitARGB1888,
+    OMX_COLOR_Format32bitBGRA8888,
+    OMX_COLOR_Format32bitARGB8888,
+    OMX_COLOR_FormatYUV411Planar,
+    OMX_COLOR_FormatYUV411PackedPlanar,
+    OMX_COLOR_FormatYUV420Planar,
+    OMX_COLOR_FormatYUV420PackedPlanar,
+    OMX_COLOR_FormatYUV420SemiPlanar,
+    OMX_COLOR_FormatYUV422Planar,
+    OMX_COLOR_FormatYUV422PackedPlanar,
+    OMX_COLOR_FormatYUV422SemiPlanar,
+    OMX_COLOR_FormatYCbYCr,
+    OMX_COLOR_FormatYCrYCb,
+    OMX_COLOR_FormatCbYCrY,
+    OMX_COLOR_FormatCrYCbY,
+    OMX_COLOR_FormatYUV444Interleaved,
+    OMX_COLOR_FormatRawBayer8bit,
+    OMX_COLOR_FormatRawBayer10bit,
+    OMX_COLOR_FormatRawBayer8bitcompressed,
+    OMX_COLOR_FormatL2,
+    OMX_COLOR_FormatL4,
+    OMX_COLOR_FormatL8,
+    OMX_COLOR_FormatL16,
+    OMX_COLOR_FormatL24,
+    OMX_COLOR_FormatL32,
+    OMX_COLOR_FormatYUV420PackedSemiPlanar,
+    OMX_COLOR_FormatYUV422PackedSemiPlanar,
+    OMX_COLOR_Format18BitBGR666,
+    OMX_COLOR_Format24BitARGB6666,
+    OMX_COLOR_Format24BitABGR6666,
+    OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_COLOR_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_COLOR_FormatMax = 0x7FFFFFFF
+} OMX_COLOR_FORMATTYPE;
+
+
+/**
+ * Defines the matrix for conversion from RGB to YUV or vice versa.
+ * iColorMatrix should be initialized with the fixed point values
+ * used in converting between formats.
+ */
+typedef struct OMX_CONFIG_COLORCONVERSIONTYPE {
+    OMX_U32 nSize;              /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */
+    OMX_U32 nPortIndex;         /**< Port that this struct applies to */
+    OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
+    OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
+}OMX_CONFIG_COLORCONVERSIONTYPE;
+
+
+/**
+ * Structure defining percent to scale each frame dimension.  For example:
+ * To make the width 50% larger, use fWidth = 1.5 and to make the width
+ * 1/2 the original size, use fWidth = 0.5
+ */
+typedef struct OMX_CONFIG_SCALEFACTORTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */
+    OMX_U32 nPortIndex;       /**< Port that this struct applies to */
+    OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
+    OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
+}OMX_CONFIG_SCALEFACTORTYPE;
+
+
+/**
+ * Enumeration of possible image filter types
+ */
+typedef enum OMX_IMAGEFILTERTYPE {
+    OMX_ImageFilterNone,
+    OMX_ImageFilterNoise,
+    OMX_ImageFilterEmboss,
+    OMX_ImageFilterNegative,
+    OMX_ImageFilterSketch,
+    OMX_ImageFilterOilPaint,
+    OMX_ImageFilterHatch,
+    OMX_ImageFilterGpen,
+    OMX_ImageFilterAntialias,
+    OMX_ImageFilterDeRing,
+    OMX_ImageFilterSolarize,
+    OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_ImageFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ImageFilterMax = 0x7FFFFFFF
+} OMX_IMAGEFILTERTYPE;
+
+
+/**
+ * Image filter configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to
+ *  eImageFilter : Image filter type enumeration
+ */
+typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGEFILTERTYPE eImageFilter;
+} OMX_CONFIG_IMAGEFILTERTYPE;
+
+
+/**
+ * Customized U and V for color enhancement
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes
+ *  nVersion          : OMX specification version information
+ *  nPortIndex        : Port that this structure applies to
+ *  bColorEnhancement : Enable/disable color enhancement
+ *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for
+ *                      U component
+ *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for
+ *                      V component
+ */
+typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bColorEnhancement;
+    OMX_U8 nCustomizedU;
+    OMX_U8 nCustomizedV;
+} OMX_CONFIG_COLORENHANCEMENTTYPE;
+
+
+/**
+ * Define color key and color key mask
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
+ *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
+ */
+typedef struct OMX_CONFIG_COLORKEYTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nARGBColor;
+    OMX_U32 nARGBMask;
+} OMX_CONFIG_COLORKEYTYPE;
+
+/*
+** A pointer to this struct is passed to the OMX_SetParameter when the extension
+** index for the 'OMX.google.android.index.enableAndroidNativeBuffers' extension
+** is given.
+**
+** When Android native buffer use is disabled for a port (the default state),
+** the OMX node should operate as normal, and expect UseBuffer calls to set its
+** buffers.  This is the mode that will be used when CPU access to the buffer is
+** required.
+**
+** When Android native buffer use has been enabled for a given port, the video
+** color format for the port is to be interpreted as an Android pixel format
+** rather than an OMX color format.  The node should then expect to receive
+** UseAndroidNativeBuffer calls (via OMX_SetParameter) rather than UseBuffer
+** calls for that port.
+*/
+typedef struct OMX_GOOGLE_ENABLE_ANDROID_BUFFERS{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL enable;
+}OMX_GOOGLE_ENABLE_ANDROID_BUFFERS;
+
+// A pointer to this struct is passed to OMX_GetParameter when the extension
+// index for the 'OMX.google.android.index.getAndroidNativeBufferUsage'
+// extension is given.  The usage bits returned from this query will be used to
+// allocate the Gralloc buffers that get passed to the useAndroidNativeBuffer
+// command.
+typedef struct OMX_GOOGLE_ANDROID_BUFFERS_USAGE {
+    OMX_U32 nSize;              // IN
+    OMX_VERSIONTYPE nVersion;   // IN
+    OMX_U32 nPortIndex;         // IN
+    OMX_U32 nUsage;             // OUT
+}OMX_GOOGLE_ANDROID_BUFFERS_USAGE;
+/**
+ * List of color blend types for pre/post processing
+ *
+ * ENUMS:
+ *  None          : No color blending present
+ *  AlphaConstant : Function is (alpha_constant * src) +
+ *                  (1 - alpha_constant) * dst)
+ *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
+ *  Alternate     : Function is alternating pixels from src and dst
+ *  And           : Function is (src & dst)
+ *  Or            : Function is (src | dst)
+ *  Invert        : Function is ~src
+ */
+typedef enum OMX_COLORBLENDTYPE {
+    OMX_ColorBlendNone,
+    OMX_ColorBlendAlphaConstant,
+    OMX_ColorBlendAlphaPerPixel,
+    OMX_ColorBlendAlternate,
+    OMX_ColorBlendAnd,
+    OMX_ColorBlendOr,
+    OMX_ColorBlendInvert,
+    OMX_ColorBlendKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_ColorBlendVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ColorBlendMax = 0x7FFFFFFF
+} OMX_COLORBLENDTYPE;
+
+
+/**
+ * Color blend configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes
+ *  nVersion          : OMX specification version information
+ *  nPortIndex        : Port that this structure applies to
+ *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
+ *  eColorBlend       : Color blend type enumeration
+ */
+typedef struct OMX_CONFIG_COLORBLENDTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nRGBAlphaConstant;
+    OMX_COLORBLENDTYPE  eColorBlend;
+} OMX_CONFIG_COLORBLENDTYPE;
+
+
+/**
+ * Hold frame dimension
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nWidth     : Frame width in pixels
+ *  nHeight    : Frame height in pixels
+ */
+typedef struct OMX_FRAMESIZETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nWidth;
+    OMX_U32 nHeight;
+} OMX_FRAMESIZETYPE;
+
+
+/**
+ * Rotation configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nRotation  : +/- integer rotation value
+ */
+typedef struct OMX_CONFIG_ROTATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nRotation;
+} OMX_CONFIG_ROTATIONTYPE;
+
+
+/**
+ * Possible mirroring directions for pre/post processing
+ *
+ * ENUMS:
+ *  None       : No mirroring
+ *  Vertical   : Vertical mirroring, flip on X axis
+ *  Horizontal : Horizontal mirroring, flip on Y axis
+ *  Both       : Both vertical and horizontal mirroring
+ */
+typedef enum OMX_MIRRORTYPE {
+    OMX_MirrorNone = 0,
+    OMX_MirrorVertical,
+    OMX_MirrorHorizontal,
+    OMX_MirrorBoth,
+    OMX_MirrorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_MirrorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MirrorMax = 0x7FFFFFFF
+} OMX_MIRRORTYPE;
+
+
+/**
+ * Mirroring configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  eMirror    : Mirror type enumeration
+ */
+typedef struct OMX_CONFIG_MIRRORTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_MIRRORTYPE  eMirror;
+} OMX_CONFIG_MIRRORTYPE;
+
+
+/**
+ * Position information only
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nX         : X coordinate for the point
+ *  nY         : Y coordinate for the point
+ */
+typedef struct OMX_CONFIG_POINTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nX;
+    OMX_S32 nY;
+} OMX_CONFIG_POINTTYPE;
+
+
+/**
+ * Frame size plus position
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nLeft      : X Coordinate of the top left corner of the rectangle
+ *  nTop       : Y Coordinate of the top left corner of the rectangle
+ *  nWidth     : Width of the rectangle
+ *  nHeight    : Height of the rectangle
+ */
+typedef struct OMX_CONFIG_RECTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nLeft;
+    OMX_S32 nTop;
+    OMX_U32 nWidth;
+    OMX_U32 nHeight;
+} OMX_CONFIG_RECTTYPE;
+
+
+/**
+ * Deblocking state; it is required to be set up before starting the codec
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  bDeblocking : Enable/disable deblocking mode
+ */
+typedef struct OMX_PARAM_DEBLOCKINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bDeblocking;
+} OMX_PARAM_DEBLOCKINGTYPE;
+
+
+/**
+ * Stabilization state
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  bStab      : Enable/disable frame stabilization state
+ */
+typedef struct OMX_CONFIG_FRAMESTABTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bStab;
+} OMX_CONFIG_FRAMESTABTYPE;
+
+
+/**
+ * White Balance control type
+ *
+ * STRUCT MEMBERS:
+ *  SunLight : Referenced in JSR-234
+ *  Flash    : Optimal for device's integrated flash
+ */
+typedef enum OMX_WHITEBALCONTROLTYPE {
+    OMX_WhiteBalControlOff = 0,
+    OMX_WhiteBalControlAuto,
+    OMX_WhiteBalControlSunLight,
+    OMX_WhiteBalControlCloudy,
+    OMX_WhiteBalControlShade,
+    OMX_WhiteBalControlTungsten,
+    OMX_WhiteBalControlFluorescent,
+    OMX_WhiteBalControlIncandescent,
+    OMX_WhiteBalControlFlash,
+    OMX_WhiteBalControlHorizon,
+    OMX_WhiteBalControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_WhiteBalControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_WhiteBalControlMax = 0x7FFFFFFF
+} OMX_WHITEBALCONTROLTYPE;
+
+
+/**
+ * White Balance control configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to
+ *  eWhiteBalControl : White balance enumeration
+ */
+typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_WHITEBALCONTROLTYPE eWhiteBalControl;
+} OMX_CONFIG_WHITEBALCONTROLTYPE;
+
+
+/**
+ * Exposure control type
+ */
+typedef enum OMX_EXPOSURECONTROLTYPE {
+    OMX_ExposureControlOff = 0,
+    OMX_ExposureControlAuto,
+    OMX_ExposureControlNight,
+    OMX_ExposureControlBackLight,
+    OMX_ExposureControlSpotLight,
+    OMX_ExposureControlSports,
+    OMX_ExposureControlSnow,
+    OMX_ExposureControlBeach,
+    OMX_ExposureControlLargeAperture,
+    OMX_ExposureControlSmallApperture,
+    OMX_ExposureControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_ExposureControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ExposureControlMax = 0x7FFFFFFF
+} OMX_EXPOSURECONTROLTYPE;
+
+
+/**
+ * White Balance control configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to
+ *  eExposureControl : Exposure control enumeration
+ */
+typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_EXPOSURECONTROLTYPE eExposureControl;
+} OMX_CONFIG_EXPOSURECONTROLTYPE;
+
+
+/**
+ * Defines sensor supported mode.
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nFrameRate : Single shot mode is indicated by a 0
+ *  bOneShot   : Enable for single shot, disable for streaming
+ *  sFrameSize : Framesize
+ */
+typedef struct OMX_PARAM_SENSORMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nFrameRate;
+    OMX_BOOL bOneShot;
+    OMX_FRAMESIZETYPE sFrameSize;
+} OMX_PARAM_SENSORMODETYPE;
+
+
+/**
+ * Defines contrast level
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
+ */
+typedef struct OMX_CONFIG_CONTRASTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nContrast;
+} OMX_CONFIG_CONTRASTTYPE;
+
+
+/**
+ * Defines brightness level
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  nBrightness : 0-100%
+ */
+typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBrightness;
+} OMX_CONFIG_BRIGHTNESSTYPE;
+
+
+/**
+ * Defines backlight level configuration for a video sink, e.g. LCD panel
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nBacklight : Values allowed for backlight 0-100%
+ *  nTimeout   : Number of milliseconds before backlight automatically turns
+ *               off.  A value of 0x0 disables backight timeout
+ */
+typedef struct OMX_CONFIG_BACKLIGHTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBacklight;
+    OMX_U32 nTimeout;
+} OMX_CONFIG_BACKLIGHTTYPE;
+
+
+/**
+ * Defines setting for Gamma
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
+ */
+typedef struct OMX_CONFIG_GAMMATYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nGamma;
+} OMX_CONFIG_GAMMATYPE;
+
+
+/**
+ * Define for setting saturation
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  nSaturation : Values allowed for saturation -100 to 100, zero means
+ *                no change
+ */
+typedef struct OMX_CONFIG_SATURATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nSaturation;
+} OMX_CONFIG_SATURATIONTYPE;
+
+
+/**
+ * Define for setting Lightness
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nLightness : Values allowed for lightness -100 to 100, zero means no
+ *               change
+ */
+typedef struct OMX_CONFIG_LIGHTNESSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nLightness;
+} OMX_CONFIG_LIGHTNESSTYPE;
+
+
+/**
+ * Plane blend configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Index of input port associated with the plane.
+ *  nDepth     : Depth of the plane in relation to the screen. Higher
+ *               numbered depths are "behind" lower number depths.
+ *               This number defaults to the Port Index number.
+ *  nAlpha     : Transparency blending component for the entire plane.
+ *               See blending modes for more detail.
+ */
+typedef struct OMX_CONFIG_PLANEBLENDTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nDepth;
+    OMX_U32 nAlpha;
+} OMX_CONFIG_PLANEBLENDTYPE;
+
+
+/**
+ * Define interlace type
+ *
+ * STRUCT MEMBERS:
+ *  nSize                 : Size of the structure in bytes
+ *  nVersion              : OMX specification version information
+ *  nPortIndex            : Port that this structure applies to
+ *  bEnable               : Enable control variable for this functionality
+ *                          (see below)
+ *  nInterleavePortIndex  : Index of input or output port associated with
+ *                          the interleaved plane.
+ *  pPlanarPortIndexes[4] : Index of input or output planar ports.
+ */
+typedef struct OMX_PARAM_INTERLEAVETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_U32 nInterleavePortIndex;
+} OMX_PARAM_INTERLEAVETYPE;
+
+
+/**
+ * Defines the picture effect used for an input picture
+ */
+typedef enum OMX_TRANSITIONEFFECTTYPE {
+    OMX_EffectNone,
+    OMX_EffectFadeFromBlack,
+    OMX_EffectFadeToBlack,
+    OMX_EffectUnspecifiedThroughConstantColor,
+    OMX_EffectDissolve,
+    OMX_EffectWipe,
+    OMX_EffectUnspecifiedMixOfTwoScenes,
+    OMX_EffectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_EffectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EffectMax = 0x7FFFFFFF
+} OMX_TRANSITIONEFFECTTYPE;
+
+
+/**
+ * Structure used to configure current transition effect
+ *
+ * STRUCT MEMBERS:
+ * nSize      : Size of the structure in bytes
+ * nVersion   : OMX specification version information
+ * nPortIndex : Port that this structure applies to
+ * eEffect    : Effect to enable
+ */
+typedef struct OMX_CONFIG_TRANSITIONEFFECTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_TRANSITIONEFFECTTYPE eEffect;
+} OMX_CONFIG_TRANSITIONEFFECTTYPE;
+
+
+/**
+ * Defines possible data unit types for encoded video data. The data unit
+ * types are used both for encoded video input for playback as well as
+ * encoded video output from recording.
+ */
+typedef enum OMX_DATAUNITTYPE {
+    OMX_DataUnitCodedPicture,
+    OMX_DataUnitVideoSegment,
+    OMX_DataUnitSeveralSegments,
+    OMX_DataUnitArbitraryStreamSection,
+    OMX_DataUnitKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_DataUnitVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DataUnitMax = 0x7FFFFFFF
+} OMX_DATAUNITTYPE;
+
+
+/**
+ * Defines possible encapsulation types for coded video data unit. The
+ * encapsulation information is used both for encoded video input for
+ * playback as well as encoded video output from recording.
+ */
+typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
+    OMX_DataEncapsulationElementaryStream,
+    OMX_DataEncapsulationGenericPayload,
+    OMX_DataEncapsulationRtpPayload,
+    OMX_DataEncapsulationKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_DataEncapsulationVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DataEncapsulationMax = 0x7FFFFFFF
+} OMX_DATAUNITENCAPSULATIONTYPE;
+
+
+/**
+ * Structure used to configure the type of being decoded/encoded
+ */
+typedef struct OMX_PARAM_DATAUNITTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_DATAUNITTYPE eUnitType;
+    OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
+} OMX_PARAM_DATAUNITTYPE;
+
+
+/**
+ * Defines dither types
+ */
+typedef enum OMX_DITHERTYPE {
+    OMX_DitherNone,
+    OMX_DitherOrdered,
+    OMX_DitherErrorDiffusion,
+    OMX_DitherOther,
+    OMX_DitherKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_DitherVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DitherMax = 0x7FFFFFFF
+} OMX_DITHERTYPE;
+
+
+/**
+ * Structure used to configure current type of dithering
+ */
+typedef struct OMX_CONFIG_DITHERTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
+} OMX_CONFIG_DITHERTYPE;
+
+typedef struct OMX_CONFIG_CAPTUREMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;     /**< Port that this structure applies to */
+    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture
+                             *   data as fast as possible (otherwise obey port's frame rate). */
+    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the
+                             *   specified number of frames (otherwise the port does not
+                             *   terminate the capture until instructed to do so by the client).
+                             *   Even if set, the client may manually terminate the capture prior
+                             *   to reaching the limit. */
+    OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
+                               *   valid if bFrameLimited is set). */
+} OMX_CONFIG_CAPTUREMODETYPE;
+
+typedef enum OMX_METERINGTYPE {
+
+    OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
+    OMX_MeteringModeSpot,  	      /**< Spot (partial) metering. */
+    OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
+
+    OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_MeteringVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EVModeMax = 0x7fffffff
+} OMX_METERINGTYPE;
+
+typedef struct OMX_CONFIG_EXPOSUREVALUETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_METERINGTYPE eMetering;
+    OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
+    OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
+    OMX_BOOL bAutoAperture;		/**< Whether aperture number is defined automatically */
+    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */
+    OMX_BOOL bAutoShutterSpeed;	/**< Whether shutter speed is defined automatically */
+    OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
+    OMX_BOOL bAutoSensitivity;	/**< Whether sensitivity is defined automatically */
+} OMX_CONFIG_EXPOSUREVALUETYPE;
+
+/**
+ * Focus region configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  bCenter         : Use center region as focus region of interest
+ *  bLeft           : Use left region as focus region of interest
+ *  bRight          : Use right region as focus region of interest
+ *  bTop            : Use top region as focus region of interest
+ *  bBottom         : Use bottom region as focus region of interest
+ *  bTopLeft        : Use top left region as focus region of interest
+ *  bTopRight       : Use top right region as focus region of interest
+ *  bBottomLeft     : Use bottom left region as focus region of interest
+ *  bBottomRight    : Use bottom right region as focus region of interest
+ */
+typedef struct OMX_CONFIG_FOCUSREGIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bCenter;
+    OMX_BOOL bLeft;
+    OMX_BOOL bRight;
+    OMX_BOOL bTop;
+    OMX_BOOL bBottom;
+    OMX_BOOL bTopLeft;
+    OMX_BOOL bTopRight;
+    OMX_BOOL bBottomLeft;
+    OMX_BOOL bBottomRight;
+} OMX_CONFIG_FOCUSREGIONTYPE;
+
+/**
+ * Focus Status type
+ */
+typedef enum OMX_FOCUSSTATUSTYPE {
+    OMX_FocusStatusOff = 0,
+    OMX_FocusStatusRequest,
+    OMX_FocusStatusReached,
+    OMX_FocusStatusUnableToReach,
+    OMX_FocusStatusLost,
+    OMX_FocusStatusKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_FocusStatusVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_FocusStatusMax = 0x7FFFFFFF
+} OMX_FOCUSSTATUSTYPE;
+
+/**
+ * Focus status configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize               : Size of the structure in bytes
+ *  nVersion            : OMX specification version information
+ *  nPortIndex          : Port that this structure applies to
+ *  eFocusStatus        : Specifies the focus status
+ *  bCenterStatus       : Use center region as focus region of interest
+ *  bLeftStatus         : Use left region as focus region of interest
+ *  bRightStatus        : Use right region as focus region of interest
+ *  bTopStatus          : Use top region as focus region of interest
+ *  bBottomStatus       : Use bottom region as focus region of interest
+ *  bTopLeftStatus      : Use top left region as focus region of interest
+ *  bTopRightStatus     : Use top right region as focus region of interest
+ *  bBottomLeftStatus   : Use bottom left region as focus region of interest
+ *  bBottomRightStatus  : Use bottom right region as focus region of interest
+ */
+typedef struct OMX_PARAM_FOCUSSTATUSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_FOCUSSTATUSTYPE eFocusStatus;
+    OMX_BOOL bCenterStatus;
+    OMX_BOOL bLeftStatus;
+    OMX_BOOL bRightStatus;
+    OMX_BOOL bTopStatus;
+    OMX_BOOL bBottomStatus;
+    OMX_BOOL bTopLeftStatus;
+    OMX_BOOL bTopRightStatus;
+    OMX_BOOL bBottomLeftStatus;
+    OMX_BOOL bBottomRightStatus;
+} OMX_PARAM_FOCUSSTATUSTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/core/inc/khronos/openmax/include/OMX_Image.h b/core/inc/khronos/openmax/include/OMX_Image.h
new file mode 100644
index 0000000..599fb2d
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_Image.h
@@ -0,0 +1,328 @@
+/**
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * @file OMX_Image.h - OpenMax IL version 1.1.2
+ * The structures needed by Image components to exchange parameters and
+ * configuration data with the components.
+ */
+#ifndef OMX_Image_h
+#define OMX_Image_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+
+#include <OMX_IVCommon.h>
+
+/** @defgroup imaging OpenMAX IL Imaging Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Imaging domain
+ * @{
+ */
+
+/**
+ * Enumeration used to define the possible image compression coding.
+ */
+typedef enum OMX_IMAGE_CODINGTYPE {
+    OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
+    OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
+    OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
+    OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
+    OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
+    OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
+    OMX_IMAGE_CodingGIF,         /**< Graphics image format */
+    OMX_IMAGE_CodingPNG,         /**< PNG image format */
+    OMX_IMAGE_CodingLZW,         /**< LZW image format */
+    OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
+    OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_CodingMax = 0x7FFFFFFF
+} OMX_IMAGE_CODINGTYPE;
+
+
+/**
+ * Data structure used to define an image path. The number of image paths
+ * for input and output will vary by type of the image component.
+ *
+ *  Input (aka Source) : Zero Inputs, one Output,
+ *  Splitter           : One Input, 2 or more Outputs,
+ *  Processing Element : One Input, one output,
+ *  Mixer              : 2 or more inputs, one output,
+ *  Output (aka Sink)  : One Input, zero outputs.
+ *
+ * The PortDefinition structure is used to define all of the parameters
+ * necessary for the compliant component to setup an input or an output
+ * image path.  If additional vendor specific data is required, it should
+ * be transmitted to the component using the CustomCommand function.
+ * Compliant components will prepopulate this structure with optimal
+ * values during the OMX_GetParameter() command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on port if
+ *                          uncompressed format is used.  Use 0 for
+ *                          unknown, don't care or variable
+ *  nFrameHeight          : Height of frame to be used on port if
+ *                          uncompressed format is used. Use 0 for
+ *                          unknown, don't care or variable
+ *  nStride               : Number of bytes per span of an image (i.e.
+ *                          indicates the number of bytes to get from
+ *                          span N to span N+1, where negative stride
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of
+ *                          the component. When OMX_IMAGE_CodingUnused is
+ *                          specified, eColorFormat is valid
+ *  eColorFormat          : Decompressed format used by this component
+ *  pNativeWindow         : Platform specific reference for a window object if a
+ *                          display sink , otherwise this field is 0x0.
+ */
+typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;
+    OMX_NATIVE_DEVICETYPE pNativeRender;
+    OMX_U32 nFrameWidth;
+    OMX_U32 nFrameHeight;
+    OMX_S32 nStride;
+    OMX_U32 nSliceHeight;
+    OMX_BOOL bFlagErrorConcealment;
+    OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} OMX_IMAGE_PORTDEFINITIONTYPE;
+
+
+/**
+ * Port format parameter.  This structure is used to enumerate the various
+ * data input/output format supported by the port.
+ *
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the
+ *                       component. When OMX_IMAGE_CodingUnused is specified,
+ *                       eColorFormat is valid
+ *  eColorFormat       : Decompressed format used by this component
+ */
+typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+} OMX_IMAGE_PARAM_PORTFORMATTYPE;
+
+
+/**
+ * Flash control type
+ *
+ * ENUMS
+ *  Torch : Flash forced constantly on
+ */
+typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
+    OMX_IMAGE_FlashControlOn = 0,
+    OMX_IMAGE_FlashControlOff,
+    OMX_IMAGE_FlashControlAuto,
+    OMX_IMAGE_FlashControlRedEyeReduction,
+    OMX_IMAGE_FlashControlFillin,
+    OMX_IMAGE_FlashControlTorch,
+    OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_IMAGE_FlashControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
+} OMX_IMAGE_FLASHCONTROLTYPE;
+
+
+/**
+ * Flash control configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize         : Size of the structure in bytes
+ *  nVersion      : OMX specification version information
+ *  nPortIndex    : Port that this structure applies to
+ *  eFlashControl : Flash control type
+ */
+typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
+} OMX_IMAGE_PARAM_FLASHCONTROLTYPE;
+
+
+/**
+ * Focus control type
+ */
+typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
+    OMX_IMAGE_FocusControlOn = 0,
+    OMX_IMAGE_FocusControlOff,
+    OMX_IMAGE_FocusControlAuto,
+    OMX_IMAGE_FocusControlAutoLock,
+    OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_IMAGE_FocusControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
+} OMX_IMAGE_FOCUSCONTROLTYPE;
+
+
+/**
+ * Focus control configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  eFocusControl   : Focus control
+ *  nFocusSteps     : Focus can take on values from 0 mm to infinity.
+ *                    Interest is only in number of steps over this range.
+ *  nFocusStepIndex : Current focus step index
+ */
+typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_FOCUSCONTROLTYPE eFocusControl;
+    OMX_U32 nFocusSteps;
+    OMX_U32 nFocusStepIndex;
+} OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;
+
+
+/**
+ * Q Factor for JPEG compression, which controls the tradeoff between image
+ * quality and size.  Q Factor provides a more simple means of controlling
+ * JPEG compression quality, without directly programming Quantization
+ * tables for chroma and luma
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1
+ *               produces the smallest, worst quality images, and a factor
+ *               of 100 produces the largest, best quality images.  A
+ *               typical default is 75 for small good quality images
+ */
+typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nQFactor;
+} OMX_IMAGE_PARAM_QFACTORTYPE;
+
+/**
+ * Quantization table type
+ */
+
+typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
+    OMX_IMAGE_QuantizationTableLuma = 0,
+    OMX_IMAGE_QuantizationTableChroma,
+    OMX_IMAGE_QuantizationTableChromaCb,
+    OMX_IMAGE_QuantizationTableChromaCr,
+    OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_IMAGE_QuantizationTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
+} OMX_IMAGE_QUANTIZATIONTABLETYPE;
+
+/**
+ * JPEG quantization tables are used to determine DCT compression for
+ * YUV data, as an alternative to specifying Q factor, providing exact
+ * control of compression
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information
+ *  nPortIndex              : Port that this structure applies to
+ *  eQuantizationTable      : Quantization table type
+ *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored
+ *                            in increasing columns then by rows of data (i.e.
+ *                            row 1, ... row 8). Quantization values are in
+ *                            the range 0-255 and stored in linear order
+ *                            (i.e. the component will zig-zag the
+ *                            quantization table data if required internally)
+ */
+typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_QUANTIZATIONTABLETYPE eQuantizationTable;
+    OMX_U8 nQuantizationMatrix[64];
+} OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;
+
+
+/**
+ * Huffman table type, the same Huffman table is applied for chroma and
+ * luma component
+ */
+typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
+    OMX_IMAGE_HuffmanTableAC = 0,
+    OMX_IMAGE_HuffmanTableDC,
+    OMX_IMAGE_HuffmanTableACLuma,
+    OMX_IMAGE_HuffmanTableACChroma,
+    OMX_IMAGE_HuffmanTableDCLuma,
+    OMX_IMAGE_HuffmanTableDCChroma,
+    OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_IMAGE_HuffmanTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
+} OMX_IMAGE_HUFFMANTABLETYPE;
+
+/**
+ * JPEG Huffman table
+ *
+ * STRUCT MEMBERS:
+ *  nSize                            : Size of the structure in bytes
+ *  nVersion                         : OMX specification version information
+ *  nPortIndex                       : Port that this structure applies to
+ *  eHuffmanTable                    : Huffman table type
+ *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each
+ *                                     possible length
+ *  nHuffmanTable[256]               : 0-255, the size used for AC and DC
+ *                                     HuffmanTable are 16 and 162
+ */
+typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
+    OMX_U8 nNumberOfHuffmanCodeOfLength[16];
+    OMX_U8 nHuffmanTable[256];
+}OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
+
+/** @} */
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/core/inc/khronos/openmax/include/OMX_Index.h b/core/inc/khronos/openmax/include/OMX_Index.h
new file mode 100644
index 0000000..74e8a17
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_Index.h
@@ -0,0 +1,259 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** @file OMX_Index.h - OpenMax IL version 1.1.2
+ *  The OMX_Index header file contains the definitions for both applications
+ *  and components .
+ */
+
+
+#ifndef OMX_Index_h
+#define OMX_Index_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+#include <OMX_Types.h>
+
+
+/** The OMX_INDEXTYPE enumeration is used to select a structure when either
+ *  getting or setting parameters and/or configuration data.  Each entry in
+ *  this enumeration maps to an OMX specified structure.  When the
+ *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
+ *  are used, the second parameter will always be an entry from this enumeration
+ *  and the third entry will be the structure shown in the comments for the entry.
+ *  For example, if the application is initializing a cropping function, the
+ *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter
+ *  and would send a pointer to an initialized OMX_RECTTYPE structure as the
+ *  third parameter.
+ *
+ *  The enumeration entries named with the OMX_Config prefix are sent using
+ *  the OMX_SetConfig command and the enumeration entries named with the
+ *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
+ */
+typedef enum OMX_INDEXTYPE {
+
+    OMX_IndexComponentStartUnused = 0x01000000,
+    OMX_IndexParamPriorityMgmt,             /**< reference: OMX_PRIORITYMGMTTYPE */
+    OMX_IndexParamAudioInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamImageInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamVideoInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamOtherInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamNumAvailableStreams,      /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexParamActiveStream,             /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexParamSuspensionPolicy,         /**< reference: OMX_PARAM_SUSPENSIONPOLICYTYPE */
+    OMX_IndexParamComponentSuspended,       /**< reference: OMX_PARAM_SUSPENSIONTYPE */
+    OMX_IndexConfigCapturing,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
+    OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */
+    OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */
+    OMX_IndexParamContentURI,               /**< reference: OMX_PARAM_CONTENTURITYPE */
+    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */
+    OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
+    OMX_IndexConfigMetadataItemCount,       /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
+    OMX_IndexConfigContainerNodeCount,      /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
+    OMX_IndexConfigMetadataItem,            /**< reference: OMX_CONFIG_METADATAITEMTYPE */
+    OMX_IndexConfigCounterNodeID,           /**< reference: OMX_CONFIG_CONTAINERNODEIDTYPE */
+    OMX_IndexParamMetadataFilterType,       /**< reference: OMX_PARAM_METADATAFILTERTYPE */
+    OMX_IndexParamMetadataKeyFilter,        /**< reference: OMX_PARAM_METADATAFILTERTYPE */
+    OMX_IndexConfigPriorityMgmt,            /**< reference: OMX_PRIORITYMGMTTYPE */
+    OMX_IndexParamStandardComponentRole,    /**< reference: OMX_PARAM_COMPONENTROLETYPE */
+
+    OMX_IndexPortStartUnused = 0x02000000,
+    OMX_IndexParamPortDefinition,           /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
+    OMX_IndexParamCompBufferSupplier,       /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE */
+    OMX_IndexReservedStartUnused = 0x03000000,
+
+    /* Audio parameters and configurations */
+    OMX_IndexAudioStartUnused = 0x04000000,
+    OMX_IndexParamAudioPortFormat,          /**< reference: OMX_AUDIO_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamAudioPcm,                 /**< reference: OMX_AUDIO_PARAM_PCMMODETYPE */
+    OMX_IndexParamAudioAac,                 /**< reference: OMX_AUDIO_PARAM_AACPROFILETYPE */
+    OMX_IndexParamAudioRa,                  /**< reference: OMX_AUDIO_PARAM_RATYPE */
+    OMX_IndexParamAudioMp3,                 /**< reference: OMX_AUDIO_PARAM_MP3TYPE */
+    OMX_IndexParamAudioAdpcm,               /**< reference: OMX_AUDIO_PARAM_ADPCMTYPE */
+    OMX_IndexParamAudioG723,                /**< reference: OMX_AUDIO_PARAM_G723TYPE */
+    OMX_IndexParamAudioG729,                /**< reference: OMX_AUDIO_PARAM_G729TYPE */
+    OMX_IndexParamAudioAmr,                 /**< reference: OMX_AUDIO_PARAM_AMRTYPE */
+    OMX_IndexParamAudioWma,                 /**< reference: OMX_AUDIO_PARAM_WMATYPE */
+    OMX_IndexParamAudioSbc,                 /**< reference: OMX_AUDIO_PARAM_SBCTYPE */
+    OMX_IndexParamAudioMidi,                /**< reference: OMX_AUDIO_PARAM_MIDITYPE */
+    OMX_IndexParamAudioGsm_FR,              /**< reference: OMX_AUDIO_PARAM_GSMFRTYPE */
+    OMX_IndexParamAudioMidiLoadUserSound,   /**< reference: OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE */
+    OMX_IndexParamAudioG726,                /**< reference: OMX_AUDIO_PARAM_G726TYPE */
+    OMX_IndexParamAudioGsm_EFR,             /**< reference: OMX_AUDIO_PARAM_GSMEFRTYPE */
+    OMX_IndexParamAudioGsm_HR,              /**< reference: OMX_AUDIO_PARAM_GSMHRTYPE */
+    OMX_IndexParamAudioPdc_FR,              /**< reference: OMX_AUDIO_PARAM_PDCFRTYPE */
+    OMX_IndexParamAudioPdc_EFR,             /**< reference: OMX_AUDIO_PARAM_PDCEFRTYPE */
+    OMX_IndexParamAudioPdc_HR,              /**< reference: OMX_AUDIO_PARAM_PDCHRTYPE */
+    OMX_IndexParamAudioTdma_FR,             /**< reference: OMX_AUDIO_PARAM_TDMAFRTYPE */
+    OMX_IndexParamAudioTdma_EFR,            /**< reference: OMX_AUDIO_PARAM_TDMAEFRTYPE */
+    OMX_IndexParamAudioQcelp8,              /**< reference: OMX_AUDIO_PARAM_QCELP8TYPE */
+    OMX_IndexParamAudioQcelp13,             /**< reference: OMX_AUDIO_PARAM_QCELP13TYPE */
+    OMX_IndexParamAudioEvrc,                /**< reference: OMX_AUDIO_PARAM_EVRCTYPE */
+    OMX_IndexParamAudioSmv,                 /**< reference: OMX_AUDIO_PARAM_SMVTYPE */
+    OMX_IndexParamAudioVorbis,              /**< reference: OMX_AUDIO_PARAM_VORBISTYPE */
+
+    OMX_IndexConfigAudioMidiImmediateEvent, /**< reference: OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE */
+    OMX_IndexConfigAudioMidiControl,        /**< reference: OMX_AUDIO_CONFIG_MIDICONTROLTYPE */
+    OMX_IndexConfigAudioMidiSoundBankProgram, /**< reference: OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE */
+    OMX_IndexConfigAudioMidiStatus,         /**< reference: OMX_AUDIO_CONFIG_MIDISTATUSTYPE */
+    OMX_IndexConfigAudioMidiMetaEvent,      /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE */
+    OMX_IndexConfigAudioMidiMetaEventData,  /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE */
+    OMX_IndexConfigAudioVolume,             /**< reference: OMX_AUDIO_CONFIG_VOLUMETYPE */
+    OMX_IndexConfigAudioBalance,            /**< reference: OMX_AUDIO_CONFIG_BALANCETYPE */
+    OMX_IndexConfigAudioChannelMute,        /**< reference: OMX_AUDIO_CONFIG_CHANNELMUTETYPE */
+    OMX_IndexConfigAudioMute,               /**< reference: OMX_AUDIO_CONFIG_MUTETYPE */
+    OMX_IndexConfigAudioLoudness,           /**< reference: OMX_AUDIO_CONFIG_LOUDNESSTYPE */
+    OMX_IndexConfigAudioEchoCancelation,    /**< reference: OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE */
+    OMX_IndexConfigAudioNoiseReduction,     /**< reference: OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE */
+    OMX_IndexConfigAudioBass,               /**< reference: OMX_AUDIO_CONFIG_BASSTYPE */
+    OMX_IndexConfigAudioTreble,             /**< reference: OMX_AUDIO_CONFIG_TREBLETYPE */
+    OMX_IndexConfigAudioStereoWidening,     /**< reference: OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE */
+    OMX_IndexConfigAudioChorus,             /**< reference: OMX_AUDIO_CONFIG_CHORUSTYPE */
+    OMX_IndexConfigAudioEqualizer,          /**< reference: OMX_AUDIO_CONFIG_EQUALIZERTYPE */
+    OMX_IndexConfigAudioReverberation,      /**< reference: OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
+    OMX_IndexConfigAudioChannelVolume,      /**< reference: OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */
+
+    /* Image specific parameters and configurations */
+    OMX_IndexImageStartUnused = 0x05000000,
+    OMX_IndexParamImagePortFormat,          /**< reference: OMX_IMAGE_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamFlashControl,             /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+    OMX_IndexConfigFocusControl,            /**< reference: OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE */
+    OMX_IndexParamQFactor,                  /**< reference: OMX_IMAGE_PARAM_QFACTORTYPE */
+    OMX_IndexParamQuantizationTable,        /**< reference: OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
+    OMX_IndexParamHuffmanTable,             /**< reference: OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
+    OMX_IndexConfigFlashControl,            /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+
+    /* Video specific parameters and configurations */
+    OMX_IndexVideoStartUnused = 0x06000000,
+    OMX_IndexParamVideoPortFormat,          /**< reference: OMX_VIDEO_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamVideoQuantization,        /**< reference: OMX_VIDEO_PARAM_QUANTIZATIONTYPE */
+    OMX_IndexParamVideoFastUpdate,          /**< reference: OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE */
+    OMX_IndexParamVideoBitrate,             /**< reference: OMX_VIDEO_PARAM_BITRATETYPE */
+    OMX_IndexParamVideoMotionVector,        /**< reference: OMX_VIDEO_PARAM_MOTIONVECTORTYPE */
+    OMX_IndexParamVideoIntraRefresh,        /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
+    OMX_IndexParamVideoErrorCorrection,     /**< reference: OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE */
+    OMX_IndexParamVideoVBSMC,               /**< reference: OMX_VIDEO_PARAM_VBSMCTYPE */
+    OMX_IndexParamVideoMpeg2,               /**< reference: OMX_VIDEO_PARAM_MPEG2TYPE */
+    OMX_IndexParamVideoMpeg4,               /**< reference: OMX_VIDEO_PARAM_MPEG4TYPE */
+    OMX_IndexParamVideoWmv,                 /**< reference: OMX_VIDEO_PARAM_WMVTYPE */
+    OMX_IndexParamVideoRv,                  /**< reference: OMX_VIDEO_PARAM_RVTYPE */
+    OMX_IndexParamVideoAvc,                 /**< reference: OMX_VIDEO_PARAM_AVCTYPE */
+    OMX_IndexParamVideoH263,                /**< reference: OMX_VIDEO_PARAM_H263TYPE */
+    OMX_IndexParamVideoProfileLevelQuerySupported, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    OMX_IndexParamVideoProfileLevelCurrent, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    OMX_IndexConfigVideoBitrate,            /**< reference: OMX_VIDEO_CONFIG_BITRATETYPE */
+    OMX_IndexConfigVideoFramerate,          /**< reference: OMX_CONFIG_FRAMERATETYPE */
+    OMX_IndexConfigVideoIntraVOPRefresh,    /**< reference: OMX_CONFIG_INTRAREFRESHVOPTYPE */
+    OMX_IndexConfigVideoIntraMBRefresh,     /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    OMX_IndexConfigVideoMBErrorReporting,   /**< reference: OMX_CONFIG_MBERRORREPORTINGTYPE */
+    OMX_IndexParamVideoMacroblocksPerFrame, /**< reference: OMX_PARAM_MACROBLOCKSTYPE */
+    OMX_IndexConfigVideoMacroBlockErrorMap, /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
+    OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
+    OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */
+
+    /* Image & Video common Configurations */
+    OMX_IndexCommonStartUnused = 0x07000000,
+    OMX_IndexParamCommonDeblocking,         /**< reference: OMX_PARAM_DEBLOCKINGTYPE */
+    OMX_IndexParamCommonSensorMode,         /**< reference: OMX_PARAM_SENSORMODETYPE */
+    OMX_IndexParamCommonInterleave,         /**< reference: OMX_PARAM_INTERLEAVETYPE */
+    OMX_IndexConfigCommonColorFormatConversion, /**< reference: OMX_CONFIG_COLORCONVERSIONTYPE */
+    OMX_IndexConfigCommonScale,             /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
+    OMX_IndexConfigCommonImageFilter,       /**< reference: OMX_CONFIG_IMAGEFILTERTYPE */
+    OMX_IndexConfigCommonColorEnhancement,  /**< reference: OMX_CONFIG_COLORENHANCEMENTTYPE */
+    OMX_IndexConfigCommonColorKey,          /**< reference: OMX_CONFIG_COLORKEYTYPE */
+    OMX_IndexConfigCommonColorBlend,        /**< reference: OMX_CONFIG_COLORBLENDTYPE */
+    OMX_IndexConfigCommonFrameStabilisation,/**< reference: OMX_CONFIG_FRAMESTABTYPE */
+    OMX_IndexConfigCommonRotate,            /**< reference: OMX_CONFIG_ROTATIONTYPE */
+    OMX_IndexConfigCommonMirror,            /**< reference: OMX_CONFIG_MIRRORTYPE */
+    OMX_IndexConfigCommonOutputPosition,    /**< reference: OMX_CONFIG_POINTTYPE */
+    OMX_IndexConfigCommonInputCrop,         /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonOutputCrop,        /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonDigitalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
+    OMX_IndexConfigCommonOpticalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE*/
+    OMX_IndexConfigCommonWhiteBalance,      /**< reference: OMX_CONFIG_WHITEBALCONTROLTYPE */
+    OMX_IndexConfigCommonExposure,          /**< reference: OMX_CONFIG_EXPOSURECONTROLTYPE */
+    OMX_IndexConfigCommonContrast,          /**< reference: OMX_CONFIG_CONTRASTTYPE */
+    OMX_IndexConfigCommonBrightness,        /**< reference: OMX_CONFIG_BRIGHTNESSTYPE */
+    OMX_IndexConfigCommonBacklight,         /**< reference: OMX_CONFIG_BACKLIGHTTYPE */
+    OMX_IndexConfigCommonGamma,             /**< reference: OMX_CONFIG_GAMMATYPE */
+    OMX_IndexConfigCommonSaturation,        /**< reference: OMX_CONFIG_SATURATIONTYPE */
+    OMX_IndexConfigCommonLightness,         /**< reference: OMX_CONFIG_LIGHTNESSTYPE */
+    OMX_IndexConfigCommonExclusionRect,     /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonDithering,         /**< reference: OMX_CONFIG_DITHERTYPE */
+    OMX_IndexConfigCommonPlaneBlend,        /**< reference: OMX_CONFIG_PLANEBLENDTYPE */
+    OMX_IndexConfigCommonExposureValue,     /**< reference: OMX_CONFIG_EXPOSUREVALUETYPE */
+    OMX_IndexConfigCommonOutputSize,        /**< reference: OMX_FRAMESIZETYPE */
+    OMX_IndexParamCommonExtraQuantData,     /**< reference: OMX_OTHER_EXTRADATATYPE */
+    OMX_IndexConfigCommonFocusRegion,       /**< reference: OMX_CONFIG_FOCUSREGIONTYPE */
+    OMX_IndexConfigCommonFocusStatus,       /**< reference: OMX_PARAM_FOCUSSTATUSTYPE */
+    OMX_IndexConfigCommonTransitionEffect,  /**< reference: OMX_CONFIG_TRANSITIONEFFECTTYPE */
+
+    /* Reserved Configuration range */
+    OMX_IndexOtherStartUnused = 0x08000000,
+    OMX_IndexParamOtherPortFormat,          /**< reference: OMX_OTHER_PARAM_PORTFORMATTYPE */
+    OMX_IndexConfigOtherPower,              /**< reference: OMX_OTHER_CONFIG_POWERTYPE */
+    OMX_IndexConfigOtherStats,              /**< reference: OMX_OTHER_CONFIG_STATSTYPE */
+
+
+    /* Reserved Time range */
+    OMX_IndexTimeStartUnused = 0x09000000,
+    OMX_IndexConfigTimeScale,               /**< reference: OMX_TIME_CONFIG_SCALETYPE */
+    OMX_IndexConfigTimeClockState,          /**< reference: OMX_TIME_CONFIG_CLOCKSTATETYPE */
+    OMX_IndexConfigTimeActiveRefClock,      /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
+    OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    OMX_IndexConfigTimeCurrentWallTime,     /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    OMX_IndexConfigTimeCurrentAudioReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimeCurrentVideoReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
+    OMX_IndexConfigTimeClientStartTime,     /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimePosition,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
+    OMX_IndexConfigTimeSeekMode,            /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */
+
+
+    OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    /* Vendor specific area */
+    OMX_IndexVendorStartUnused = 0x7F000000,
+    OMX_IndexIntelPrivateInfo,
+    /* Vendor specific structures should be in the range of 0x7F000000
+       to 0x7FFFFFFE.  This range is not broken out by vendor, so
+       private indexes are not guaranteed unique and therefore should
+       only be sent to the appropriate component. */
+
+    OMX_IndexMax = 0x7FFFFFFF
+
+} OMX_INDEXTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/core/inc/khronos/openmax/include/OMX_IndexExt.h b/core/inc/khronos/openmax/include/OMX_IndexExt.h
new file mode 100644
index 0000000..b9ad3fa
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_IndexExt.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2010 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** @file OMX_IndexExt.h - OpenMax IL version 1.1.2
+ * The OMX_IndexExt header file contains extensions to the definitions
+ * for both applications and components .
+ */
+
+#ifndef OMX_IndexExt_h
+#define OMX_IndexExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Index.h>
+
+
+/** Khronos standard extension indices.
+
+This enum lists the current Khronos extension indices to OpenMAX IL.
+*/
+typedef enum OMX_INDEXEXTTYPE {
+
+    /* Component parameters and configurations */
+    OMX_IndexExtComponentStartUnused = OMX_IndexKhronosExtensions + 0x00100000,
+    OMX_IndexConfigCallbackRequest,                 /**< reference: OMX_CONFIG_CALLBACKREQUESTTYPE */
+    OMX_IndexConfigCommitMode,                      /**< reference: OMX_CONFIG_COMMITMODETYPE */
+    OMX_IndexConfigCommit,                          /**< reference: OMX_CONFIG_COMMITTYPE */
+
+    /* Port parameters and configurations */
+    OMX_IndexExtPortStartUnused = OMX_IndexKhronosExtensions + 0x00200000,
+
+    /* Audio parameters and configurations */
+    OMX_IndexExtAudioStartUnused = OMX_IndexKhronosExtensions + 0x00400000,
+
+    /* Image parameters and configurations */
+    OMX_IndexExtImageStartUnused = OMX_IndexKhronosExtensions + 0x00500000,
+
+    /* Video parameters and configurations */
+    OMX_IndexExtVideoStartUnused = OMX_IndexKhronosExtensions + 0x00600000,
+    OMX_IndexParamNalStreamFormatSupported,         /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamNalStreamFormat,                  /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamNalStreamFormatSelect,            /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamVideoBytestream,                  /**< reference: OMX_VIDEO_PARAM_BYTESTREAMTYPE */
+    OMX_IndexParamIntelBitrate,                     /**< reference: OMX_VIDEO_PARAM_INTEL_BITRATETYPE */
+    OMX_IndexConfigIntelBitrate,                    /**< reference: OMX_VIDEO_CONFIG_INTEL_BITRATETYPE */
+    OMX_IndexParamIntelAVCDecodeSettings,           /**< reference: OMX_VIDEO_PARAM_INTEL_AVC_DECODE_SETTINGS */
+    OMX_IndexConfigIntelSliceNumbers,               /**< reference: OMX_VIDEO_CONFIG_INTEL_SLICE_NUMBERS */
+    OMX_IndexConfigIntelAIR,                         /**< reference: OMX_VIDEO_CONFIG_INTEL_AIR */
+    OMX_IndexParamGoogleNativeBuffers,               /**< reference: EnableAndroidNativeBuffersParams in Android */
+    OMX_IndexParamGoogleNativeBufferUsage,           /**< reference: GetAndroidNativeBufferUsageParams */
+    OMX_IndexParamGoogleMetaDataInBuffers,
+    OMX_IndexParamGoogleThumbNail,
+    OMX_IndexParamIntelXDisplay,                      /**< reference: OMX_VIDEO_PARAM_X_DISPLAY */
+    OMX_IndexParamIntelGlxPictures,                      /**< reference: OMX_VIDEO_PARAM_GLX_PICTURES */
+    /* Image & Video common configurations */
+    OMX_IndexExtCommonStartUnused = OMX_IndexKhronosExtensions + 0x00700000,
+
+    /* Other configurations */
+    OMX_IndexExtOtherStartUnused = OMX_IndexKhronosExtensions + 0x00800000,
+
+    /* Time configurations */
+    OMX_IndexExtTimeStartUnused = OMX_IndexKhronosExtensions + 0x00900000,
+
+    OMX_IndexExtMax = 0x7FFFFFFF
+} OMX_INDEXEXTTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_IndexExt_h */
+/* File EOF */
diff --git a/core/inc/khronos/openmax/include/OMX_IntelErrorTypes.h b/core/inc/khronos/openmax/include/OMX_IntelErrorTypes.h
new file mode 100644
index 0000000..a2af96a
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_IntelErrorTypes.h
@@ -0,0 +1,24 @@
+#ifndef OMX_IntelErrorTypes_h
+#define OMX_IntelErrorTypes_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#include <OMX_Core.h>
+
+typedef enum OMX_INTELERRORTYPE
+{
+      OMX_ErrorIntelExtSliceSizeOverflow = OMX_ErrorVendorStartUnused + (OMX_S32)0x00001001,
+      OMX_ErrorIntelVideoNotPermitted    = OMX_ErrorVendorStartUnused + (OMX_S32)0x00001002,
+      OMX_ErrorIntelProcessStream        = OMX_ErrorVendorStartUnused + (OMX_S32)0x00001003,
+      OMX_ErrorIntelMissingConfig        = OMX_ErrorVendorStartUnused + (OMX_S32)0x00001004,
+
+} OMX_INTELERRORTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/core/inc/khronos/openmax/include/OMX_Other.h b/core/inc/khronos/openmax/include/OMX_Other.h
new file mode 100644
index 0000000..a3abbec
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_Other.h
@@ -0,0 +1,337 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** @file OMX_Other.h - OpenMax IL version 1.1.2
+ *  The structures needed by Other components to exchange
+ *  parameters and configuration data with the components.
+ */
+
+#ifndef OMX_Other_h
+#define OMX_Other_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+
+#include <OMX_Core.h>
+
+
+/**
+ * Enumeration of possible data types which match to multiple domains or no
+ * domain at all.  For types which are vendor specific, a value above
+ * OMX_OTHER_VENDORTSTART should be used.
+ */
+typedef enum OMX_OTHER_FORMATTYPE {
+    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time,
+                                   time deltas, etc */
+    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power
+                                   management, setting clocks? */
+    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames
+                                   dropped, etc */
+    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
+    OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific
+                                                formats */
+
+    OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_OTHER_FormatMax = 0x7FFFFFFF
+} OMX_OTHER_FORMATTYPE;
+
+/**
+ * Enumeration of seek modes.
+ */
+typedef enum OMX_TIME_SEEKMODETYPE {
+    OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
+                                * of the requested seek position over
+                                * the actual seek position if it
+                                * results in a faster seek. */
+    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek
+                                * position over an approximation
+                                * of the requested seek position even
+                                * if it results in a slower seek. */
+    OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_TIME_SeekModeMax = 0x7FFFFFFF
+} OMX_TIME_SEEKMODETYPE;
+
+/* Structure representing the seekmode of the component */
+typedef struct OMX_TIME_CONFIG_SEEKMODETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
+} OMX_TIME_CONFIG_SEEKMODETYPE;
+
+/** Structure representing a time stamp used with the following configs
+ * on the Clock Component (CC):
+ *
+ * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall
+ *     time
+ * OMX_IndexConfigTimeCurrentMediaTime: query of the CCs current media
+ *     time
+ * OMX_IndexConfigTimeCurrentAudioReference and
+ * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference
+ *     clock sending SC its reference time
+ * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends
+ *     this structure to the Clock Component via a SetConfig on its
+ *     client port when it receives a buffer with
+ *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
+ *     specified by that buffer for nStartTimestamp.
+ *
+ * Its also used with the following config on components in general:
+ *
+ * OMX_IndexConfigTimePosition: IL client querying component position
+ * (GetConfig) or commanding a component to seek to the given location
+ * (SetConfig)
+ */
+typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
+    OMX_U32 nSize;               /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;    /**< OMX specification version
+                                  *   information */
+    OMX_U32 nPortIndex;     /**< port that this structure applies to */
+    OMX_TICKS nTimestamp;  	     /**< timestamp .*/
+} OMX_TIME_CONFIG_TIMESTAMPTYPE;
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum OMX_TIME_UPDATETYPE {
+      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
+      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
+      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
+      OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+      OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_UpdateMax = 0x7FFFFFFF
+} OMX_TIME_UPDATETYPE;
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum OMX_TIME_REFCLOCKTYPE {
+      OMX_TIME_RefClockNone,    /**< Use no references. */
+      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
+      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
+      OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+      OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_RefClockMax = 0x7FFFFFFF
+} OMX_TIME_REFCLOCKTYPE;
+
+/** Enumeration of clock states. */
+typedef enum OMX_TIME_CLOCKSTATE {
+      OMX_TIME_ClockStateRunning,             /**< Clock running. */
+      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the
+                                               *   prescribed clients emit their
+                                               *   start time. */
+      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
+      OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+      OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_ClockStateMax = 0x7FFFFFFF
+} OMX_TIME_CLOCKSTATE;
+
+/** Structure representing a media time request to the clock component.
+ *
+ *  A client component sends this structure to the Clock Component via a SetConfig
+ *  on its client port to specify a media timestamp the Clock Component
+ *  should emit.  The Clock Component should fulfill the request by sending a
+ *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested
+ *  timestamp.
+ *
+ *  The client may require a media time request be fulfilled slightly
+ *  earlier than the media time specified. In this case the client specifies
+ *  an offset which is equal to the difference between wall time corresponding
+ *  to the requested media time and the wall time when it will be
+ *  fulfilled.
+ *
+ *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
+ *  time events according to timestamps. If a client must perform an operation O at
+ *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a
+ *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
+ *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
+ *  structure back to the client component, the client may perform operation O (perhaps having
+ *  to wait a slight amount more time itself as specified by the return values).
+ */
+
+typedef struct OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time
+                                 *   from others (e.g. the number of the frame to deliver).
+                                 *   Duplicated in the media time structure that fulfills
+                                 *   this request. A value of zero is reserved for time scale
+                                 *   updates. */
+    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/
+    OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
+                                 *   request should be fulfilled early */
+} OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;
+
+/**< Structure sent from the clock component client either when fulfilling
+ *   a media time request or when the time scale has changed.
+ *
+ *   In the former case the Clock Component fills this structure and times its emission
+ *   to a client component (via the client port) according to the corresponding media
+ *   time request sent by the client. The Clock Component should time the emission to occur
+ *   when the requested timestamp matches the Clock Component's media time but also the
+ *   prescribed offset early.
+ *
+ *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
+ *   media time and sets the nScale to the new scale via the client port. It emits a
+ *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to
+ *   alter processing to accomodate scaling. For instance a video component might skip inter-frames
+ *   in the case of extreme fastforward. Likewise an audio component might add or remove samples
+ *   from an audio frame to scale audio data.
+ *
+ *   It is expected that some clock components may not be able to fulfill requests
+ *   at exactly the prescribed time. This is acceptable so long as the request is
+ *   fulfilled at least as early as described and not later. This structure provides
+ *   fields the client may use to wait for the remaining time.
+ *
+ *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the
+ *   wall time until the nMediaTimestamp actually occurs. In the latter case the
+ *   client can get a more accurate value for offset by getting the current wall
+ *   from the cloc component and subtracting it from nWallTimeAtMedia.
+ */
+
+typedef struct OMX_TIME_MEDIATIMETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time
+                                     *   from others. Copied from the media time request.
+                                     *   A value of zero is reserved for time scale updates. */
+    OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
+    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was
+                                     *   requested then this is the current media time. */
+    OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
+                                     *   request was actually fulfilled early */
+
+    OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
+                                     *   A client may compare this value to current
+                                     *   media time obtained from the Clock Component to determine
+                                     *   the wall time until the media timestamp is really
+                                     *   current. */
+    OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
+    OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
+                                    /**< State of the media time. */
+} OMX_TIME_MEDIATIMETYPE;
+
+/** Structure representing the current media time scale factor. Applicable only to clock
+ *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
+ *  the clock component client ports. Upon recieving this config the clock component changes
+ *  the rate by which the media time increases or decreases effectively implementing trick modes.
+ */
+typedef struct OMX_TIME_CONFIG_SCALETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
+                                     * scaling the media time */
+} OMX_TIME_CONFIG_SCALETYPE;
+
+/** Bits used to identify a clock port. Used in OMX_TIME_CONFIG_CLOCKSTATETYPEs nWaitMask field */
+#define OMX_CLOCKPORT0 0x00000001
+#define OMX_CLOCKPORT1 0x00000002
+#define OMX_CLOCKPORT2 0x00000004
+#define OMX_CLOCKPORT3 0x00000008
+#define OMX_CLOCKPORT4 0x00000010
+#define OMX_CLOCKPORT5 0x00000020
+#define OMX_CLOCKPORT6 0x00000040
+#define OMX_CLOCKPORT7 0x00000080
+
+/** Structure representing the current mode of the media clock.
+ *  IL Client uses this config to change or query the mode of the
+ *  media clock of the clock component. Applicable only to clock
+ *  component.
+ *
+ *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
+ *  starts immediately at the prescribed start time. If
+ *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
+ *  the given nStartTime and waits for all clients specified in the
+ *  nWaitMask to send starttimes (via
+ *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts
+ *  the media clock using the earliest start time supplied. */
+typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version
+                                 *   information */
+    OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
+    OMX_TICKS nStartTime;       /**< Start time of the media time. */
+    OMX_TICKS nOffset;          /**< Time to offset the media time by
+                                 * (e.g. preroll). Media time will be
+                                 * reported to be nOffset ticks earlier.
+                                 */
+    OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
+} OMX_TIME_CONFIG_CLOCKSTATETYPE;
+
+/** Structure representing the reference clock currently being used to
+ *  compute media time. IL client uses this config to change or query the
+ *  clock component's active reference clock */
+typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */
+} OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;
+
+/** Descriptor for setting specifics of power type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct OMX_OTHER_CONFIG_POWERTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
+} OMX_OTHER_CONFIG_POWERTYPE;
+
+
+/** Descriptor for setting specifics of stats type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct OMX_OTHER_CONFIG_STATSTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    /* what goes here */
+} OMX_OTHER_CONFIG_STATSTYPE;
+
+
+/**
+ * The PortDefinition structure is used to define all of the parameters
+ * necessary for the compliant component to setup an input or an output other
+ * path.
+ */
+typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
+    OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
+} OMX_OTHER_PORTDEFINITIONTYPE;
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct OMX_OTHER_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize; /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex; /**< Indicates which port to set */
+    OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
+} OMX_OTHER_PARAM_PORTFORMATTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/core/inc/khronos/openmax/include/OMX_Types.h b/core/inc/khronos/openmax/include/OMX_Types.h
new file mode 100644
index 0000000..264532d
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_Types.h
@@ -0,0 +1,347 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_Types.h - OpenMax IL version 1.1.2
+ *  The OMX_Types header file contains the primitive type definitions used by
+ *  the core, the application and the component.  This file may need to be
+ *  modified to be used on systems that do not have "char" set to 8 bits,
+ *  "short" set to 16 bits and "long" set to 32 bits.
+ */
+
+#ifndef OMX_Types_h
+#define OMX_Types_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/** The OMX_API and OMX_APIENTRY are platform specific definitions used
+ *  to declare OMX function prototypes.  They are modified to meet the
+ *  requirements for a particular platform */
+#ifdef __SYMBIAN32__
+#   ifdef __OMX_EXPORTS
+#       define OMX_API __declspec(dllexport)
+#   else
+#       ifdef _WIN32
+#           define OMX_API __declspec(dllexport)
+#       else
+#           define OMX_API __declspec(dllimport)
+#       endif
+#   endif
+#else
+#   ifdef _WIN32
+#      ifdef __OMX_EXPORTS
+#          define OMX_API __declspec(dllexport)
+#      else
+#          define OMX_API __declspec(dllimport)
+#      endif
+#   else
+#      ifdef __OMX_EXPORTS
+#          define OMX_API
+#      else
+#          define OMX_API extern
+#      endif
+#   endif
+#endif
+
+#ifndef OMX_APIENTRY
+#define OMX_APIENTRY
+#endif
+
+/** OMX_IN is used to identify inputs to an OMX function.  This designation
+    will also be used in the case of a pointer that points to a parameter
+    that is used as an output. */
+#ifndef OMX_IN
+#define OMX_IN
+#endif
+
+/** OMX_OUT is used to identify outputs from an OMX function.  This
+    designation will also be used in the case of a pointer that points
+    to a parameter that is used as an input. */
+#ifndef OMX_OUT
+#define OMX_OUT
+#endif
+
+
+/** OMX_INOUT is used to identify parameters that may be either inputs or
+    outputs from an OMX function at the same time.  This designation will
+    also be used in the case of a pointer that  points to a parameter that
+    is used both as an input and an output. */
+#ifndef OMX_INOUT
+#define OMX_INOUT
+#endif
+
+/** OMX_ALL is used to as a wildcard to select all entities of the same type
+ *  when specifying the index, or referring to a object by an index.  (i.e.
+ *  use OMX_ALL to indicate all N channels). When used as a port index
+ *  for a config or parameter this OMX_ALL denotes that the config or
+ *  parameter applies to the entire component not just one port. */
+#define OMX_ALL 0xFFFFFFFF
+
+/** In the following we define groups that help building doxygen documentation */
+
+/** @defgroup core OpenMAX IL core
+ * Functions and structure related to the OMX IL core
+ */
+
+ /** @defgroup comp OpenMAX IL component
+ * Functions and structure related to the OMX IL component
+ */
+
+/** @defgroup rpm Resource and Policy Management
+ * Structures for resource and policy management of components
+ */
+
+/** @defgroup buf Buffer Management
+ * Buffer handling functions and structures
+ */
+
+/** @defgroup tun Tunneling
+ * @ingroup core comp
+ * Structures and functions to manage tunnels among component ports
+ */
+
+/** @defgroup cp Content Pipes
+ *  @ingroup core
+ */
+
+ /** @defgroup metadata Metadata handling
+  *
+  */
+
+/** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
+typedef unsigned char OMX_U8;
+
+/** OMX_S8 is an 8 bit signed quantity that is byte aligned */
+typedef signed char OMX_S8;
+
+/** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
+typedef unsigned short OMX_U16;
+
+/** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
+typedef signed short OMX_S16;
+
+/** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
+typedef unsigned long OMX_U32;
+
+/** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
+typedef signed long OMX_S32;
+
+
+/* Users with compilers that cannot accept the "long long" designation should
+   define the OMX_SKIP64BIT macro.  It should be noted that this may cause
+   some components to fail to compile if the component was written to require
+   64 bit integral types.  However, these components would NOT compile anyway
+   since the compiler does not support the way the component was written.
+*/
+#ifndef OMX_SKIP64BIT
+#ifdef __SYMBIAN32__
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long OMX_S64;
+
+#elif defined(WIN32)
+
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned __int64  OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed   __int64  OMX_S64;
+
+#else /* WIN32 */
+
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long OMX_S64;
+
+#endif /* WIN32 */
+#endif
+
+
+/** The OMX_BOOL type is intended to be used to represent a true or a false
+    value when passing parameters to and from the OMX core and components.  The
+    OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
+ */
+typedef enum OMX_BOOL {
+    OMX_FALSE = 0,
+    OMX_TRUE = !OMX_FALSE,
+    OMX_BOOL_MAX = 0x7FFFFFFF
+} OMX_BOOL;
+
+/** The OMX_PTR type is intended to be used to pass pointers between the OMX
+    applications and the OMX Core and components.  This is a 32 bit pointer and
+    is aligned on a 32 bit boundary.
+ */
+typedef void* OMX_PTR;
+
+/** The OMX_STRING type is intended to be used to pass "C" type strings between
+    the application and the core and component.  The OMX_STRING type is a 32
+    bit pointer to a zero terminated string.  The  pointer is word aligned and
+    the string is byte aligned.
+ */
+typedef char* OMX_STRING;
+
+/** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
+    buffers between the application and the component and core.  The OMX_BYTE
+    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
+    aligned and the string is byte aligned.
+ */
+typedef unsigned char* OMX_BYTE;
+
+/** OMX_UUIDTYPE is a very long unique identifier to uniquely identify
+    at runtime.  This identifier should be generated by a component in a way
+    that guarantees that every instance of the identifier running on the system
+    is unique. */
+typedef unsigned char OMX_UUIDTYPE[128];
+
+/** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
+    an output port.  This enumeration is common across all component types.
+ */
+typedef enum OMX_DIRTYPE
+{
+    OMX_DirInput,              /**< Port is an input port */
+    OMX_DirOutput,             /**< Port is an output port */
+    OMX_DirMax = 0x7FFFFFFF
+} OMX_DIRTYPE;
+
+/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering
+    for numerical data (i.e. big endian, or little endian).
+ */
+typedef enum OMX_ENDIANTYPE
+{
+    OMX_EndianBig, /**< big endian */
+    OMX_EndianLittle, /**< little endian */
+    OMX_EndianMax = 0x7FFFFFFF
+} OMX_ENDIANTYPE;
+
+
+/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data
+    is signed or unsigned
+ */
+typedef enum OMX_NUMERICALDATATYPE
+{
+    OMX_NumericalDataSigned, /**< signed data */
+    OMX_NumericalDataUnsigned, /**< unsigned data */
+    OMX_NumercialDataMax = 0x7FFFFFFF
+} OMX_NUMERICALDATATYPE;
+
+
+/** Unsigned bounded value type */
+typedef struct OMX_BU32 {
+    OMX_U32 nValue; /**< actual value */
+    OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} OMX_BU32;
+
+
+/** Signed bounded value type */
+typedef struct OMX_BS32 {
+    OMX_S32 nValue; /**< actual value */
+    OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} OMX_BS32;
+
+
+/** Structure representing some time or duration in microseconds. This structure
+  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate
+  *  negative deltas and preroll scenarios. The quantity is represented in microseconds
+  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
+  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g.
+  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to
+  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
+  *  or minus 35 minutes).
+  *
+  *  Implementations with limited precision may convert the signed 64 bit value to
+  *  a signed 32 bit value internally but risk loss of precision.
+  */
+#ifndef OMX_SKIP64BIT
+typedef OMX_S64 OMX_TICKS;
+#else
+typedef struct OMX_TICKS
+{
+    OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
+    OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
+} OMX_TICKS;
+#endif
+#define OMX_TICKS_PER_SECOND 1000000
+
+/** Define the public interface for the OMX Handle.  The core will not use
+    this value internally, but the application should only use this value.
+ */
+typedef void* OMX_HANDLETYPE;
+
+typedef struct OMX_MARKTYPE
+{
+    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will
+                                                generate a mark event upon
+                                                processing the mark. */
+    OMX_PTR pMarkData;   /**< Application specific data associated with
+                              the mark sent on a mark event to disambiguate
+                              this mark from others. */
+} OMX_MARKTYPE;
+
+
+/** OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the display
+ *  or can be used by a audio port for native audio rendering */
+typedef void* OMX_NATIVE_DEVICETYPE;
+
+/** OMX_NATIVE_WINDOWTYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the window */
+typedef void* OMX_NATIVE_WINDOWTYPE;
+
+/** The OMX_VERSIONTYPE union is used to specify the version for
+    a structure or component.  For a component, the version is entirely
+    specified by the component vendor.  Components doing the same function
+    from different vendors may or may not have the same version.  For
+    structures, the version shall be set by the entity that allocates the
+    structure.  For structures specified in the OMX 1.1 specification, the
+    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
+    OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
+    by accessing one of the structure elements to, for example, check only
+    the Major revision.
+ */
+typedef union OMX_VERSIONTYPE
+{
+    struct
+    {
+        OMX_U8 nVersionMajor;   /**< Major version accessor element */
+        OMX_U8 nVersionMinor;   /**< Minor version accessor element */
+        OMX_U8 nRevision;       /**< Revision version accessor element */
+        OMX_U8 nStep;           /**< Step version accessor element */
+    } s;
+    OMX_U32 nVersion;           /**< 32 bit value to make accessing the
+                                    version easily done in a single word
+                                    size copy/compare operation */
+} OMX_VERSIONTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/core/inc/khronos/openmax/include/OMX_Video.h b/core/inc/khronos/openmax/include/OMX_Video.h
new file mode 100644
index 0000000..caf6048
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_Video.h
@@ -0,0 +1,1079 @@
+/**
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/**
+ *  @file OMX_Video.h - OpenMax IL version 1.1.2
+ *  The structures is needed by Video components to exchange parameters
+ *  and configuration data with OMX components.
+ */
+#ifndef OMX_Video_h
+#define OMX_Video_h
+
+/** @defgroup video OpenMAX IL Video Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Video domain
+ * @{
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+
+#include <OMX_IVCommon.h>
+
+
+/**
+ * Enumeration used to define the possible video compression codings.
+ * NOTE:  This essentially refers to file extensions. If the coding is
+ *        being used to specify the ENCODE type, then additional work
+ *        must be done to configure the exact flavor of the compression
+ *        to be used.  For decode cases where the user application can
+ *        not differentiate between MPEG-4 and H.264 bit streams, it is
+ *        up to the codec to handle this.
+ */
+typedef enum OMX_VIDEO_CODINGTYPE {
+    OMX_VIDEO_CodingUnused,     /**< Value when coding is N/A */
+    OMX_VIDEO_CodingAutoDetect, /**< Autodetection of coding type */
+    OMX_VIDEO_CodingMPEG2,      /**< AKA: H.262 */
+    OMX_VIDEO_CodingH263,       /**< H.263 */
+    OMX_VIDEO_CodingMPEG4,      /**< MPEG-4 */
+    OMX_VIDEO_CodingWMV,        /**< all versions of Windows Media Video */
+    OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
+    OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
+    OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
+    OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_CodingMax = 0x7FFFFFFF
+} OMX_VIDEO_CODINGTYPE;
+
+
+/**
+ * Data structure used to define a video path.  The number of Video paths for
+ * input and output will vary by type of the Video component.
+ *
+ *    Input (aka Source) : zero Inputs, one Output,
+ *    Splitter           : one Input, 2 or more Outputs,
+ *    Processing Element : one Input, one output,
+ *    Mixer              : 2 or more inputs, one output,
+ *    Output (aka Sink)  : one Input, zero outputs.
+ *
+ * The PortDefinition structure is used to define all of the parameters
+ * necessary for the compliant component to setup an input or an output video
+ * path.  If additional vendor specific data is required, it should be
+ * transmitted to the component using the CustomCommand function.  Compliant
+ * components will prepopulate this structure with optimal values during the
+ * GetDefaultInitParams command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on channel if
+ *                          uncompressed format is used.  Use 0 for unknown,
+ *                          don't care or variable
+ *  nFrameHeight          : Height of frame to be used on channel if
+ *                          uncompressed format is used. Use 0 for unknown,
+ *                          don't care or variable
+ *  nStride               : Number of bytes per span of an image
+ *                          (i.e. indicates the number of bytes to get
+ *                          from span N to span N+1, where negative stride
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  nBitrate              : Bit rate of frame to be used on channel if
+ *                          compressed format is used. Use 0 for unknown,
+ *                          don't care or variable
+ *  xFramerate            : Frame rate to be used on channel if uncompressed
+ *                          format is used. Use 0 for unknown, don't care or
+ *                          variable.  Units are Q16 frames per second.
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of the
+ *                          component. When OMX_VIDEO_CodingUnused is
+ *                          specified, eColorFormat is used
+ *  eColorFormat : Decompressed format used by this component
+ *  pNativeWindow : Platform specific reference for a window object if a
+ *                          display sink , otherwise this field is 0x0.
+ */
+typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;
+    OMX_NATIVE_DEVICETYPE pNativeRender;
+    OMX_U32 nFrameWidth;
+    OMX_U32 nFrameHeight;
+    OMX_S32 nStride;
+    OMX_U32 nSliceHeight;
+    OMX_U32 nBitrate;
+    OMX_U32 xFramerate;
+    OMX_BOOL bFlagErrorConcealment;
+    OMX_VIDEO_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} OMX_VIDEO_PORTDEFINITIONTYPE;
+
+/**
+ * Port format parameter.  This structure is used to enumerate the various
+ * data input/output format supported by the port.
+ *
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the
+ *                       component. When OMX_VIDEO_CodingUnused is specified,
+ *                       eColorFormat is used
+ *  eColorFormat       : Decompressed format used by this component
+ *  xFrameRate         : Indicates the video frame rate in Q16 format
+ */
+typedef struct OMX_VIDEO_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_VIDEO_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_U32 xFramerate;
+} OMX_VIDEO_PARAM_PORTFORMATTYPE;
+
+
+/**
+ * This is a structure for configuring video compression quantization
+ * parameter values.  Codecs may support different QP values for different
+ * frame types.
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info
+ *  nPortIndex : Port that this structure applies to
+ *  nQpI       : QP value to use for index frames
+ *  nQpP       : QP value to use for P frames
+ *  nQpB       : QP values to use for bidirectional frames
+ */
+typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nQpI;
+    OMX_U32 nQpP;
+    OMX_U32 nQpB;
+} OMX_VIDEO_PARAM_QUANTIZATIONTYPE;
+
+
+/**
+ * Structure for configuration of video fast update parameters.
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info
+ *  nPortIndex : Port that this structure applies to
+ *  bEnableVFU : Enable/Disable video fast update
+ *  nFirstGOB  : Specifies the number of the first macroblock row
+ *  nFirstMB   : specifies the first MB relative to the specified first GOB
+ *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB
+ *               and nFirstMB
+ */
+typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnableVFU;
+    OMX_U32 nFirstGOB;
+    OMX_U32 nFirstMB;
+    OMX_U32 nNumMBs;
+} OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;
+
+
+/**
+ * Enumeration of possible bitrate control types
+ */
+typedef enum OMX_VIDEO_CONTROLRATETYPE {
+    OMX_Video_ControlRateDisable,
+    OMX_Video_ControlRateVariable,
+    OMX_Video_ControlRateConstant,
+    OMX_Video_ControlRateVariableSkipFrames,
+    OMX_Video_ControlRateConstantSkipFrames,
+    OMX_Video_ControlRateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_Video_ControlRateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_Video_ControlRateMax = 0x7FFFFFFF
+} OMX_VIDEO_CONTROLRATETYPE;
+
+
+/**
+ * Structure for configuring bitrate mode of a codec.
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  eControlRate   : Control rate type enum
+ *  nTargetBitrate : Target bitrate to encode with
+ */
+typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_CONTROLRATETYPE eControlRate;
+    OMX_U32 nTargetBitrate;
+} OMX_VIDEO_PARAM_BITRATETYPE;
+
+
+/**
+ * Enumeration of possible motion vector (MV) types
+ */
+typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
+    OMX_Video_MotionVectorPixel,
+    OMX_Video_MotionVectorHalfPel,
+    OMX_Video_MotionVectorQuarterPel,
+    OMX_Video_MotionVectorEighthPel,
+    OMX_Video_MotionVectorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_Video_MotionVectorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_Video_MotionVectorMax = 0x7FFFFFFF
+} OMX_VIDEO_MOTIONVECTORTYPE;
+
+
+/**
+ * Structure for configuring the number of motion vectors used as well
+ * as their accuracy.
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the struct in bytes
+ *  nVersion         : OMX spec version info
+ *  nPortIndex       : port that this structure applies to
+ *  eAccuracy        : Enumerated MV accuracy
+ *  bUnrestrictedMVs : Allow unrestricted MVs
+ *  bFourMV          : Allow use of 4 MVs
+ *  sXSearchRange    : Search range in horizontal direction for MVs
+ *  sYSearchRange    : Search range in vertical direction for MVs
+ */
+typedef struct OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_MOTIONVECTORTYPE eAccuracy;
+    OMX_BOOL bUnrestrictedMVs;
+    OMX_BOOL bFourMV;
+    OMX_S32 sXSearchRange;
+    OMX_S32 sYSearchRange;
+} OMX_VIDEO_PARAM_MOTIONVECTORTYPE;
+
+
+/**
+ * Enumeration of possible methods to use for Intra Refresh
+ */
+typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
+    OMX_VIDEO_IntraRefreshCyclic,
+    OMX_VIDEO_IntraRefreshAdaptive,
+    OMX_VIDEO_IntraRefreshBoth,
+    OMX_VIDEO_IntraRefreshKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_IntraRefreshVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
+} OMX_VIDEO_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for configuring intra refresh mode
+ *
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to
+ *  eRefreshMode : Cyclic, Adaptive, or Both
+ *  nAirMBs      : Number of intra macroblocks to refresh in a frame when
+ *                 AIR is enabled
+ *  nAirRef      : Number of times a motion marked macroblock has to be
+ *                 intra coded
+ *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"
+ *                 when CIR is enabled
+ */
+typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_INTRAREFRESHTYPE eRefreshMode;
+    OMX_U32 nAirMBs;
+    OMX_U32 nAirRef;
+    OMX_U32 nCirMBs;
+} OMX_VIDEO_PARAM_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for enabling various error correction methods for video
+ * compression.
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information
+ *  nPortIndex              : Port that this structure applies to
+ *  bEnableHEC              : Enable/disable header extension codes (HEC)
+ *  bEnableResync           : Enable/disable resynchronization markers
+ *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be
+ *                            applied in the stream
+ *  bEnableDataPartitioning : Enable/disable data partitioning
+ *  bEnableRVLC             : Enable/disable reversible variable length
+ *                            coding
+ */
+typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnableHEC;
+    OMX_BOOL bEnableResync;
+    OMX_U32  nResynchMarkerSpacing;
+    OMX_BOOL bEnableDataPartitioning;
+    OMX_BOOL bEnableRVLC;
+} OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;
+
+
+/**
+ * Configuration of variable block-size motion compensation (VBSMC)
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  b16x16     : Enable inter block search 16x16
+ *  b16x8      : Enable inter block search 16x8
+ *  b8x16      : Enable inter block search 8x16
+ *  b8x8       : Enable inter block search 8x8
+ *  b8x4       : Enable inter block search 8x4
+ *  b4x8       : Enable inter block search 4x8
+ *  b4x4       : Enable inter block search 4x4
+ */
+typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL b16x16;
+    OMX_BOOL b16x8;
+    OMX_BOOL b8x16;
+    OMX_BOOL b8x8;
+    OMX_BOOL b8x4;
+    OMX_BOOL b4x8;
+    OMX_BOOL b4x4;
+} OMX_VIDEO_PARAM_VBSMCTYPE;
+
+
+/**
+ * H.263 profile types, each profile indicates support for various
+ * performance bounds and different annexes.
+ *
+ * ENUMS:
+ *  Baseline           : Baseline Profile: H.263 (V1), no optional modes
+ *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility
+ *                       Profile: H.263+ (V2), includes annexes I, J, L.4
+ *                       and T
+ *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1),
+ *                       includes annex F
+ *  ISWV2              : Interactive Streaming Wireless Profile: H.263+
+ *                       (V2), includes annexes I, J, K and T
+ *  ISWV3              : Interactive Streaming Wireless Profile: H.263++
+ *                       (V3), includes profile 3 and annexes V and W.6.3.8
+ *  HighCompression    : Conversational High Compression Profile: H.263++
+ *                       (V3), includes profiles 1 & 2 and annexes D and U
+ *  Internet           : Conversational Internet Profile: H.263++ (V3),
+ *                       includes profile 5 and annex K
+ *  Interlace          : Conversational Interlace Profile: H.263++ (V3),
+ *                       includes profile 5 and annex W.6.3.11
+ *  HighLatency        : High Latency Profile: H.263++ (V3), includes
+ *                       profile 6 and annexes O.1 and P.5
+ */
+typedef enum OMX_VIDEO_H263PROFILETYPE {
+    OMX_VIDEO_H263ProfileBaseline            = 0x01,
+    OMX_VIDEO_H263ProfileH320Coding          = 0x02,
+    OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,
+    OMX_VIDEO_H263ProfileISWV2               = 0x08,
+    OMX_VIDEO_H263ProfileISWV3               = 0x10,
+    OMX_VIDEO_H263ProfileHighCompression     = 0x20,
+    OMX_VIDEO_H263ProfileInternet            = 0x40,
+    OMX_VIDEO_H263ProfileInterlace           = 0x80,
+    OMX_VIDEO_H263ProfileHighLatency         = 0x100,
+    OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_H263ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF
+} OMX_VIDEO_H263PROFILETYPE;
+
+
+/**
+ * H.263 level types, each level indicates support for various frame sizes,
+ * bit rates, decoder frame rates.
+ */
+typedef enum OMX_VIDEO_H263LEVELTYPE {
+    OMX_VIDEO_H263Level10  = 0x01,
+    OMX_VIDEO_H263Level20  = 0x02,
+    OMX_VIDEO_H263Level30  = 0x04,
+    OMX_VIDEO_H263Level40  = 0x08,
+    OMX_VIDEO_H263Level45  = 0x10,
+    OMX_VIDEO_H263Level50  = 0x20,
+    OMX_VIDEO_H263Level60  = 0x40,
+    OMX_VIDEO_H263Level70  = 0x80,
+    OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_H263LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_H263LevelMax = 0x7FFFFFFF
+} OMX_VIDEO_H263LEVELTYPE;
+
+
+/**
+ * Specifies the picture type. These values should be OR'd to signal all
+ * pictures types which are allowed.
+ *
+ * ENUMS:
+ *  Generic Picture Types:          I, P and B
+ *  H.263 Specific Picture Types:   SI and SP
+ *  H.264 Specific Picture Types:   EI and EP
+ *  MPEG-4 Specific Picture Types:  S
+ */
+typedef enum OMX_VIDEO_PICTURETYPE {
+    OMX_VIDEO_PictureTypeI   = 0x01,
+    OMX_VIDEO_PictureTypeP   = 0x02,
+    OMX_VIDEO_PictureTypeB   = 0x04,
+    OMX_VIDEO_PictureTypeSI  = 0x08,
+    OMX_VIDEO_PictureTypeSP  = 0x10,
+    OMX_VIDEO_PictureTypeEI  = 0x11,
+    OMX_VIDEO_PictureTypeEP  = 0x12,
+    OMX_VIDEO_PictureTypeS   = 0x14,
+    OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_PictureTypeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
+} OMX_VIDEO_PICTURETYPE;
+
+
+/**
+ * H.263 Params
+ *
+ * STRUCT MEMBERS:
+ *  nSize                    : Size of the structure in bytes
+ *  nVersion                 : OMX specification version information
+ *  nPortIndex               : Port that this structure applies to
+ *  nPFrames                 : Number of P frames between each I frame
+ *  nBFrames                 : Number of B frames between each I frame
+ *  eProfile                 : H.263 profile(s) to use
+ *  eLevel                   : H.263 level(s) to use
+ *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE
+ *                             (specified in the 1998 version of H.263) to
+ *                             indicate custom picture sizes or clock
+ *                             frequencies
+ *  nAllowedPictureTypes     : Specifies the picture types allowed in the
+ *                             bitstream
+ *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is
+ *                             not constrained. It is recommended to change
+ *                             the value of the RTYPE bit for each reference
+ *                             picture in error-free communication
+ *  nPictureHeaderRepetition : Specifies the frequency of picture header
+ *                             repetition
+ *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB
+ *                             headers in units of GOBs
+ */
+typedef struct OMX_VIDEO_PARAM_H263TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_VIDEO_H263PROFILETYPE eProfile;
+	OMX_VIDEO_H263LEVELTYPE eLevel;
+    OMX_BOOL bPLUSPTYPEAllowed;
+    OMX_U32 nAllowedPictureTypes;
+    OMX_BOOL bForceRoundingTypeToZero;
+    OMX_U32 nPictureHeaderRepetition;
+    OMX_U32 nGOBHeaderInterval;
+} OMX_VIDEO_PARAM_H263TYPE;
+
+
+/**
+ * MPEG-2 profile types, each profile indicates support for various
+ * performance bounds and different annexes.
+ */
+typedef enum OMX_VIDEO_MPEG2PROFILETYPE {
+    OMX_VIDEO_MPEG2ProfileSimple = 0,  /**< Simple Profile */
+    OMX_VIDEO_MPEG2ProfileMain,        /**< Main Profile */
+    OMX_VIDEO_MPEG2Profile422,         /**< 4:2:2 Profile */
+    OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
+    OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
+    OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
+    OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_MPEG2ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF
+} OMX_VIDEO_MPEG2PROFILETYPE;
+
+
+/**
+ * MPEG-2 level types, each level indicates support for various frame
+ * sizes, bit rates, decoder frame rates.  No need
+ */
+typedef enum OMX_VIDEO_MPEG2LEVELTYPE {
+    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */
+    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */
+    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */
+    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */
+    OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_MPEG2LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF
+} OMX_VIDEO_MPEG2LEVELTYPE;
+
+
+/**
+ * MPEG-2 params
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nPFrames   : Number of P frames between each I frame
+ *  nBFrames   : Number of B frames between each I frame
+ *  eProfile   : MPEG-2 profile(s) to use
+ *  eLevel     : MPEG-2 levels(s) to use
+ */
+typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_VIDEO_MPEG2PROFILETYPE eProfile;
+	OMX_VIDEO_MPEG2LEVELTYPE eLevel;
+} OMX_VIDEO_PARAM_MPEG2TYPE;
+
+
+/**
+ * MPEG-4 profile types, each profile indicates support for various
+ * performance bounds and different annexes.
+ *
+ * ENUMS:
+ *  - Simple Profile, Levels 1-3
+ *  - Simple Scalable Profile, Levels 1-2
+ *  - Core Profile, Levels 1-2
+ *  - Main Profile, Levels 2-4
+ *  - N-bit Profile, Level 2
+ *  - Scalable Texture Profile, Level 1
+ *  - Simple Face Animation Profile, Levels 1-2
+ *  - Simple Face and Body Animation (FBA) Profile, Levels 1-2
+ *  - Basic Animated Texture Profile, Levels 1-2
+ *  - Hybrid Profile, Levels 1-2
+ *  - Advanced Real Time Simple Profiles, Levels 1-4
+ *  - Core Scalable Profile, Levels 1-3
+ *  - Advanced Coding Efficiency Profile, Levels 1-4
+ *  - Advanced Core Profile, Levels 1-2
+ *  - Advanced Scalable Texture, Levels 2-3
+ */
+typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
+    OMX_VIDEO_MPEG4ProfileSimple           = 0x01,
+    OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,
+    OMX_VIDEO_MPEG4ProfileCore             = 0x04,
+    OMX_VIDEO_MPEG4ProfileMain             = 0x08,
+    OMX_VIDEO_MPEG4ProfileNbit             = 0x10,
+    OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,
+    OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,
+    OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,
+    OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,
+    OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,
+    OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,
+    OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,
+    OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,
+    OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,
+    OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,
+    OMX_VIDEO_MPEG4ProfileAdvancedSimple   = 0x8000,
+    OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_MPEG4ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF
+} OMX_VIDEO_MPEG4PROFILETYPE;
+
+
+/**
+ * MPEG-4 level types, each level indicates support for various frame
+ * sizes, bit rates, decoder frame rates.  No need
+ */
+typedef enum OMX_VIDEO_MPEG4LEVELTYPE {
+    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */
+    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */
+    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */
+    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */
+    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */
+    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */
+    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */
+    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */
+    OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_MPEG4LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF
+} OMX_VIDEO_MPEG4LEVELTYPE;
+
+
+/**
+ * MPEG-4 configuration.  This structure handles configuration options
+ * which are specific to MPEG4 algorithms
+ *
+ * STRUCT MEMBERS:
+ *  nSize                : Size of the structure in bytes
+ *  nVersion             : OMX specification version information
+ *  nPortIndex           : Port that this structure applies to
+ *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+
+ *                         Annex K). Put zero if not used
+ *  bSVH                 : Enable Short Video Header mode
+ *  bGov                 : Flag to enable GOV
+ *  nPFrames             : Number of P frames between each I frame (also called
+ *                         GOV period)
+ *  nBFrames             : Number of B frames between each I frame
+ *  nIDCVLCThreshold     : Value of intra DC VLC threshold
+ *  bACPred              : Flag to use ac prediction
+ *  nMaxPacketSize       : Maximum size of packet in bytes.
+ *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4.
+ *                         Interpreted as described in MPEG4 standard.
+ *  eProfile             : MPEG-4 profile(s) to use.
+ *  eLevel               : MPEG-4 level(s) to use.
+ *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
+ *  nHeaderExtension     : Specifies the number of consecutive video packet
+ *                         headers within a VOP
+ *  bReversibleVLC       : Specifies whether reversible variable length coding
+ *                         is in use
+ */
+typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nSliceHeaderSpacing;
+    OMX_BOOL bSVH;
+    OMX_BOOL bGov;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_U32 nIDCVLCThreshold;
+    OMX_BOOL bACPred;
+    OMX_U32 nMaxPacketSize;
+    OMX_U32 nTimeIncRes;
+    OMX_VIDEO_MPEG4PROFILETYPE eProfile;
+    OMX_VIDEO_MPEG4LEVELTYPE eLevel;
+    OMX_U32 nAllowedPictureTypes;
+    OMX_U32 nHeaderExtension;
+    OMX_BOOL bReversibleVLC;
+} OMX_VIDEO_PARAM_MPEG4TYPE;
+
+
+/**
+ * WMV Versions
+ */
+typedef enum OMX_VIDEO_WMVFORMATTYPE {
+    OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
+    OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
+    OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
+    OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
+    OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_WMFFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
+} OMX_VIDEO_WMVFORMATTYPE;
+
+
+/**
+ * WMV Params
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  eFormat    : Version of WMV stream / data
+ */
+typedef struct OMX_VIDEO_PARAM_WMVTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_WMVFORMATTYPE eFormat;
+} OMX_VIDEO_PARAM_WMVTYPE;
+
+
+/**
+ * Real Video Version
+ */
+typedef enum OMX_VIDEO_RVFORMATTYPE {
+    OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
+    OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
+    OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
+    OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
+    OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_RVFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
+} OMX_VIDEO_RVFORMATTYPE;
+
+
+/**
+ * Real Video Params
+ *
+ * STUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Port that this structure applies to
+ *  eFormat            : Version of RV stream / data
+ *  nBitsPerPixel      : Bits per pixel coded in the frame
+ *  nPaddedWidth       : Padded width in pixel of a video frame
+ *  nPaddedHeight      : Padded Height in pixels of a video frame
+ *  nFrameRate         : Rate of video in frames per second
+ *  nBitstreamFlags    : Flags which internal information about the bitstream
+ *  nBitstreamVersion  : Bitstream version
+ *  nMaxEncodeFrameSize: Max encoded frame size
+ *  bEnablePostFilter  : Turn on/off post filter
+ *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
+ *  bEnableLatencyMode : When enabled, the decoder does not display a decoded
+ *                       frame until it has detected that no enhancement layer
+ *  					 frames or dependent B frames will be coming. This
+ *  					 detection usually occurs when a subsequent non-B
+ *  					 frame is encountered
+ */
+typedef struct OMX_VIDEO_PARAM_RVTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_RVFORMATTYPE eFormat;
+    OMX_U16 nBitsPerPixel;
+    OMX_U16 nPaddedWidth;
+    OMX_U16 nPaddedHeight;
+    OMX_U32 nFrameRate;
+    OMX_U32 nBitstreamFlags;
+    OMX_U32 nBitstreamVersion;
+    OMX_U32 nMaxEncodeFrameSize;
+    OMX_BOOL bEnablePostFilter;
+    OMX_BOOL bEnableTemporalInterpolation;
+    OMX_BOOL bEnableLatencyMode;
+} OMX_VIDEO_PARAM_RVTYPE;
+
+
+/**
+ * AVC profile types, each profile indicates support for various
+ * performance bounds and different annexes.
+ */
+typedef enum OMX_VIDEO_AVCPROFILETYPE {
+    OMX_VIDEO_AVCProfileBaseline = 0x01,   /**< Baseline profile */
+    OMX_VIDEO_AVCProfileMain     = 0x02,   /**< Main profile */
+    OMX_VIDEO_AVCProfileExtended = 0x04,   /**< Extended profile */
+    OMX_VIDEO_AVCProfileHigh     = 0x08,   /**< High profile */
+    OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
+    OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
+    OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
+    OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_AVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF
+} OMX_VIDEO_AVCPROFILETYPE;
+
+
+/**
+ * AVC level types, each level indicates support for various frame sizes,
+ * bit rates, decoder frame rates.  No need
+ */
+typedef enum OMX_VIDEO_AVCLEVELTYPE {
+    OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
+    OMX_VIDEO_AVCLevel1b  = 0x02,     /**< Level 1b */
+    OMX_VIDEO_AVCLevel11  = 0x04,     /**< Level 1.1 */
+    OMX_VIDEO_AVCLevel12  = 0x08,     /**< Level 1.2 */
+    OMX_VIDEO_AVCLevel13  = 0x10,     /**< Level 1.3 */
+    OMX_VIDEO_AVCLevel2   = 0x20,     /**< Level 2 */
+    OMX_VIDEO_AVCLevel21  = 0x40,     /**< Level 2.1 */
+    OMX_VIDEO_AVCLevel22  = 0x80,     /**< Level 2.2 */
+    OMX_VIDEO_AVCLevel3   = 0x100,    /**< Level 3 */
+    OMX_VIDEO_AVCLevel31  = 0x200,    /**< Level 3.1 */
+    OMX_VIDEO_AVCLevel32  = 0x400,    /**< Level 3.2 */
+    OMX_VIDEO_AVCLevel4   = 0x800,    /**< Level 4 */
+    OMX_VIDEO_AVCLevel41  = 0x1000,   /**< Level 4.1 */
+    OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
+    OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
+    OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
+    OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_AVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF
+} OMX_VIDEO_AVCLEVELTYPE;
+
+
+/**
+ * AVC loop filter modes
+ *
+ * OMX_VIDEO_AVCLoopFilterEnable               : Enable
+ * OMX_VIDEO_AVCLoopFilterDisable              : Disable
+ * OMX_VIDEO_AVCLoopFilterDisableSliceBoundary : Disabled on slice boundaries
+ */
+typedef enum OMX_VIDEO_AVCLOOPFILTERTYPE {
+    OMX_VIDEO_AVCLoopFilterEnable = 0,
+    OMX_VIDEO_AVCLoopFilterDisable,
+    OMX_VIDEO_AVCLoopFilterDisableSliceBoundary,
+    OMX_VIDEO_AVCLoopFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_AVCLoopFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
+} OMX_VIDEO_AVCLOOPFILTERTYPE;
+
+
+/**
+ * AVC params
+ *
+ * STRUCT MEMBERS:
+ *  nSize                     : Size of the structure in bytes
+ *  nVersion                  : OMX specification version information
+ *  nPortIndex                : Port that this structure applies to
+ *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put
+ *                              zero if not used
+ *  nPFrames                  : Number of P frames between each I frame
+ *  nBFrames                  : Number of B frames between each I frame
+ *  bUseHadamard              : Enable/disable Hadamard transform
+ *  nRefFrames                : Max number of reference frames to use for inter
+ *                              motion search (1-16)
+ *  nRefIdxTrailing           : Pic param set ref frame index (index into ref
+ *                              frame buffer of trailing frames list), B frame
+ *                              support
+ *  nRefIdxForward            : Pic param set ref frame index (index into ref
+ *                              frame buffer of forward frames list), B frame
+ *                              support
+ *  bEnableUEP                : Enable/disable unequal error protection. This
+ *                              is only valid of data partitioning is enabled.
+ *  bEnableFMO                : Enable/disable flexible macroblock ordering
+ *  bEnableASO                : Enable/disable arbitrary slice ordering
+ *  bEnableRS                 : Enable/disable sending of redundant slices
+ *  eProfile                  : AVC profile(s) to use
+ *  eLevel                    : AVC level(s) to use
+ *  nAllowedPictureTypes      : Specifies the picture types allowed in the
+ *                              bitstream
+ *  bFrameMBsOnly             : specifies that every coded picture of the
+ *                              coded video sequence is a coded frame
+ *                              containing only frame macroblocks
+ *  bMBAFF                    : Enable/disable switching between frame and
+ *                              field macroblocks within a picture
+ *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the
+ *                              syntax elements for which two descriptors appear
+ *                              in the syntax tables
+ *  bWeightedPPrediction      : Enable/disable weighted prediction shall not
+ *                              be applied to P and SP slices
+ *  nWeightedBipredicitonMode : Default weighted prediction is applied to B
+ *                              slices
+ *  bconstIpred               : Enable/disable intra prediction
+ *  bDirect8x8Inference       : Specifies the method used in the derivation
+ *                              process for luma motion vectors for B_Skip,
+ *                              B_Direct_16x16 and B_Direct_8x8 as specified
+ *                              in subclause 8.4.1.2 of the AVC spec
+ *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
+ *                              mode used in B slice coding (related to
+ *                              bDirect8x8Inference) . Spatial direct mode is
+ *                              more common and should be the default.
+ *  nCabacInitIdx             : Index used to init CABAC contexts
+ *  eLoopFilterMode           : Enable/disable loop filter
+ */
+typedef struct OMX_VIDEO_PARAM_AVCTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nSliceHeaderSpacing;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_BOOL bUseHadamard;
+    OMX_U32 nRefFrames;
+	OMX_U32 nRefIdx10ActiveMinus1;
+	OMX_U32 nRefIdx11ActiveMinus1;
+    OMX_BOOL bEnableUEP;
+    OMX_BOOL bEnableFMO;
+    OMX_BOOL bEnableASO;
+    OMX_BOOL bEnableRS;
+    OMX_VIDEO_AVCPROFILETYPE eProfile;
+	OMX_VIDEO_AVCLEVELTYPE eLevel;
+    OMX_U32 nAllowedPictureTypes;
+	OMX_BOOL bFrameMBsOnly;
+    OMX_BOOL bMBAFF;
+    OMX_BOOL bEntropyCodingCABAC;
+    OMX_BOOL bWeightedPPrediction;
+    OMX_U32 nWeightedBipredicitonMode;
+    OMX_BOOL bconstIpred ;
+    OMX_BOOL bDirect8x8Inference;
+	OMX_BOOL bDirectSpatialTemporal;
+	OMX_U32 nCabacInitIdc;
+	OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
+} OMX_VIDEO_PARAM_AVCTYPE;
+
+typedef struct OMX_VIDEO_PARAM_PROFILELEVELTYPE {
+   OMX_U32 nSize;
+   OMX_VERSIONTYPE nVersion;
+   OMX_U32 nPortIndex;
+   OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE,
+                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE,
+                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
+                               This parameter is valid only for
+                               OMX_IndexParamVideoProfileLevelQuerySupported index,
+                               For all other indices this parameter is to be ignored. */
+} OMX_VIDEO_PARAM_PROFILELEVELTYPE;
+
+/**
+ * Structure for dynamically configuring bitrate mode of a codec.
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  nEncodeBitrate : Target average bitrate to be generated in bps
+ */
+typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nEncodeBitrate;
+} OMX_VIDEO_CONFIG_BITRATETYPE;
+
+/**
+ * Defines Encoder Frame Rate setting
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to
+ *  xEncodeFramerate : Encoding framerate represented in Q16 format
+ */
+typedef struct OMX_CONFIG_FRAMERATETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 xEncodeFramerate; /* Q16 format */
+} OMX_CONFIG_FRAMERATETYPE;
+
+typedef struct OMX_CONFIG_INTRAREFRESHVOPTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL IntraRefreshVOP;
+} OMX_CONFIG_INTRAREFRESHVOPTYPE;
+
+typedef struct OMX_CONFIG_MACROBLOCKERRORMAPTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nErrMapSize;           /* Size of the Error Map in bytes */
+    OMX_U8  ErrMap[1];             /* Error map hint */
+} OMX_CONFIG_MACROBLOCKERRORMAPTYPE;
+
+typedef struct OMX_CONFIG_MBERRORREPORTINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnabled;
+} OMX_CONFIG_MBERRORREPORTINGTYPE;
+
+typedef struct OMX_PARAM_MACROBLOCKSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nMacroblocks;
+} OMX_PARAM_MACROBLOCKSTYPE;
+
+/**
+ * AVC Slice Mode modes
+ *
+ * OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
+ * OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
+ * OMX_VIDEO_SLICEMODE_AVCByteSlice : NAL mode, number of bytes per frame
+ */
+typedef enum OMX_VIDEO_AVCSLICEMODETYPE {
+    OMX_VIDEO_SLICEMODE_AVCDefault = 0,
+    OMX_VIDEO_SLICEMODE_AVCMBSlice,
+    OMX_VIDEO_SLICEMODE_AVCByteSlice,
+    OMX_VIDEO_SLICEMODE_AVCKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_VIDEO_SLICEMODE_AVCVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
+} OMX_VIDEO_AVCSLICEMODETYPE;
+
+/**
+ * AVC FMO Slice Mode Params
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNumSliceGroups : Specifies the number of slice groups
+ *  nSliceGroupMapType : Specifies the type of slice groups
+ *  eSliceMode : Specifies the type of slice
+ */
+typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U8 nNumSliceGroups;
+    OMX_U8 nSliceGroupMapType;
+    OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
+} OMX_VIDEO_PARAM_AVCSLICEFMO;
+
+/**
+ * AVC IDR Period Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nIDRPeriod : Specifies periodicity of IDR frames
+ *  nPFrames : Specifies internal of coding Intra frames
+ */
+typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIDRPeriod;
+    OMX_U32 nPFrames;
+} OMX_VIDEO_CONFIG_AVCINTRAPERIOD;
+
+/**
+ * AVC NAL Size Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNaluBytes : Specifies the NAL unit size
+ */
+typedef struct OMX_VIDEO_CONFIG_NALSIZE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nNaluBytes;
+} OMX_VIDEO_CONFIG_NALSIZE;
+
+/**
+ * Vendor Private Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nCapacity  : Specifies the private unit size
+ *  nHolder    : Pointer to private unit address 
+ */
+typedef struct OMX_VIDEO_CONFIG_PRI_INFOTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nCapacity;
+    OMX_PTR nHolder;
+} OMX_VIDEO_CONFIG_PRI_INFOTYPE;
+
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/core/inc/khronos/openmax/include/OMX_VideoExt.h b/core/inc/khronos/openmax/include/OMX_VideoExt.h
new file mode 100644
index 0000000..f97a3bf
--- /dev/null
+++ b/core/inc/khronos/openmax/include/OMX_VideoExt.h
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2010 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_VideoExt.h - OpenMax IL version 1.1.2
+ * The OMX_VideoExt header file contains extensions to the
+ * definitions used by both the application and the component to
+ * access video items.
+ */
+
+#ifndef OMX_VideoExt_h
+#define OMX_VideoExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Core.h>
+
+/** NALU Formats */
+typedef enum OMX_NALUFORMATSTYPE {
+    OMX_NaluFormatStartCodes = 1,
+    OMX_NaluFormatOneNaluPerBuffer = 2,
+    OMX_NaluFormatOneByteInterleaveLength = 4,
+    OMX_NaluFormatTwoByteInterleaveLength = 8,
+    OMX_NaluFormatFourByteInterleaveLength = 16,
+    OMX_NaluFormatZeroByteInterleaveLength = 32,
+    OMX_NaluFormatStartCodesSeparateFirstHeader = 64,
+    OMX_NaluFormatCodingMax = 0x7FFFFFFF
+} OMX_NALUFORMATSTYPE;
+
+
+/** NAL Stream Format */
+typedef struct OMX_NALSTREAMFORMATTYPE{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_NALUFORMATSTYPE eNaluFormat;
+} OMX_NALSTREAMFORMATTYPE;
+
+typedef struct OMX_VIDEO_PARAM_BYTESTREAMTYPE {
+     OMX_U32 nSize;                 // Size of the structure
+     OMX_VERSIONTYPE nVersion;      // OMX specification version
+     OMX_U32 nPortIndex;            // Port that this structure applies to
+     OMX_BOOL bBytestream;          // Enable/disable bytestream support
+} OMX_VIDEO_PARAM_BYTESTREAMTYPE;
+
+typedef struct OMX_VIDEO_CONFIG_INTEL_BITRATETYPE {
+     OMX_U32 nSize;
+     OMX_VERSIONTYPE nVersion;
+     OMX_U32 nPortIndex;
+     OMX_U32 nMaxEncodeBitrate;    // Maximum bitrate
+     OMX_U32 nTargetPercentage;    // Target bitrate as percentage of maximum bitrate; e.g. 95 is 95%
+     OMX_U32 nWindowSize;          // Window size in milliseconds allowed for bitrate to reach target
+     OMX_U32 nInitialQP;           // Initial QP for I frames
+     OMX_U32 nMinQP;
+} OMX_VIDEO_CONFIG_INTEL_BITRATETYPE;
+
+typedef enum OMX_VIDEO_INTEL_CONTROLRATETYPE {
+    OMX_Video_Intel_ControlRateDisable,
+    OMX_Video_Intel_ControlRateVariable,
+    OMX_Video_Intel_ControlRateConstant,
+    OMX_Video_Intel_ControlRateVideoConferencingMode,
+    OMX_Video_Intel_ControlRateMax = 0x7FFFFFFF
+} OMX_VIDEO_INTEL_CONTROLRATETYPE;
+
+typedef struct OMX_VIDEO_PARAM_INTEL_BITRATETYPE {
+     OMX_U32 nSize;
+     OMX_VERSIONTYPE nVersion;
+     OMX_U32 nPortIndex;
+     OMX_VIDEO_INTEL_CONTROLRATETYPE eControlRate;
+     OMX_U32 nTargetBitrate;
+} OMX_VIDEO_PARAM_INTEL_BITRATETYPE;
+
+typedef struct OMX_VIDEO_PARAM_INTEL_AVC_DECODE_SETTINGS {
+     OMX_U32 nSize;                       // Size of the structure
+     OMX_VERSIONTYPE nVersion;            // OMX specification version
+     OMX_U32 nPortIndex;                  // Port that this structure applies to
+     OMX_U32 nMaxNumberOfReferenceFrame;  // Maximum number of reference frames
+     OMX_U32 nMaxWidth;                   // Maximum width of video
+     OMX_U32 nMaxHeight;                  // Maximum height of video
+} OMX_VIDEO_PARAM_INTEL_AVC_DECODE_SETTINGS;
+
+
+typedef struct OMX_VIDEO_CONFIG_INTEL_SLICE_NUMBERS {
+     OMX_U32 nSize;                       // Size of the structure
+     OMX_VERSIONTYPE nVersion;            // OMX specification version
+     OMX_U32 nPortIndex;                  // Port that this structure applies to
+     OMX_U32 nISliceNumber;               // I frame slice number
+     OMX_U32 nPSliceNumber;               // P frame slice number
+} OMX_VIDEO_CONFIG_INTEL_SLICE_NUMBERS;
+
+
+typedef struct OMX_VIDEO_CONFIG_INTEL_AIR {
+     OMX_U32 nSize;                       // Size of the structure
+     OMX_VERSIONTYPE nVersion;            // OMX specification version
+     OMX_U32 nPortIndex;                  // Port that this structure applies to
+     OMX_BOOL bAirEnable;                 // Enable AIR
+     OMX_BOOL bAirAuto;                   // AIR auto
+     OMX_U32 nAirMBs;                     // Number of AIR MBs
+     OMX_U32 nAirThreshold;               // AIR Threshold
+
+} OMX_VIDEO_CONFIG_INTEL_AIR;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_VideoExt_h */
+/* File EOF */
diff --git a/core/src/Android.mk b/core/src/Android.mk
new file mode 100644
index 0000000..f14346b
--- /dev/null
+++ b/core/src/Android.mk
@@ -0,0 +1,26 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	wrs_omxcore.cpp
+
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE := libwrs_omxil_core_pvwrapped
+
+LOCAL_CFLAGS := $(OMXLOG_CFLAGS) -DLOG_TAG=\"omxil-core\"
+LOCAL_CPPFLAGS :=
+
+LOCAL_LDFLAGS :=
+
+LOCAL_SHARED_LIBRARIES := \
+	libwrs_omxil_common \
+	libdl \
+	liblog
+
+LOCAL_C_INCLUDES := \
+	$(WRS_OMXIL_CORE_ROOT)/utils/inc \
+	$(WRS_OMXIL_CORE_ROOT)/base/inc \
+	$(WRS_OMXIL_CORE_ROOT)/core/inc/khronos/openmax/include \
+	$(PV_INCLUDES)
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/core/src/Makefile.am b/core/src/Makefile.am
new file mode 100644
index 0000000..956dafd
--- /dev/null
+++ b/core/src/Makefile.am
@@ -0,0 +1,50 @@
+libOmxCore_source_cpp = \
+	wrs_omxcore.cpp \
+	$(NULL)
+
+libOmxCore_source_h = \
+	../inc/khronos/openmax/include/OMX_Audio.h \
+	../inc/khronos/openmax/include/OMX_ContentPipe.h \
+	../inc/khronos/openmax/include/OMX_Image.h \
+	../inc/khronos/openmax/include/OMX_Index.h \
+	../inc/khronos/openmax/include/OMX_IVCommon.h \
+	../inc/khronos/openmax/include/OMX_Types.h \
+	../inc/khronos/openmax/include/OMX_Video.h \
+	../inc/khronos/openmax/include/OMX_Component.h \
+	../inc/khronos/openmax/include/OMX_Core.h \
+	../inc/khronos/openmax/include/OMX_IndexExt.h \
+	../inc/khronos/openmax/include/OMX_IntelErrorTypes.h \
+	../inc/khronos/openmax/include/OMX_Other.h \
+	../inc/khronos/openmax/include/OMX_VideoExt.h \
+	$(NULL)
+
+libOmxCore_source_priv_h = \
+	$(NULL)
+	
+libOmxCore_ldflags = \
+	-version-info 0:5:0 \
+	-no-undefined \
+	$(NULL)
+
+libOmxCore_deps_libs = \
+	$(top_srcdir)/base/src/libomxil_base.la \
+	$(top_srcdir)/utils/src/libomxil_utils.la \
+	-ldl -lpthread \
+	$(NULL)
+
+libOmxCore_deps = \
+	$(top_srcdir)/base/src/libomxil_base.la \
+	$(top_srcdir)/utils/src/libomxil_utils.la \
+	$(NULL)
+
+lib_LTLIBRARIES			= libOmxCore.la
+libOmxCoreincludedir		= ${includedir}/omx
+libOmxCoreinclude_HEADERS	= $(libOmxCore_source_h)
+noinst_HEADERS			= $(libOmxCore_source_h_priv)
+libOmxCore_la_SOURCES		= $(libOmxCore_source_cpp)
+libOmxCore_la_LDFLAGS		= $(libOmxCore_ldflags)
+libOmxCore_la_CPPFLAGS       	= -I../inc -I$(top_srcdir)/utils/inc -I$(top_srcdir)/base/inc -I../inc/khronos/openmax/include
+libOmxCore_la_DEPENDENCIES	= $(libOmxCore_deps)
+libOmxCore_la_LIBADD		= $(libOmxCore_deps_libs)
+
+DISTCLEANFILES = Makefile.in
diff --git a/core/src/ebuild.mk b/core/src/ebuild.mk
new file mode 100644
index 0000000..d2ce4ff
--- /dev/null
+++ b/core/src/ebuild.mk
@@ -0,0 +1,21 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	wrs_omxcore.cpp
+
+LOCAL_MODULE := libwrs_omxil_core
+
+LOCAL_CPPFLAGS :=
+
+LOCAL_LDFLAGS :=
+
+LOCAL_SHARED_LIBRARIES := \
+	libwrs_omxil_common
+
+LOCAL_C_INCLUDES := \
+	$(WRS_OMXIL_CORE_ROOT)/utils/inc \
+	$(WRS_OMXIL_CORE_ROOT)/base/inc \
+	$(WRS_OMXIL_CORE_ROOT)/core/inc/khronos/openmax/include
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/core/src/intel_m4v_config_parser.cpp b/core/src/intel_m4v_config_parser.cpp
new file mode 100644
index 0000000..4088852
--- /dev/null
+++ b/core/src/intel_m4v_config_parser.cpp
@@ -0,0 +1,1316 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "intel_m4v_config_parser.cpp"
+#include <utils/Log.h>
+
+
+#include "intel_m4v_config_parser.h"
+#include "oscl_mem.h"
+#include "oscl_dll.h"
+OSCL_DLL_ENTRY_POINT_DEFAULT()
+
+#define PV_CLZ(A,B) while (((B) & 0x8000) == 0) {(B) <<=1; A++;}
+
+static const uint32 mask[33] =
+{
+    0x00000000, 0x00000001, 0x00000003, 0x00000007,
+    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
+    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
+    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
+    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
+    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
+    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
+    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
+    0xffffffff
+};
+
+int32 LocateFrameHeader(uint8 *ptr, int32 size)
+{
+    int32 count = 0;
+    int32 i = size;
+
+    if (size < 1)
+    {
+        return 0;
+    }
+    while (i--)
+    {
+        if ((count > 1) && (*ptr == 0x01))
+        {
+            i += 2;
+            break;
+        }
+
+        if (*ptr++)
+            count = 0;
+        else
+            count++;
+    }
+    return (size - (i + 1));
+}
+
+void movePointerTo(mp4StreamType *psBits, int32 pos)
+{
+    uint32 byte_pos;
+    if (pos < 0)
+    {
+        pos = 0;
+    }
+
+    byte_pos = pos >> 3;
+
+    if (byte_pos > (psBits->numBytes - psBits->bytePos))
+    {
+        byte_pos = (psBits->numBytes - psBits->bytePos);
+    }
+
+    psBits->bytePos = byte_pos & -4;
+    psBits->dataBitPos = psBits->bytePos << 3;
+    FlushBits(psBits, ((pos & 0x7) + ((byte_pos & 0x3) << 3)));
+}
+
+int16 SearchNextM4VFrame(mp4StreamType *psBits)
+{
+    int16 status = 0;
+    uint8 *ptr;
+    int32 i;
+    uint32 initial_byte_aligned_position = (psBits->dataBitPos + 7) >> 3;
+
+    ptr = psBits->data + initial_byte_aligned_position;
+
+    i = LocateFrameHeader(ptr, psBits->numBytes - initial_byte_aligned_position);
+    if (psBits->numBytes <= initial_byte_aligned_position + i)
+    {
+        status = -1;
+    }
+    (void)movePointerTo(psBits, ((i + initial_byte_aligned_position) << 3)); /* ptr + i */
+    return status;
+}
+
+OSCL_EXPORT_REF int16 iGetM4VConfigInfo(uint8 *buffer, int32 length, int32 *width, int32 *height, int32 *display_width, int32 *display_height)
+{
+    int16 status;
+    mp4StreamType psBits;
+    psBits.data = buffer;
+    psBits.numBytes = length;
+    psBits.bitBuf = 0;
+    psBits.bitPos = 32;
+    psBits.bytePos = 0;
+    psBits.dataBitPos = 0;
+    *width = *height = *display_height = *display_width = 0;
+
+    if (length == 0)
+    {
+        return MP4_INVALID_VOL_PARAM;
+    }
+    int32 profilelevel = 0; // dummy value discarded here
+    status = iDecodeVOLHeader(&psBits, width, height, display_width, display_height, &profilelevel);
+    return status;
+}
+
+// name: iDecodeVOLHeader
+// Purpose: decode VOL header
+// return:  error code
+OSCL_EXPORT_REF int16 iDecodeVOLHeader(mp4StreamType *psBits, int32 *width, int32 *height, int32 *display_width, int32 *display_height, int32 *profilelevel)
+{
+    int16 iErrorStat;
+    uint32 codeword;
+    int32 time_increment_resolution, nbits_time_increment;
+    int32 i, j;
+
+    *profilelevel = 0x0000FFFF; // init to some invalid value. When this value is returned, then no profilelevel info is available
+
+    ShowBits(psBits, 32, &codeword);
+
+    if (codeword == VISUAL_OBJECT_SEQUENCE_START_CODE)
+    {
+        //DV: this is the wrong way to skip bits, use FLush or Read psBits->dataBitPos += 32;
+        ReadBits(psBits, 32, &codeword); // skip 32 bits of the Start code
+
+        ReadBits(psBits, 8, &codeword);
+
+        // record profile and level
+        *profilelevel = (int) codeword;
+
+        ShowBits(psBits, 32, &codeword);
+        if (codeword == USER_DATA_START_CODE)
+        {
+            iErrorStat = DecodeUserData(psBits);
+            if (iErrorStat) return MP4_INVALID_VOL_PARAM;
+        }
+
+
+        ReadBits(psBits, 32, &codeword);
+        if (codeword != VISUAL_OBJECT_START_CODE) return MP4_INVALID_VOL_PARAM;
+
+        /*  is_visual_object_identifier            */
+        ReadBits(psBits, 1, &codeword);
+
+        if (codeword)
+        {
+            /* visual_object_verid                            */
+            ReadBits(psBits, 4, &codeword);
+            /* visual_object_priority                         */
+            ReadBits(psBits, 3, &codeword);
+        }
+        /* visual_object_type                                 */
+        ReadBits(psBits, 4, &codeword);
+
+        if (codeword == 1)
+        { /* video_signal_type */
+            ReadBits(psBits, 1, &codeword);
+            if (codeword == 1)
+            {
+                /* video_format */
+                ReadBits(psBits, 3, &codeword);
+                /* video_range  */
+                ReadBits(psBits, 1, &codeword);
+                /* color_description */
+                ReadBits(psBits, 1, &codeword);
+                if (codeword == 1)
+                {
+                    /* color_primaries */
+                    ReadBits(psBits, 8, &codeword);;
+                    /* transfer_characteristics */
+                    ReadBits(psBits, 8, &codeword);
+                    /* matrix_coefficients */
+                    ReadBits(psBits, 8, &codeword);
+                }
+            }
+        }
+        else
+        {
+            int16 status = 0;
+            do
+            {
+                /* Search for VOL_HEADER */
+                status = SearchNextM4VFrame(psBits); /* search 0x00 0x00 0x01 */
+                if (status != 0)
+                    return MP4_INVALID_VOL_PARAM;
+
+                status = ReadBits(psBits, VOL_START_CODE_LENGTH, &codeword);
+            }
+            while ((codeword != VOL_START_CODE) && (status == 0));
+            goto decode_vol;
+        }
+        /* next_start_code() */
+        ByteAlign(psBits);
+
+        ShowBits(psBits, 32, &codeword);
+        if (codeword == USER_DATA_START_CODE)
+        {
+            iErrorStat = DecodeUserData(psBits);
+            if (iErrorStat) return MP4_INVALID_VOL_PARAM;
+        }
+        ShowBits(psBits, 27, &codeword);
+    }
+    else
+    {
+        ShowBits(psBits, 27, &codeword);
+    }
+
+    if (codeword == VO_START_CODE)
+    {
+
+        ReadBits(psBits, 32, &codeword);
+
+        /* video_object_layer_start_code                   */
+        ReadBits(psBits, 28, &codeword);
+        if (codeword != VOL_START_CODE)
+        {
+            if (psBits->dataBitPos >= (psBits->numBytes << 3))
+            {
+                return SHORT_HEADER_MODE; /* SH */
+            }
+            else
+            {
+                int16 status = 0;
+                do
+                {
+                    /* Search for VOL_HEADER */
+                    status = SearchNextM4VFrame(psBits); /* search 0x00 0x00 0x01 */
+                    if (status != 0)
+                        return MP4_INVALID_VOL_PARAM;
+
+                    status = ReadBits(psBits, VOL_START_CODE_LENGTH, &codeword);
+                }
+                while ((codeword != VOL_START_CODE) && (status == 0));
+                goto decode_vol;
+            }
+        }
+decode_vol:
+
+        uint32 vol_id;
+
+        /* vol_id (4 bits) */
+        ReadBits(psBits, 4, & vol_id);
+
+        // RandomAccessibleVOLFlag
+        ReadBits(psBits, 1, &codeword);
+
+        //Video Object Type Indication
+        ReadBits(psBits, 8, &codeword);
+        if (codeword != 1)
+        {
+            return MP4_INVALID_VOL_PARAM;
+        }
+
+        // is_object_layer_identifier
+        ReadBits(psBits, 1, &codeword);
+
+        if (codeword)
+        {
+            ReadBits(psBits, 4, &codeword);
+            ReadBits(psBits, 3, &codeword);
+        }
+
+        // aspect ratio
+        ReadBits(psBits, 4, &codeword);
+
+        if (codeword == 0xF)
+        {
+            // Extended Parameter
+            /* width */
+            ReadBits(psBits, 8, &codeword);
+            /* height */
+            ReadBits(psBits, 8, &codeword);
+        }
+
+        ReadBits(psBits, 1, &codeword);
+
+        if (codeword)
+        {
+            ReadBits(psBits, 2, &codeword);
+            if (codeword != 1)
+            {
+                return MP4_INVALID_VOL_PARAM;
+            }
+
+            ReadBits(psBits, 1, &codeword);
+
+            if (!codeword)
+            {
+                return MP4_INVALID_VOL_PARAM;
+            }
+
+            ReadBits(psBits, 1, &codeword);
+            if (codeword)   /* if (vbv_parameters) {}, page 36 */
+            {
+                ReadBits(psBits, 15, &codeword);
+                ReadBits(psBits, 1, &codeword);
+                if (codeword != 1)
+                    return MP4_INVALID_VOL_PARAM;
+
+                ReadBits(psBits, 15, &codeword);
+                ReadBits(psBits, 1, &codeword);
+                if (codeword != 1)
+                    return MP4_INVALID_VOL_PARAM;
+
+
+                ReadBits(psBits, 19, &codeword);
+                if (!(codeword & 0x8))
+                    return MP4_INVALID_VOL_PARAM;
+
+                ReadBits(psBits, 11, &codeword);
+                ReadBits(psBits, 1, &codeword);
+                if (codeword != 1)
+                    return MP4_INVALID_VOL_PARAM;
+
+                ReadBits(psBits, 15, &codeword);
+                ReadBits(psBits, 1, &codeword);
+                if (codeword != 1)
+                    return MP4_INVALID_VOL_PARAM;
+            }
+
+        }
+
+        ReadBits(psBits, 2, &codeword);
+
+        if (codeword != 0)
+        {
+            return MP4_INVALID_VOL_PARAM;
+        }
+
+        ReadBits(psBits, 1, &codeword);
+        if (codeword != 1)
+            return MP4_INVALID_VOL_PARAM;
+
+        ReadBits(psBits, 16, &codeword);
+        time_increment_resolution = codeword;
+
+
+        ReadBits(psBits, 1, &codeword);
+        if (codeword != 1)
+            return MP4_INVALID_VOL_PARAM;
+
+
+
+        ReadBits(psBits, 1, &codeword);
+
+        if (codeword && time_increment_resolution > 2)
+        {
+            i = time_increment_resolution - 1;
+            j = 1;
+            while (i >>= 1)
+            {
+                j++;
+            }
+            nbits_time_increment = j;
+
+            ReadBits(psBits, nbits_time_increment, &codeword);
+        }
+
+        ReadBits(psBits, 1, &codeword);
+        if (codeword != 1)
+            return MP4_INVALID_VOL_PARAM;
+
+        /* this should be 176 for QCIF */
+        ReadBits(psBits, 13, &codeword);
+        *display_width = (int32)codeword;
+        ReadBits(psBits, 1, &codeword);
+        if (codeword != 1)
+            return MP4_INVALID_VOL_PARAM;
+
+        /* this should be 144 for QCIF */
+        ReadBits(psBits, 13, &codeword);
+        *display_height = (int32)codeword;
+
+        *width = (*display_width + 15) & -16;
+        *height = (*display_height + 15) & -16;
+    }
+    else
+    {
+        /* SHORT_HEADER */
+        ShowBits(psBits, SHORT_VIDEO_START_MARKER_LENGTH, &codeword);
+        if (codeword == SHORT_VIDEO_START_MARKER)
+        {
+            iDecodeShortHeader(psBits, width, height, display_width, display_height);
+        }
+        else
+        {
+            int16 status = 0;
+            do
+            {
+                /* Search for VOL_HEADER */
+                status = SearchNextM4VFrame(psBits); /* search 0x00 0x00 0x01 */
+                if (status != 0)
+                    return MP4_INVALID_VOL_PARAM;
+
+                status = ReadBits(psBits, VOL_START_CODE_LENGTH, &codeword);
+            }
+            while ((codeword != VOL_START_CODE) && (status == 0));
+            goto decode_vol;
+        }
+    }
+    return 0;
+}
+
+
+
+OSCL_EXPORT_REF
+int16 iDecodeShortHeader(mp4StreamType *psBits,
+                         int32 *width,
+                         int32 *height,
+                         int32 *display_width,
+                         int32 *display_height)
+{
+    uint32 codeword;
+    int32   extended_PTYPE = 0;
+    int32 UFEP = 0;
+    int32 custom_PFMT = 0;
+
+    ShowBits(psBits, 22, &codeword);
+
+    if (codeword !=  0x20)
+    {
+        return MP4_INVALID_VOL_PARAM;
+    }
+    FlushBits(psBits, 22);
+    ReadBits(psBits, 8, &codeword);
+
+    ReadBits(psBits, 1, &codeword);
+    if (codeword == 0) return MP4_INVALID_VOL_PARAM;
+
+    ReadBits(psBits, 1, &codeword);
+    if (codeword == 1) return MP4_INVALID_VOL_PARAM;
+
+    ReadBits(psBits, 1, &codeword);
+    if (codeword == 1) return MP4_INVALID_VOL_PARAM;
+
+    ReadBits(psBits, 1, &codeword);
+    if (codeword == 1) return MP4_INVALID_VOL_PARAM;
+
+    ReadBits(psBits, 1, &codeword);
+    if (codeword == 1) return MP4_INVALID_VOL_PARAM;
+
+    /* source format */
+    ReadBits(psBits, 3, &codeword);
+    switch (codeword)
+    {
+        case 1:
+            *width = 128;
+            *height = 96;
+            break;
+
+        case 2:
+            *width = 176;
+            *height = 144;
+            break;
+
+        case 3:
+            *width = 352;
+            *height = 288;
+            break;
+
+        case 4:
+            *width = 704;
+            *height = 576;
+            break;
+
+        case 5:
+            *width = 1408;
+            *height = 1152;
+            break;
+
+        case 7:
+            extended_PTYPE = 1;
+            break;
+        default:
+            /* Msg("H.263 source format not legal\n"); */
+            return MP4_INVALID_VOL_PARAM;
+    }
+
+    if (extended_PTYPE == 0)
+    {
+        *display_width = *width;
+        *display_height = *height;
+        return 0;
+    }
+    /* source format */
+    ReadBits(psBits, 3, &codeword);
+    UFEP = codeword;
+    if (UFEP == 1)
+    {
+        ReadBits(psBits, 3, &codeword);
+        switch (codeword)
+        {
+            case 1:
+                *width = 128;
+                *height = 96;
+                break;
+
+            case 2:
+                *width = 176;
+                *height = 144;
+                break;
+
+            case 3:
+                *width = 352;
+                *height = 288;
+                break;
+
+            case 4:
+                *width = 704;
+                *height = 576;
+                break;
+
+            case 5:
+                *width = 1408;
+                *height = 1152;
+                break;
+
+            case 6:
+                custom_PFMT = 1;
+                break;
+            default:
+                /* Msg("H.263 source format not legal\n"); */
+                return MP4_INVALID_VOL_PARAM;
+        }
+        if (custom_PFMT == 0)
+        {
+            *display_width = *width;
+            *display_height = *height;
+            return 0;
+        }
+        ReadBits(psBits, 1, &codeword);
+        ReadBits(psBits, 1, &codeword);
+        if (codeword) return MP4_INVALID_VOL_PARAM;
+        ReadBits(psBits, 1, &codeword);
+        if (codeword) return MP4_INVALID_VOL_PARAM;
+        ReadBits(psBits, 1, &codeword);
+        if (codeword) return MP4_INVALID_VOL_PARAM;
+        ReadBits(psBits, 3, &codeword);
+        ReadBits(psBits, 3, &codeword);
+        if (codeword) return MP4_INVALID_VOL_PARAM;             /* RPS, ISD, AIV */
+        ReadBits(psBits, 1, &codeword);
+        ReadBits(psBits, 4, &codeword);
+        if (codeword != 8) return MP4_INVALID_VOL_PARAM;
+    }
+    if (UFEP == 0 || UFEP == 1)
+    {
+        ReadBits(psBits, 3, &codeword);
+        if (codeword > 1) return MP4_INVALID_VOL_PARAM;
+        ReadBits(psBits, 1, &codeword);
+        if (codeword) return MP4_INVALID_VOL_PARAM;
+        ReadBits(psBits, 1, &codeword);
+        if (codeword) return MP4_INVALID_VOL_PARAM;
+        ReadBits(psBits, 1, &codeword);
+        ReadBits(psBits, 3, &codeword);
+        if (codeword != 1) return MP4_INVALID_VOL_PARAM;
+    }
+    else
+    {
+        return MP4_INVALID_VOL_PARAM;
+    }
+    ReadBits(psBits, 1, &codeword);
+    if (codeword) return MP4_INVALID_VOL_PARAM; /* CPM */
+    if (custom_PFMT == 1 && UFEP == 1)
+    {
+        ReadBits(psBits, 4, &codeword);
+        if (codeword == 0) return MP4_INVALID_VOL_PARAM;
+        if (codeword == 0xf)
+        {
+            ReadBits(psBits, 8, &codeword);
+            ReadBits(psBits, 8, &codeword);
+        }
+        ReadBits(psBits, 9, &codeword);
+        *display_width = (codeword + 1) << 2;
+        *width = (*display_width + 15) & -16;
+        ReadBits(psBits, 1, &codeword);
+        if (codeword != 1) return MP4_INVALID_VOL_PARAM;
+        ReadBits(psBits, 9, &codeword);
+        if (codeword == 0) return MP4_INVALID_VOL_PARAM;
+        *display_height = codeword << 2;
+        *height = (*display_height + 15) & -16;
+    }
+
+    return 0;
+}
+
+
+int16 ShowBits(
+    mp4StreamType *pStream,           /* Input Stream */
+    uint8 ucNBits,          /* nr of bits to read */
+    uint32 *pulOutData      /* output target */
+)
+{
+    uint8 *bits;
+    uint32 dataBitPos = pStream->dataBitPos;
+    uint32 bitPos = pStream->bitPos;
+    uint32 dataBytePos;
+
+    uint i;
+
+    if (ucNBits > (32 - bitPos))    /* not enough bits */
+    {
+        dataBytePos = dataBitPos >> 3; /* Byte Aligned Position */
+        bitPos = dataBitPos & 7; /* update bit position */
+        if (dataBytePos > pStream->numBytes - 4)
+        {
+            pStream->bitBuf = 0;
+            for (i = 0; i < pStream->numBytes - dataBytePos; i++)
+            {
+                pStream->bitBuf |= pStream->data[dataBytePos+i];
+                pStream->bitBuf <<= 8;
+            }
+            pStream->bitBuf <<= 8 * (3 - i);
+        }
+        else
+        {
+            bits = &pStream->data[dataBytePos];
+            pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
+        }
+        pStream->bitPos = bitPos;
+    }
+
+    bitPos += ucNBits;
+
+    *pulOutData = (pStream->bitBuf >> (32 - bitPos)) & mask[(uint16)ucNBits];
+
+
+    return 0;
+}
+
+int16 FlushBits(
+    mp4StreamType *pStream,           /* Input Stream */
+    uint8 ucNBits                      /* number of bits to flush */
+)
+{
+    uint8 *bits;
+    uint32 dataBitPos = pStream->dataBitPos;
+    uint32 bitPos = pStream->bitPos;
+    uint32 dataBytePos;
+
+
+    if ((dataBitPos + ucNBits) > (uint32)(pStream->numBytes << 3))
+        return (-2); // Buffer over run
+
+    dataBitPos += ucNBits;
+    bitPos     += ucNBits;
+
+    if (bitPos > 32)
+    {
+        dataBytePos = dataBitPos >> 3;    /* Byte Aligned Position */
+        bitPos = dataBitPos & 7; /* update bit position */
+        bits = &pStream->data[dataBytePos];
+        pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
+    }
+
+    pStream->dataBitPos = dataBitPos;
+    pStream->bitPos     = bitPos;
+
+    return 0;
+}
+
+int16 ReadBits(
+    mp4StreamType *pStream,           /* Input Stream */
+    uint8 ucNBits,                     /* nr of bits to read */
+    uint32 *pulOutData                 /* output target */
+)
+{
+    uint8 *bits;
+    uint32 dataBitPos = pStream->dataBitPos;
+    uint32 bitPos = pStream->bitPos;
+    uint32 dataBytePos;
+
+
+    if ((dataBitPos + ucNBits) > (pStream->numBytes << 3))
+    {
+        *pulOutData = 0;
+        return (-2); // Buffer over run
+    }
+
+    //  dataBitPos += ucNBits;
+
+    if (ucNBits > (32 - bitPos))    /* not enough bits */
+    {
+        dataBytePos = dataBitPos >> 3;    /* Byte Aligned Position */
+        bitPos = dataBitPos & 7; /* update bit position */
+        bits = &pStream->data[dataBytePos];
+        pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
+    }
+
+    pStream->dataBitPos += ucNBits;
+    pStream->bitPos      = (unsigned char)(bitPos + ucNBits);
+
+    *pulOutData = (pStream->bitBuf >> (32 - pStream->bitPos)) & mask[(uint16)ucNBits];
+
+    return 0;
+}
+
+
+
+int16 ByteAlign(
+    mp4StreamType *pStream           /* Input Stream */
+)
+{
+    uint8 *bits;
+    uint32 dataBitPos = pStream->dataBitPos;
+    uint32 bitPos = pStream->bitPos;
+    uint32 dataBytePos;
+    uint32 leftBits;
+
+    leftBits =  8 - (dataBitPos & 0x7);
+    if (leftBits == 8)
+    {
+        if ((dataBitPos + 8) > (uint32)(pStream->numBytes << 3))
+            return (-2); // Buffer over run
+        dataBitPos += 8;
+        bitPos += 8;
+    }
+    else
+    {
+        dataBytePos = dataBitPos >> 3;
+        dataBitPos += leftBits;
+        bitPos += leftBits;
+    }
+
+
+    if (bitPos > 32)
+    {
+        dataBytePos = dataBitPos >> 3;    /* Byte Aligned Position */
+        bits = &pStream->data[dataBytePos];
+        pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
+    }
+
+    pStream->dataBitPos = dataBitPos;
+    pStream->bitPos     = bitPos;
+
+    return 0;
+}
+
+int16 DecodeUserData(mp4StreamType *pStream)
+{
+
+    uint32 codeword;
+    int16 iErrorStat;
+
+    iErrorStat = ReadBits(pStream, 32, &codeword);
+    if (iErrorStat) return iErrorStat;
+    iErrorStat = ShowBits(pStream, 24, &codeword);
+    if (iErrorStat) return iErrorStat;
+
+    while (codeword != 1)
+    {
+        /* Discard user data for now. */
+        iErrorStat = ReadBits(pStream, 8, &codeword);
+        if (iErrorStat) return iErrorStat;
+        iErrorStat = ShowBits(pStream, 24, &codeword);
+        if (iErrorStat) return iErrorStat;
+    }
+    return 0;
+}
+
+
+OSCL_EXPORT_REF int16 iGetAVCConfigInfo(uint8 *buffer, int32 length, int32 *width, int32 *height, int32 *display_width, int32 *display_height, int32 *profile_idc, int32 *level_idc)
+{
+    int16 status;
+    mp4StreamType psBits;
+    uint16 sps_length, pps_length;
+    int32 size;
+    int32 i = 0;
+    uint8* sps = NULL;
+    uint8* temp = (uint8 *)OSCL_MALLOC(sizeof(uint8) * length);
+    uint8* pps = NULL;
+
+
+    if (temp)
+    {
+        sps = temp; // Make a copy of the original pointer to be freed later
+        // Successfull allocation... copy input buffer
+        oscl_memcpy(sps, buffer, length);
+    }
+    else
+    {
+        // Allocation failed
+        return MP4_INVALID_VOL_PARAM;
+    }
+
+    if (length < 3)
+    {
+        OSCL_FREE(temp);
+        return MP4_INVALID_VOL_PARAM;
+    }
+
+    *width = *height = *display_height = *display_width = 0;
+
+    if (sps[0] == 0 && sps[1] == 0)
+    {
+        /* find SC at the beginning of the NAL */
+        while (sps[i++] == 0 && i < length)
+        {
+        }
+
+        if (sps[i-1] == 1)
+        {
+            sps += i;
+
+            sps_length = 0;
+            // search for the next start code
+            while (!(sps[sps_length] == 0 && sps[sps_length+1] == 0 && sps[sps_length+2] == 1) &&
+                    sps_length < length - i - 2)
+            {
+                sps_length++;
+            }
+
+            if (sps_length >= length - i - 2)
+            {
+                OSCL_FREE(temp);
+                return MP4_INVALID_VOL_PARAM;
+            }
+
+            pps_length = length - i - sps_length - 3;
+            pps = sps + sps_length + 3;
+        }
+        else
+        {
+            OSCL_FREE(temp);
+            return MP4_INVALID_VOL_PARAM;
+        }
+    }
+    else
+    {
+        sps_length = (uint16)(sps[1] << 8) | sps[0];
+        sps += 2;
+        pps = sps + sps_length;
+        pps_length = (uint16)(pps[1] << 8) | pps[0];
+        pps += 2;
+    }
+
+    if (sps_length + pps_length > length)
+    {
+        OSCL_FREE(temp);
+        return MP4_INVALID_VOL_PARAM;
+    }
+
+    size = sps_length;
+
+    Parser_EBSPtoRBSP(sps, &size);
+
+    psBits.data = sps;
+    psBits.numBytes = size;
+    psBits.bitBuf = 0;
+    psBits.bitPos = 32;
+    psBits.bytePos = 0;
+    psBits.dataBitPos = 0;
+
+    LOGV("intel: --- call to DecodeSPS() begin ---\n");
+    if (DecodeSPS(&psBits, width, height, display_width, display_height, profile_idc, level_idc))
+    {
+        OSCL_FREE(temp);
+        return MP4_INVALID_VOL_PARAM;
+    }
+    LOGV("intel: --- call to DecodeSPS() end ---\n");
+
+    // now do PPS
+    size = pps_length;
+
+    Parser_EBSPtoRBSP(pps, &size);
+    psBits.data = pps;
+    psBits.numBytes = size;
+    psBits.bitBuf = 0;
+    psBits.bitPos = 32;
+    psBits.bytePos = 0;
+    psBits.dataBitPos = 0;
+
+#if 1
+    
+    return 0;
+	
+#else
+
+    LOGV("intel: --- call to DecodePPS() begin ---\n");
+
+    status = DecodePPS(&psBits);
+
+    LOGV("intel: --- call to DecodePPS() end : status = %x ---\n", status);
+
+    OSCL_FREE(temp);
+
+    return status;
+#endif
+}
+
+void scaling_list(mp4StreamType *psBits, uint32 sizeOfScalingList) {
+    uint32 lastScale = 8;
+    uint32 nextScale = 8;
+    int32 delta_scale;
+    uint32 j = 0;
+
+    for (j = 0; j < sizeOfScalingList; j++) {
+        if(nextScale != 0) {
+          /* delta_scale */
+          se_v(psBits, &delta_scale);
+          nextScale = ( lastScale + delta_scale + 256 ) % 256 ;
+        } 
+        lastScale = ( nextScale == 0 ) ? lastScale : nextScale;
+    } 
+}
+
+
+int16 DecodeSPS(mp4StreamType *psBits, int32 *width, int32 *height, int32 *display_width, int32 *display_height, int32 *profile_idc, int32 *level_idc)
+{
+    uint32 temp;
+    int32 temp0;
+    uint left_offset, right_offset, top_offset, bottom_offset;
+    uint i;
+
+    ReadBits(psBits, 8, &temp);
+
+    if ((temp & 0x1F) != 7) {
+          return MP4_INVALID_VOL_PARAM;
+    }
+
+    /* Read profile_idc */
+    ReadBits(psBits, 8, &temp);
+    *profile_idc = temp;
+
+    /* Read Constraint_set0-3_flag */
+    ReadBits(psBits, 1, &temp);
+    ReadBits(psBits, 1, &temp);
+    ReadBits(psBits, 1, &temp);
+    ReadBits(psBits, 1, &temp);
+
+    LOGV("intel: --- profile_idc = %d ---\n", temp);
+
+    /* reserved_zero_4bits */
+    ReadBits(psBits, 4, &temp);
+
+    /* level_idc */ 
+    ReadBits(psBits, 8, &temp);
+    *level_idc = temp;
+
+    if (temp > 51)
+        return MP4_INVALID_VOL_PARAM;
+
+    /* seq_parameter_set_id */
+    ue_v(psBits, &temp);
+    if(*profile_idc == 100 || *profile_idc == 110 || 
+       *profile_idc == 122 || *profile_idc == 144 )
+    {
+    /* chroma_format_idc */ 
+       ue_v(psBits, &temp);
+       if(temp == 3) {
+       /* residual_colour_transform_flag */
+          ReadBits(psBits, 1, &temp);
+       }
+       /* bit_depth_luma_minus8 */
+       ue_v(psBits, &temp);
+  
+       /* bit_depth_chroma_minus8 */
+       ue_v(psBits, &temp);
+   
+       /* qpprime_y_zero_transform_bypass_flag */
+       ReadBits(psBits, 1, &temp);
+
+       /* seq_scaling_matrix_present_flag */
+       ReadBits(psBits, 1, &temp);
+ 
+       if(temp) {
+           int i = 0;
+           for(i = 0; i < 8; i++) {
+               ReadBits(psBits, 1, &temp);
+               if(temp) {
+                  if(i < 6 ) {
+                     scaling_list(psBits, 16);
+                  } else {
+                     scaling_list(psBits, 64);
+                  }
+              } 
+           }
+       }
+    }
+
+    /* log2_max_frame_num_minus4 */
+    ue_v(psBits, &temp);
+
+    /* pic_order_cnt_type */
+    ue_v(psBits, &temp);
+
+    if (temp == 0)
+    {
+        ue_v(psBits, &temp);
+    }
+    else if (temp == 1)
+    {
+        ReadBits(psBits, 1, &temp);
+        se_v(psBits, &temp0);
+        se_v(psBits, &temp0);
+        ue_v(psBits, &temp);
+
+        for (i = 0; i < temp; i++)
+        {
+            se_v(psBits, &temp0);
+        }
+    }
+
+    /* num_ref_frames */
+    ue_v(psBits, &temp);
+
+    /* gaps_in_frame_num_value_allowed_flag */
+    ReadBits(psBits, 1, &temp);
+
+
+    /* pic_width_in_mbs_minus1 */
+    ue_v(psBits, &temp);
+    *display_width = *width = (temp + 1) << 4;
+
+    /* pic_height_in_map_units_minus1 */
+    ue_v(psBits, &temp);
+    *display_height = *height = (temp + 1) << 4;
+
+
+    LOGV("---intel: 1 *display_width = %d *display_height = %d\n", *display_width, *display_height);
+
+    /* frame_mbs_only_flag */
+    ReadBits(psBits, 1, &temp);
+
+    if (!temp)
+    {
+       /* mb_adaptive_frame_field_flag */
+        ReadBits(psBits,1, &temp);
+    }
+
+    /* direct_8x8_inference_flag */
+    ReadBits(psBits, 1, &temp);
+    
+    /* frame_cropping_flag */
+    ReadBits(psBits, 1, &temp);
+
+    if (temp)
+    {
+        ue_v(psBits, (uint32*)&left_offset);
+        ue_v(psBits, (uint32*)&right_offset);
+        ue_v(psBits, (uint32*)&top_offset);
+        ue_v(psBits, (uint32*)&bottom_offset);
+
+        *display_width = *width - 2 * (right_offset + left_offset);
+        *display_height = *height - 2 * (top_offset + bottom_offset);
+
+        LOGV("---intel: 2 *display_width = %d *display_height = %d\n", *display_width, *display_height);
+    }
+
+    /*  no need to check further */
+#if USE_LATER
+    ReadBits(psBits, 1, &temp);
+    if (temp)
+    {
+        if (!DecodeVUI(psBits))
+        {
+            return MP4_INVALID_VOL_PARAM;
+        }
+    }
+#endif
+    return 0; // return 0 for success
+}
+
+#if USE_LATER
+/* unused for now */
+int32 DecodeVUI(mp4StreamType *psBits)
+{
+    uint temp;
+    uint32 temp32;
+    uint aspect_ratio_idc, overscan_appopriate_flag, video_format, video_full_range_flag;
+    int32 status;
+
+    ReadBits(psBits, 1, &temp); /* aspect_ratio_info_present_flag */
+    if (temp)
+    {
+        ReadBits(psBits, 8, &aspect_ratio_idc);
+        if (aspect_ratio_idc == 255)
+        {
+            ReadBits(psBits, 16, &temp); /* sar_width */
+            ReadBits(psBits, 16, &temp); /* sar_height */
+        }
+    }
+    ReadBits(psBits, 1, &temp); /* overscan_info_present */
+    if (temp)
+    {
+        ReadBits(psBits, 1, &overscan_appopriate_flag);
+    }
+    ReadBits(psBits, 1, &temp); /* video_signal_type_present_flag */
+    if (temp)
+    {
+        ReadBits(psBits, 3, &video_format);
+        ReadBits(psBits, 1, &video_full_range_flag);
+        ReadBits(psBits, 1, &temp); /* colour_description_present_flag */
+        if (temp)
+        {
+            ReadBits(psBits, 8, &temp); /* colour_primaries */
+            ReadBits(psBits, 8, &temp); /* transfer_characteristics */
+            ReadBits(psBits, 8, &temp); /* matrix coefficients */
+        }
+    }
+    ReadBits(psBits, 1, &temp);/*   chroma_loc_info_present_flag */
+    if (temp)
+    {
+        ue_v(psBits, &temp); /*  chroma_sample_loc_type_top_field */
+        ue_v(psBits, &temp); /*  chroma_sample_loc_type_bottom_field */
+    }
+
+    ReadBits(psBits, 1, &temp); /*  timing_info_present_flag*/
+    if (temp)
+    {
+        ReadBits(psBits, 32, &temp32); /*  num_unit_in_tick*/
+        ReadBits(psBits, 32, &temp32); /*   time_scale */
+        ReadBits(psBits, 1, &temp); /*  fixed_frame_rate_flag */
+    }
+
+    ReadBits(psBits, 1, &temp); /*  nal_hrd_parameters_present_flag */
+    if (temp)
+    {
+        if (!DecodeHRD(psBits))
+        {
+            return 1;
+        }
+    }
+    ReadBits(psBits, 1, &temp32); /*    vcl_hrd_parameters_present_flag*/
+    if (temp32)
+    {
+        if (!DecodeHRD(psBits))
+        {
+            return 1;
+        }
+    }
+    if (temp || temp32)
+    {
+        ReadBits(psBits, 1, &temp);     /*  low_delay_hrd_flag */
+    }
+    ReadBits(psBits, 1, &temp); /*  pic_struct_present_flag */
+    status = ReadBits(psBits, 1, &temp); /* _restriction_flag */
+    if (status != 0) // buffer overrun
+    {
+        return 1;
+    }
+
+    if (temp)
+    {
+        ReadBits(psBits, 1, &temp); /*  motion_vectors_over_pic_boundaries_flag */
+        ue_v(psBits, &temp); /* max_bytes_per_pic_denom */
+        ue_v(psBits, &temp); /* max_bits_per_mb_denom */
+        ue_v(psBits, &temp); /* log2_max_mv_length_horizontal */
+        ue_v(psBits, &temp); /* log2_max_mv_length_vertical */
+        ue_v(psBits, &temp); /* num_reorder_frames */
+        ue_v(psBits, &temp); /* max_dec_frame_buffering */
+    }
+
+    return 0; // 0 for success
+}
+
+/* unused for now */
+int32 DecodeHRD(mp4StreamType *psBits)
+{
+    uint temp;
+    uint cpb_cnt_minus1;
+    uint i;
+    int32 status;
+
+    ue_v(psBits, &cpb_cnt_minus1);
+    ReadBits(psBits, 4, &temp); /*  bit_rate_scale */
+    ReadBits(psBits, 4, &temp); /*  cpb_size_scale */
+    for (i = 0; i <= cpb_cnt_minus1; i++)
+    {
+        ue_v(psBits, &temp); /* bit_rate_value_minus1[i] */
+        ue_v(psBits, &temp); /* cpb_size_value_minus1[i] */
+        ue_v(psBits, &temp); /* cbr_flag[i] */
+    }
+    ReadBits(psBits, 5, &temp); /*  initial_cpb_removal_delay_length_minus1 */
+    ReadBits(psBits, 5, &temp); /*  cpb_removal_delay_length_minus1 */
+    ReadBits(psBits, 5, &temp); /*  dpb_output_delay_length_minus1 */
+    status = ReadBits(psBits, 5, &temp); /* time_offset_length  */
+
+    if (status != 0) // buffer overrun
+    {
+        return 1;
+    }
+
+    return 0; // 0 for success
+}
+#endif
+
+// only check for entropy coding mode
+int32 DecodePPS(mp4StreamType *psBits)
+{
+    uint32 temp, pic_parameter_set_id, seq_parameter_set_id, entropy_coding_mode_flag;
+
+    ReadBits(psBits, 8, &temp);
+
+    if ((temp & 0x1F) != 8) return MP4_INVALID_VOL_PARAM;
+
+    ue_v(psBits, &pic_parameter_set_id);
+    ue_v(psBits, &seq_parameter_set_id);
+
+    ReadBits(psBits, 1, &entropy_coding_mode_flag);
+    if (entropy_coding_mode_flag)
+    {
+        return 1;
+    }
+
+    return 0;
+}
+
+void ue_v(mp4StreamType *psBits, uint32 *codeNum)
+{
+    uint32 temp;
+    uint tmp_cnt;
+    int32 leading_zeros = 0;
+    ShowBits(psBits, 16, &temp);
+
+    tmp_cnt = temp  | 0x1;
+
+    PV_CLZ(leading_zeros, tmp_cnt)
+
+    if (leading_zeros < 8)
+    {
+        *codeNum = (temp >> (15 - (leading_zeros << 1))) - 1;
+
+	FlushBits(psBits, (leading_zeros << 1) + 1);
+	
+    }
+    else
+    {
+        ReadBits(psBits, (leading_zeros << 1) + 1, &temp);
+        *codeNum = temp - 1;
+
+    }
+
+}
+
+
+void se_v(mp4StreamType *psBits, int32 *value)
+{
+    int32 leadingZeros = 0;
+    uint32 temp;
+
+    OSCL_UNUSED_ARG(value);
+
+    ReadBits(psBits, 1, &temp);
+    while (!temp)
+    {
+        leadingZeros++;
+        if (ReadBits(psBits, 1, &temp))
+        {
+            break;
+        }
+    }
+    ReadBits(psBits, leadingZeros, &temp);
+}
+
+void Parser_EBSPtoRBSP(uint8 *nal_unit, int32 *size)
+{
+    int32 i, j;
+    int32 count = 0;
+
+
+    for (i = 0; i < *size; i++)
+    {
+        if (count == 2 && nal_unit[i] == 0x03)
+        {
+            break;
+        }
+
+        if (nal_unit[i])
+            count = 0;
+        else
+            count++;
+    }
+
+    count = 0;
+    j = i++;
+    for (; i < *size; i++)
+    {
+        if (count == 2 && nal_unit[i] == 0x03)
+        {
+            i++;
+            count = 0;
+        }
+        nal_unit[j] = nal_unit[i];
+        if (nal_unit[i])
+            count = 0;
+        else
+            count++;
+        j++;
+    }
+
+    *size = j;
+}
+
+
+
diff --git a/core/src/intel_m4v_config_parser.h b/core/src/intel_m4v_config_parser.h
new file mode 100644
index 0000000..b428740
--- /dev/null
+++ b/core/src/intel_m4v_config_parser.h
@@ -0,0 +1,105 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+#ifndef PV_M4V_CONFIG_PARSER_H_INCLUDED
+#define PV_M4V_CONFIG_PARSER_H_INCLUDED
+
+#include "oscl_base.h"
+#include "oscl_types.h"
+
+#define USE_LATER 0  // for some code that will be needed in the future
+
+#define MP4_INVALID_VOL_PARAM -1
+#define SHORT_HEADER_MODE -4
+
+
+#define VISUAL_OBJECT_SEQUENCE_START_CODE   0x01B0
+#define VISUAL_OBJECT_SEQUENCE_END_CODE     0x01B1
+#define VISUAL_OBJECT_START_CODE   0x01B5
+#define VO_START_CODE           0x8
+#define VO_HEADER_LENGTH        32
+#define VOL_START_CODE 0x12
+#define VOL_START_CODE_LENGTH 28
+
+#define GROUP_START_CODE    0x01B3
+#define GROUP_START_CODE_LENGTH  32
+
+#define VOP_ID_CODE_LENGTH      5
+#define VOP_TEMP_REF_CODE_LENGTH    16
+
+#define USER_DATA_START_CODE        0x01B2
+#define USER_DATA_START_CODE_LENGTH 32
+
+#define SHORT_VIDEO_START_MARKER        0x20
+#define SHORT_VIDEO_START_MARKER_LENGTH  22
+
+typedef struct
+{
+    uint8 *data;
+    uint32 numBytes;
+    uint32 bytePos;
+    uint32 bitBuf;
+    uint32 dataBitPos;
+    uint32  bitPos;
+} mp4StreamType;
+
+
+int16 ShowBits(
+    mp4StreamType *pStream,
+    uint8 ucNBits,
+    uint32 *pulOutData
+);
+
+int16 FlushBits(
+    mp4StreamType *pStream,
+    uint8 ucNBits
+);
+
+int16 ReadBits(
+    mp4StreamType *pStream,
+    uint8 ucNBits,
+    uint32 *pulOutData
+);
+
+
+
+int16 ByteAlign(
+    mp4StreamType *pStream
+);
+
+
+OSCL_IMPORT_REF int16 iDecodeVOLHeader(mp4StreamType *psBits, int32 *width, int32 *height, int32 *, int32 *, int32 *profilelevel);
+OSCL_IMPORT_REF int16 iGetM4VConfigInfo(uint8 *buffer, int32 length, int32 *width, int32 *height, int32 *, int32 *);
+int16 DecodeUserData(mp4StreamType *pStream);
+OSCL_IMPORT_REF int16 iDecodeShortHeader(mp4StreamType *psBits, int32 *width, int32 *height, int32 *, int32 *);
+OSCL_IMPORT_REF int16 iGetAVCConfigInfo(uint8 *buffer, int32 length, int32 *width, int32 *height, int32 *, int32 *, int32 *profile, int32 *level);
+
+int32 FindNAL(uint8** nal_pnt, uint8* buffer, int32 length);
+int16 DecodeSPS(mp4StreamType *psBits, int32 *width, int32 *height, int32 *display_width, int32 *display_height, int32 *profile_idc, int32 *level_idc);
+#if USE_LATER
+int32 DecodeHRD(mp4StreamType *psBits);
+int32 DecodeVUI(mp4StreamType *psBits);
+#endif
+int32 DecodePPS(mp4StreamType *psBits);
+
+void ue_v(mp4StreamType *psBits, uint32 *codeNum);
+void se_v(mp4StreamType *psBits, int32 *value);
+void Parser_EBSPtoRBSP(uint8 *nal_unit, int32 *size);
+
+#endif //PV_M4V_CONFIG_PARSER_H_INCLUDED
+
+
diff --git a/core/src/intel_omx_config_parser.cpp b/core/src/intel_omx_config_parser.cpp
new file mode 100644
index 0000000..c9c5a06
--- /dev/null
+++ b/core/src/intel_omx_config_parser.cpp
@@ -0,0 +1,164 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "intel_omx_config_parser"
+#include <utils/Log.h>
+
+
+#include "oscl_stdstring.h"
+
+// Use default DLL entry point
+#ifndef OSCL_DLL_H_INCLUDED
+#include "oscl_dll.h"
+#endif
+
+#include "pv_omx_config_parser.h"
+#include "pv_omxcore.h"
+#include "intel_omx_config_parser.h"
+#include "intel_video_config_parser.h"
+
+
+OSCL_EXPORT_REF OMX_BOOL Intel_OMXConfigParser(
+    OMX_PTR aInputParameters,
+    OMX_PTR aOutputParameters)
+
+{
+    OMXConfigParserInputs* pInputs;
+
+    LOGV("--- Intel_OMXConfigParser() ----\n");
+
+    pInputs = (OMXConfigParserInputs*) aInputParameters;
+
+
+    if (NULL != pInputs->cComponentRole)
+    {
+        if (0 == oscl_strncmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder", oscl_strlen("audio_decoder")))
+        {
+            OMX_S32 Status;
+            pvAudioConfigParserInputs aInputs;
+
+            aInputs.inPtr = pInputs->inPtr;
+            aInputs.inBytes = pInputs->inBytes;
+
+            if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.wma"))
+            {
+                aInputs.iMimeType = PVMF_MIME_WMA;
+
+            }
+            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.aac"))
+            {
+                aInputs.iMimeType = PVMF_MIME_AAC_SIZEHDR;
+
+            }
+            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.amr"))
+            {
+                aInputs.iMimeType = PVMF_MIME_AMR;
+
+            }
+            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.amrnb"))
+            {
+                aInputs.iMimeType = PVMF_MIME_AMR;
+
+            }
+            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.amrwb"))
+            {
+                aInputs.iMimeType = PVMF_MIME_AMRWB;
+
+            }
+            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.mp3"))
+            {
+                aInputs.iMimeType = PVMF_MIME_MP3;
+
+            }
+            else
+            {
+                return OMX_FALSE;
+            }
+
+
+            Status = pv_audio_config_parser(&aInputs, (pvAudioConfigParserOutputs *)aOutputParameters);
+            if (0 == Status)
+            {
+                return OMX_FALSE;
+            }
+        }
+        else if (0 == oscl_strncmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder", oscl_strlen("video_decoder")))
+        {
+
+            OMX_S32 Status;
+            pvVideoConfigParserInputs aInputs;
+
+            aInputs.inPtr = pInputs->inPtr;
+            aInputs.inBytes = pInputs->inBytes;
+
+            if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder.wmv"))
+            {
+                aInputs.iMimeType = PVMF_MIME_WMV;
+
+            }
+            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder.avc"))
+            {
+                aInputs.iMimeType = PVMF_MIME_H264_VIDEO;
+
+            }
+            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder.mpeg4"))
+            {
+                aInputs.iMimeType = PVMF_MIME_M4V;
+
+            }
+            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder.h263"))
+            {
+                aInputs.iMimeType = PVMF_MIME_H2632000;
+
+            }
+            else
+            {
+                return OMX_FALSE;
+            }
+
+            if(aInputs.iMimeType == PVMF_MIME_H264_VIDEO || 
+                    aInputs.iMimeType == PVMF_MIME_H2632000 || 
+                    aInputs.iMimeType == PVMF_MIME_H2631998) 
+	    {
+                LOGV("--- intel_video_config_parser() ---\n");
+                Status = intel_video_config_parser(&aInputs, (pvVideoConfigParserOutputs *)aOutputParameters);
+            }
+            else
+            {
+                Status = pv_video_config_parser(&aInputs, (pvVideoConfigParserOutputs *)aOutputParameters);
+            }
+            if (0 != Status)
+            {
+                return OMX_FALSE;
+            }
+        }
+        else
+        {
+            return OMX_FALSE;
+        }
+
+    }
+    else
+    {
+        return OMX_FALSE;
+    }
+
+    return OMX_TRUE;
+}
+
diff --git a/core/src/intel_omx_config_parser.h b/core/src/intel_omx_config_parser.h
new file mode 100644
index 0000000..abd0625
--- /dev/null
+++ b/core/src/intel_omx_config_parser.h
@@ -0,0 +1,35 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+#ifndef INTEL_OMX_CONFIG_PARSER_H_INCLUDED
+#define INTEL_OMX_CONFIG_PARSER_H_INCLUDED
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+    OSCL_IMPORT_REF OMX_BOOL Intel_OMXConfigParser(
+        OMX_PTR aInputParameters,
+        OMX_PTR aOutputParameters);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* INTEL_OMX_CONFIG_PARSER_H_INCLUDED */
+
diff --git a/core/src/intel_video_config_parser.cpp b/core/src/intel_video_config_parser.cpp
new file mode 100644
index 0000000..835a893
--- /dev/null
+++ b/core/src/intel_video_config_parser.cpp
@@ -0,0 +1,288 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+#include "intel_video_config_parser.h"
+#include "intel_m4v_config_parser.h"
+#include "oscl_mem.h"
+
+#include "oscl_dll.h"
+
+#define GetUnalignedWord( pb, w ) \
+            (w) = ((uint16) *(pb + 1) << 8) + *pb;
+
+#define GetUnalignedDword( pb, dw ) \
+            (dw) = ((uint32) *(pb + 3) << 24) + \
+                   ((uint32) *(pb + 2) << 16) + \
+                   ((uint16) *(pb + 1) << 8) + *pb;
+
+#define GetUnalignedWordEx( pb, w )     GetUnalignedWord( pb, w ); (pb) += sizeof(uint16);
+#define GetUnalignedDwordEx( pb, dw )   GetUnalignedDword( pb, dw ); (pb) += sizeof(uint32);
+#define GetUnalignedQwordEx( pb, qw )   GetUnalignedQword( pb, qw ); (pb) += sizeof(uint64);
+
+#define LoadBYTE( b, p )    b = *(uint8 *)p;  p += sizeof( uint8 )
+
+#define LoadWORD( w, p )    GetUnalignedWordEx( p, w )
+#define LoadDWORD( dw, p )  GetUnalignedDwordEx( p, dw )
+#define LoadQWORD( qw, p )  GetUnalignedQwordEx( p, qw )
+
+#ifndef MAKEFOURCC_WMC
+#define MAKEFOURCC_WMC(ch0, ch1, ch2, ch3) \
+        ((uint32)(uint8)(ch0) | ((uint32)(uint8)(ch1) << 8) |   \
+        ((uint32)(uint8)(ch2) << 16) | ((uint32)(uint8)(ch3) << 24 ))
+
+#define mmioFOURCC_WMC(ch0, ch1, ch2, ch3)  MAKEFOURCC_WMC(ch0, ch1, ch2, ch3)
+#endif
+
+#define FOURCC_WMV2     mmioFOURCC_WMC('W','M','V','2')
+#define FOURCC_WMV3     mmioFOURCC_WMC('W','M','V','3')
+#define FOURCC_WMVA     mmioFOURCC_WMC('W','M','V','A')
+#define FOURCC_WVC1     mmioFOURCC_WMC('W','V','C','1')
+//For WMVA
+#define ASFBINDING_SIZE                   1   // size of ASFBINDING is 1 byte
+#define FOURCC_MP42     mmioFOURCC_WMC('M','P','4','2')
+#define FOURCC_MP43     mmioFOURCC_WMC('M','P','4','3')
+#define FOURCC_mp42     mmioFOURCC_WMC('m','p','4','2')
+#define FOURCC_mp43     mmioFOURCC_WMC('m','p','4','3')
+
+
+OSCL_DLL_ENTRY_POINT_DEFAULT()
+
+int32 GetNAL_Config(uint8** bitstream, int32* size);
+
+OSCL_EXPORT_REF int16 intel_video_config_parser(pvVideoConfigParserInputs *aInputs, pvVideoConfigParserOutputs *aOutputs)
+{
+    if (aInputs->iMimeType == PVMF_MIME_M4V) //m4v
+    {
+        mp4StreamType psBits;
+        psBits.data = aInputs->inPtr;
+        if (aInputs->inBytes <= 0)
+        {
+            return -1;
+        }
+        psBits.numBytes = aInputs->inBytes;
+        psBits.bytePos = 0;
+        psBits.bitBuf = 0;
+        psBits.dataBitPos = 0;
+        psBits.bitPos = 32;
+
+        int32 width, height, display_width, display_height = 0;
+        int32 profile_level = 0;
+        int16 retval = 0;
+        retval = iDecodeVOLHeader(&psBits, &width, &height, &display_width, &display_height, &profile_level);
+        if (retval != 0)
+        {
+            return retval;
+        }
+        aOutputs->width  = (uint32)display_width;
+        aOutputs->height = (uint32)display_height;
+        aOutputs->profile = (uint32)profile_level; // for mp4, profile/level info is packed
+        aOutputs->level = 0;
+    }
+    else if (aInputs->iMimeType == PVMF_MIME_H2631998 ||
+             aInputs->iMimeType == PVMF_MIME_H2632000)//h263
+    {
+        // Nothing to do for h263
+        aOutputs->width  = 0;
+        aOutputs->height = 0;
+        aOutputs->profile = 0;
+        aOutputs->level = 0;
+    }
+    else if (aInputs->iMimeType == PVMF_MIME_H264_VIDEO ||
+             aInputs->iMimeType == PVMF_MIME_H264_VIDEO_MP4) //avc
+    {
+        int32 width, height, display_width, display_height = 0;
+        int32 profile_idc, level_idc = 0;
+
+        uint8 *tp = aInputs->inPtr;
+
+        if (aInputs->inBytes > 1)
+        {
+            if (tp[0] == 0 && tp[1] == 0)
+            {
+                // ByteStream Format
+                uint8* tmp_ptr = tp;
+                uint8* buffer_begin = tp;
+                int16 length = 0;
+                int initbufsize = aInputs->inBytes;
+                int tConfigSize = 0;
+                do
+                {
+                    tmp_ptr += length;
+                    length = GetNAL_Config(&tmp_ptr, &initbufsize);
+                    buffer_begin[0] = length & 0xFF;
+                    buffer_begin[1] = (length >> 8) & 0xFF;
+                    oscl_memcpy(buffer_begin + 2, tmp_ptr, length);
+                    buffer_begin += (length + 2);
+                    tConfigSize += (length + 2);
+                }
+                while (initbufsize > 0);
+            }
+        }
+
+        // check codec info and get settings
+        int16 retval;
+        retval = iGetAVCConfigInfo(tp,
+                                   aInputs->inBytes,
+                                   (int*) & width,
+                                   (int*) & height,
+                                   (int*) & display_width,
+                                   (int*) & display_height,
+                                   (int*) & profile_idc,
+                                   (int*) & level_idc);
+        if (retval != 0)
+        {
+            return retval;
+        }
+        aOutputs->width  = (uint32)display_width;
+        aOutputs->height = (uint32)display_height;
+        aOutputs->profile = (uint32)profile_idc;
+        aOutputs->level = (uint32) level_idc;
+    }
+    else if (aInputs->iMimeType == PVMF_MIME_WMV) //wmv
+    {
+        uint32 dwdat;
+        uint16 wdat;
+        uint8 bdat;
+        uint8 *pData = aInputs->inPtr;
+
+        LoadDWORD(dwdat, pData); // Window width
+        LoadDWORD(dwdat, pData); // Window height
+        LoadBYTE(bdat, pData);
+        LoadWORD(wdat, pData);  // Size of image info.
+
+        // BITMAPINFOHEADER
+        LoadDWORD(dwdat, pData); // Size of BMAPINFOHDR
+        LoadDWORD(dwdat, pData);
+        aOutputs->width = dwdat;
+        LoadDWORD(dwdat, pData);
+        aOutputs->height = dwdat;
+
+        /* WMV1 and WMV2 are not supported. Rejected here. */
+        /* Code to Check if comp is WMV1 then return not supported */
+        pData += 4;
+        LoadDWORD(dwdat, pData);
+        uint32 NewCompression = dwdat;
+        uint32 NewSeqHeader = 0;
+        uint32 NewProfile = 0;
+        // in case of WMV store "Compression Type as Level"
+        aOutputs->level = NewCompression;
+
+        if (NewCompression != FOURCC_WMV2 &&
+                NewCompression != FOURCC_WMV3 &&
+                NewCompression != FOURCC_WVC1 &&
+                NewCompression != FOURCC_WMVA &&
+                NewCompression != FOURCC_MP42 &&
+                NewCompression != FOURCC_MP43 &&
+                NewCompression != FOURCC_mp42 &&
+                NewCompression != FOURCC_mp43)
+        {
+            return -1;
+        }
+        // get profile etc.
+        // Check sequence header
+        switch (NewCompression)
+        {
+            case FOURCC_WMV3:
+            {
+                // start fresh
+                pData = aInputs->inPtr;
+                pData += (11 + 40); //sizeof(BITMAPINFOHEADER); // position to sequence header
+
+                LoadDWORD(dwdat, pData);
+                NewSeqHeader = dwdat; // this is little endian read sequence header
+
+                NewProfile = (NewSeqHeader & 0xC0) >> 6; // 0 - simple , 1- main, 3 - complex, 2-forbidden
+
+                break;
+            }
+            case FOURCC_WMVA:
+            {
+                pData = aInputs->inPtr;
+                pData += (11 + 40 + ASFBINDING_SIZE); //sizeof(BITMAPINFOHEADER); // position to sequence header
+
+                LoadDWORD(dwdat, pData); // prefix  // this is little endian read sequence header
+                LoadDWORD(dwdat, pData);
+                NewSeqHeader = dwdat;
+
+                NewProfile = (NewSeqHeader & 0xC0) >> 6; // this must be 3
+            }
+            break;
+
+            default:
+
+                NewProfile = 0;
+                break;
+        }
+
+        aOutputs->profile = NewProfile;
+
+    }
+    else
+    {
+        return -1;
+    }
+    return 0;
+}
+
+
+/* This function finds a nal from the SC's, moves the bitstream pointer to the beginning of the NAL unit, returns the
+    size of the NAL, and at the same time, updates the remaining size in the bitstream buffer that is passed in */
+int32 GetNAL_Config(uint8** bitstream, int32* size)
+{
+    int i = 0;
+    int j;
+    uint8* nal_unit = *bitstream;
+    int count = 0;
+
+    /* find SC at the beginning of the NAL */
+    while (nal_unit[i++] == 0 && i < *size)
+    {
+    }
+
+    if (nal_unit[i-1] == 1)
+    {
+        *bitstream = nal_unit + i;
+    }
+    else
+    {
+        j = *size;
+        *size = 0;
+        return j;  // no SC at the beginning, not supposed to happen
+    }
+
+    j = i;
+
+    /* found the SC at the beginning of the NAL, now find the SC at the beginning of the next NAL */
+    while (i < *size)
+    {
+        if (count == 2 && nal_unit[i] == 0x01)
+        {
+            i -= 2;
+            break;
+        }
+
+        if (nal_unit[i])
+            count = 0;
+        else
+            count++;
+        i++;
+    }
+
+    *size -= i;
+    return (i - j);
+}
diff --git a/core/src/intel_video_config_parser.h b/core/src/intel_video_config_parser.h
new file mode 100644
index 0000000..8042c45
--- /dev/null
+++ b/core/src/intel_video_config_parser.h
@@ -0,0 +1,33 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+#ifndef INTEL_VIDEO_CONFIG_PARSER_H_INCLUDED
+#define INTEL_VIDEO_CONFIG_PARSER_H_INCLUDED
+/*
+#include "oscl_base.h"
+#include "oscl_types.h"
+#include "pvmf_format_type.h"
+#include "oscl_stdstring.h"
+*/
+#include "pv_video_config_parser.h"
+
+OSCL_IMPORT_REF int16 intel_video_config_parser(pvVideoConfigParserInputs *aInputs, pvVideoConfigParserOutputs *aOutputs);
+
+
+#endif //INTEL_VIDEO_CONFIG_PARSER_H_INCLUDED
+
+
diff --git a/core/src/pv_omx_interface.cpp b/core/src/pv_omx_interface.cpp
new file mode 100644
index 0000000..3e1b928
--- /dev/null
+++ b/core/src/pv_omx_interface.cpp
@@ -0,0 +1,90 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+/* Contains changes by Wind River Systems, 2009-2010 */
+
+#include "pvlogger.h"
+
+#include "pv_omxcore.h"
+#include "omx_interface.h"
+#include "intel_omx_config_parser.h"
+
+
+
+class PVOMXInterface : public OMXInterface
+{
+    public:
+        OsclAny* SharedLibraryLookup(const OsclUuid& aInterfaceId)
+        {
+            if (aInterfaceId == OMX_INTERFACE_ID)
+            {
+                // the library lookup was successful
+                return this;
+            }
+            // the ID doesn't match
+            return NULL;
+        };
+
+        static PVOMXInterface* Instance()
+        {
+            return OSCL_NEW(PVOMXInterface, ());
+        };
+
+        bool UnloadWhenNotUsed(void)
+        {
+            // As of 9/22/08, the PV OMX core library can not be
+            // safely unloaded and reloaded when the proxy interface
+            // is enabled.
+            return false;
+        };
+
+    private:
+
+        PVOMXInterface()
+        {
+            // set the pointers to the omx core methods
+            pOMX_Init = OMX_Init;
+            pOMX_Deinit = OMX_Deinit;
+            pOMX_ComponentNameEnum = OMX_ComponentNameEnum;
+            pOMX_GetHandle = OMX_GetHandle;
+            pOMX_FreeHandle = OMX_FreeHandle;
+            pOMX_GetComponentsOfRole = OMX_GetComponentsOfRole;
+            pOMX_GetRolesOfComponent = OMX_GetRolesOfComponent;
+            pOMX_SetupTunnel = OMX_SetupTunnel;
+            pOMX_GetContentPipe = OMX_GetContentPipe;
+            pOMXConfigParser = Intel_OMXConfigParser; 
+        };
+
+};
+
+// function to obtain the interface object from the shared library
+extern "C"
+{
+    OSCL_EXPORT_REF OsclAny* PVGetInterface()
+    {
+        return PVOMXInterface::Instance();
+    }
+    OSCL_EXPORT_REF void PVReleaseInterface(void* interface)
+    {
+        PVOMXInterface* pInterface = (PVOMXInterface*)interface;
+        if (pInterface)
+        {
+            OSCL_DELETE(pInterface);
+        }
+    }
+}
diff --git a/core/src/wrs_omxcore.cpp b/core/src/wrs_omxcore.cpp
new file mode 100644
index 0000000..adcd8ca
--- /dev/null
+++ b/core/src/wrs_omxcore.cpp
@@ -0,0 +1,460 @@
+/*
+ * wrs_core.cpp, Wind River OpenMax-IL Core
+ *
+ * Copyright (c) 2009-2010 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dlfcn.h>
+
+#include <pthread.h>
+
+#include <OMX_Core.h>
+#include <OMX_Component.h>
+
+#include <list.h>
+#include <cmodule.h>
+#include <componentbase.h>
+
+#define NUM_COMPONENTS 2
+typedef struct component_handle {
+
+    char comp_name[OMX_MAX_STRINGNAME_SIZE];
+    void * comp_handle;
+    char parser_name[OMX_MAX_STRINGNAME_SIZE];
+    void * parser_handle;
+
+}ComponentHandle, *ComponentHandlePtr;
+
+static unsigned int g_initialized = 0;
+static unsigned int g_nr_instances = 0;
+static struct list *preload_list=NULL;
+
+static struct list *g_module_list = NULL;
+static pthread_mutex_t g_module_lock = PTHREAD_MUTEX_INITIALIZER;
+
+static char *omx_components[NUM_COMPONENTS][2] = {
+    {"libOMXVideoDecoderAVC.so", "libmixvbp-h264.so"},
+    {NULL,NULL}
+};
+
+extern "C" bool preload_components(void)
+{
+    /* this function is called by openMAX-IL client when libraries are to be
+     * loaded at initial stages.  Security features of the operating system require
+     * to load libraries upfront */
+    ComponentHandlePtr component_handle;
+    int index;
+    bool ret = true;
+
+    for (index=0;omx_components[index][0];index++) {
+        struct list *entry;
+        component_handle = (ComponentHandlePtr) malloc(sizeof(ComponentHandle));
+
+        strncpy(component_handle->comp_name, omx_components[index][0], OMX_MAX_STRINGNAME_SIZE);
+        /* parser is not always needed */
+        if (omx_components[index][1])
+            strncpy(component_handle->parser_name, omx_components[index][1], OMX_MAX_STRINGNAME_SIZE);
+
+        /* skip libraries starting with # */
+        if (component_handle->comp_name[0] == '#')
+            continue;
+
+        component_handle->comp_handle = dlopen(component_handle->comp_name, RTLD_NOW);
+        if (!component_handle->comp_handle) {
+            ret=false;
+            goto delete_comphandle;
+        }
+
+
+        if (component_handle->parser_name) {
+            /* some components don't need a parser */
+            component_handle->parser_handle = dlopen(component_handle->parser_name, RTLD_NOW);
+            if (!component_handle->parser_handle) {
+                ret=false;
+                goto delete_comphandle;
+            }
+        }
+
+        entry = list_alloc(component_handle);
+        if (!entry) {
+            ret=false;
+            goto unload_comphandle;
+        }
+        preload_list = __list_add_tail(preload_list, entry);
+
+	omx_infoLog("open component %s and parser %s", component_handle->comp_name,
+			component_handle->parser_name == NULL ?
+			"No parser provided":component_handle->parser_name );
+	continue;
+
+unload_comphandle:
+        dlclose(component_handle->comp_handle);
+delete_comphandle:
+        free(component_handle);
+    }
+    return ret;
+}
+
+static struct list *construct_components(const char *config_file_name)
+{
+    FILE *config_file;
+    char config_file_path[256];
+    int index=0;
+    struct list *head = NULL, *preload_entry;
+    ComponentHandlePtr component_handle;
+
+    list_foreach(preload_list, preload_entry) {
+        CModule *cmodule;
+        struct list *entry;
+        OMX_ERRORTYPE ret;
+
+        component_handle = (ComponentHandlePtr) preload_entry->data;
+
+        /* skip libraries starting with # */
+        if (component_handle->comp_name[0] == '#')
+            continue;
+
+        cmodule = new CModule(component_handle->comp_name);
+        if (!cmodule)
+            continue;
+
+        omx_verboseLog("found component library %s", component_handle->comp_name);
+
+        ret = cmodule->Load(MODULE_NOW, component_handle->comp_handle);
+        if (ret != OMX_ErrorNone)
+            goto delete_cmodule;
+
+        ret = cmodule->SetParser(component_handle->parser_handle);
+        if (ret != OMX_ErrorNone)
+            goto delete_cmodule;
+
+        ret = cmodule->QueryComponentNameAndRoles();
+        if (ret != OMX_ErrorNone)
+            goto unload_cmodule;
+
+        entry = list_alloc(cmodule);
+        if (!entry)
+            goto unload_cmodule;
+        head = __list_add_tail(head, entry);
+
+        // cmodule->Unload();
+        omx_verboseLog("module %s:%s added to component list",
+             cmodule->GetLibraryName(), cmodule->GetComponentName());
+
+        continue;
+
+    unload_cmodule:
+        cmodule->Unload();
+    delete_cmodule:
+        delete cmodule;
+    }
+
+    return head;
+}
+
+static struct list *destruct_components(struct list *head)
+{
+    struct list *entry, *next;
+    ComponentHandlePtr component_handle;
+
+    list_foreach_safe(head, entry, next) {
+        CModule *cmodule = static_cast<CModule *>(entry->data);
+
+        head = __list_delete(head, entry);
+        delete cmodule;
+    }
+
+    return head;
+}
+
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void)
+{
+    int ret;
+
+    omx_verboseLog("%s(): enter", __FUNCTION__);
+
+    pthread_mutex_lock(&g_module_lock);
+    if (!g_initialized) {
+        g_module_list = construct_components("wrs_omxil_components.list");
+        if (!g_module_list) {
+            pthread_mutex_unlock(&g_module_lock);
+            omx_errorLog("%s(): exit failure, construct_components failed",
+                 __FUNCTION__);
+            return OMX_ErrorInsufficientResources;
+        }
+
+        g_initialized = 1;
+    }
+    pthread_mutex_unlock(&g_module_lock);
+
+    omx_verboseLog("%s(): exit done", __FUNCTION__);
+    return OMX_ErrorNone;
+}
+
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    omx_verboseLog("%s(): enter", __FUNCTION__);
+
+    pthread_mutex_lock(&g_module_lock);
+    if (!g_nr_instances) {
+        g_module_list = destruct_components(g_module_list);
+        g_initialized = 0;
+    } else
+        ret = OMX_ErrorUndefined;
+    pthread_mutex_unlock(&g_module_lock);
+
+    omx_verboseLog("%s(): exit done (ret : 0x%08x)", __FUNCTION__, ret);
+    return ret;
+}
+
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
+    OMX_OUT OMX_STRING cComponentName,
+    OMX_IN OMX_U32 nNameLength,
+    OMX_IN OMX_U32 nIndex)
+{
+    CModule *cmodule;
+    ComponentBase *cbase;
+    struct list *entry;
+    OMX_STRING cname;
+
+    pthread_mutex_lock(&g_module_lock);
+    entry = __list_entry(g_module_list, nIndex);
+    if (!entry) {
+        pthread_mutex_unlock(&g_module_lock);
+        return OMX_ErrorNoMore;
+    }
+    pthread_mutex_unlock(&g_module_lock);
+
+    cmodule = static_cast<CModule *>(entry->data);
+    cname = cmodule->GetComponentName();
+
+    strncpy(cComponentName, cname, nNameLength);
+
+    omx_verboseLog("%s(): found %luth component %s", __FUNCTION__, nIndex, cname);
+    return OMX_ErrorNone;
+}
+
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
+    OMX_OUT OMX_HANDLETYPE* pHandle,
+    OMX_IN OMX_STRING cComponentName,
+    OMX_IN OMX_PTR pAppData,
+    OMX_IN OMX_CALLBACKTYPE *pCallBacks)
+{
+    struct list *entry;
+    OMX_ERRORTYPE ret;
+
+    omx_verboseLog("%s(): enter, try to get %s", __FUNCTION__, cComponentName);
+
+    pthread_mutex_lock(&g_module_lock);
+    list_foreach(g_module_list, entry) {
+        CModule *cmodule;
+        OMX_STRING cname;
+
+        cmodule = static_cast<CModule *>(entry->data);
+
+        cname = cmodule->GetComponentName();
+        if (!strcmp(cComponentName, cname)) {
+            ComponentBase *cbase = NULL;
+
+            ret = cmodule->InstantiateComponent(&cbase);
+            if (ret != OMX_ErrorNone){
+                omx_errorLog("%s(): exit failure, cmodule->Instantiate failed\n",
+                     __FUNCTION__);
+                goto unload_cmodule;
+            }
+
+            ret = cbase->GetHandle(pHandle, pAppData, pCallBacks);
+            if (ret != OMX_ErrorNone) {
+                omx_errorLog("%s(): exit failure, cbase->GetHandle failed\n",
+                     __FUNCTION__);
+                goto delete_cbase;
+            }
+
+            cbase->SetCModule(cmodule);
+
+            g_nr_instances++;
+            pthread_mutex_unlock(&g_module_lock);
+
+            omx_infoLog("get handle of component %s successfully", cComponentName);
+            omx_verboseLog("%s(): exit done\n", __FUNCTION__);
+            return OMX_ErrorNone;
+
+        delete_cbase:
+            delete cbase;
+        unload_cmodule:
+            cmodule->Unload();
+        unlock_list:
+            pthread_mutex_unlock(&g_module_lock);
+
+            omx_errorLog("%s(): exit failure, (ret : 0x%08x)\n", __FUNCTION__, ret);
+            return ret;
+        }
+    }
+    pthread_mutex_unlock(&g_module_lock);
+
+    omx_errorLog("%s(): exit failure, %s not found", __FUNCTION__, cComponentName);
+    return OMX_ErrorInvalidComponent;
+}
+
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
+    OMX_IN OMX_HANDLETYPE hComponent)
+{
+    ComponentBase *cbase;
+    CModule *cmodule;
+    OMX_ERRORTYPE ret;
+    char cname[OMX_MAX_STRINGNAME_SIZE];
+
+    if (!hComponent)
+        return OMX_ErrorBadParameter;
+
+    cbase = static_cast<ComponentBase *>
+        (((OMX_COMPONENTTYPE *)hComponent)->pComponentPrivate);
+    if (!cbase) {
+        omx_errorLog("%s(): exit failure, cannot find cbase pointer\n",
+             __FUNCTION__);
+        return OMX_ErrorBadParameter;
+    }
+    strcpy(&cname[0], cbase->GetName());
+
+    omx_verboseLog("%s(): enter, try to free %s", __FUNCTION__, cbase->GetName());
+
+
+    ret = cbase->FreeHandle(hComponent);
+    if (ret != OMX_ErrorNone) {
+        omx_errorLog("%s(): exit failure, cbase->FreeHandle() failed (ret = 0x%08x)\n",
+             __FUNCTION__, ret);
+        return ret;
+    }
+
+    pthread_mutex_lock(&g_module_lock);
+    g_nr_instances--;
+    pthread_mutex_unlock(&g_module_lock);
+
+    cmodule = cbase->GetCModule();
+    if (!cmodule)
+        omx_errorLog("fatal error, %s does not have cmodule\n", cbase->GetName());
+
+
+    if (cmodule && !preload_list)
+        cmodule->Unload();
+
+    delete cbase;
+
+    omx_infoLog("free handle of component %s successfully", cname);
+    omx_verboseLog("%s(): exit done", __FUNCTION__);
+    return OMX_ErrorNone;
+}
+
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
+    OMX_IN OMX_HANDLETYPE hOutput,
+    OMX_IN OMX_U32 nPortOutput,
+    OMX_IN OMX_HANDLETYPE hInput,
+    OMX_IN OMX_U32 nPortInput)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
+    OMX_OUT OMX_HANDLETYPE *hPipe,
+    OMX_IN OMX_STRING szURI)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole (
+    OMX_IN OMX_STRING role,
+    OMX_INOUT OMX_U32 *pNumComps,
+    OMX_INOUT OMX_U8  **compNames)
+{
+    struct list *entry;
+    OMX_U32 nr_comps = 0, copied_nr_comps = 0;
+
+    pthread_mutex_lock(&g_module_lock);
+    list_foreach(g_module_list, entry) {
+        CModule *cmodule;
+        OMX_STRING cname;
+        bool having_role;
+
+        cmodule = static_cast<CModule *>(entry->data);
+
+        having_role = cmodule->QueryHavingThisRole(role);
+        if (having_role) {
+            if (compNames && compNames[nr_comps]) {
+                cname = cmodule->GetComponentName();
+                strncpy((OMX_STRING)&compNames[nr_comps][0], cname,
+                        OMX_MAX_STRINGNAME_SIZE);
+                copied_nr_comps++;
+                omx_verboseLog("%s(): component %s has %s role", __FUNCTION__,
+                     cname, role);
+            }
+            nr_comps++;
+        }
+    }
+    pthread_mutex_unlock(&g_module_lock);
+
+    if (!copied_nr_comps)
+        *pNumComps = nr_comps;
+    else {
+        if (copied_nr_comps != *pNumComps)
+            return OMX_ErrorBadParameter;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent (
+    OMX_IN OMX_STRING compName,
+    OMX_INOUT OMX_U32 *pNumRoles,
+    OMX_OUT OMX_U8 **roles)
+{
+    struct list *entry;
+
+    pthread_mutex_lock(&g_module_lock);
+    list_foreach(g_module_list, entry) {
+        CModule *cmodule;
+        ComponentBase *cbase;
+        OMX_STRING cname;
+        OMX_ERRORTYPE ret;
+
+        cmodule = static_cast<CModule *>(entry->data);
+
+        cname = cmodule->GetComponentName();
+        if (!strcmp(compName, cname)) {
+            pthread_mutex_unlock(&g_module_lock);
+#if LOG_NDEBUG
+            return cmodule->GetComponentRoles(pNumRoles, roles);
+#else
+            ret = cmodule->GetComponentRoles(pNumRoles, roles);
+            if (ret != OMX_ErrorNone) {
+                OMX_U32 i;
+
+                for (i = 0; i < *pNumRoles; i++) {
+                    omx_verboseLog("%s(): component %s has %s role", __FUNCTION__,
+                         compName, &roles[i][0]);
+                }
+            }
+            return ret;
+#endif
+        }
+    }
+    pthread_mutex_unlock(&g_module_lock);
+
+    return OMX_ErrorInvalidComponent;
+}
diff --git a/ilcore/inc/khronos/openmax/include/OMX_Audio.h b/ilcore/inc/khronos/openmax/include/OMX_Audio.h
deleted file mode 100644
index 9d084e8..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_Audio.h
+++ /dev/null
@@ -1,1311 +0,0 @@
-/*
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** @file OMX_Audio.h - OpenMax IL version 1.1.2
- *  The structures needed by Audio components to exchange
- *  parameters and configuration data with the componenmilts.
- */
-
-#ifndef OMX_Audio_h
-#define OMX_Audio_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/* Each OMX header must include all required header files to allow the
- *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully
- */
-
-#include <OMX_Core.h>
-
-/** @defgroup midi MIDI
- * @ingroup audio
- */
-
-/** @defgroup effects Audio effects
- * @ingroup audio
- */
-
-/** @defgroup audio OpenMAX IL Audio Domain
- * Structures for OpenMAX IL Audio domain
- * @{
- */
-
-/** Enumeration used to define the possible audio codings.
- *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must
- *  be done in a vendor specific way.  Since this is for an audio
- *  processing element this enum is relevant.  However, for another
- *  type of component other enums would be in this area.
- */
-typedef enum OMX_AUDIO_CODINGTYPE {
-    OMX_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
-    OMX_AUDIO_CodingAutoDetect,  /**< auto detection of audio format */
-    OMX_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
-    OMX_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
-    OMX_AUDIO_CodingAMR,         /**< Any variant of AMR encoded data */
-    OMX_AUDIO_CodingGSMFR,       /**< Any variant of GSM fullrate (i.e. GSM610) */
-    OMX_AUDIO_CodingGSMEFR,      /**< Any variant of GSM Enhanced Fullrate encoded data*/
-    OMX_AUDIO_CodingGSMHR,       /**< Any variant of GSM Halfrate encoded data */
-    OMX_AUDIO_CodingPDCFR,       /**< Any variant of PDC Fullrate encoded data */
-    OMX_AUDIO_CodingPDCEFR,      /**< Any variant of PDC Enhanced Fullrate encoded data */
-    OMX_AUDIO_CodingPDCHR,       /**< Any variant of PDC Halfrate encoded data */
-    OMX_AUDIO_CodingTDMAFR,      /**< Any variant of TDMA Fullrate encoded data (TIA/EIA-136-420) */
-    OMX_AUDIO_CodingTDMAEFR,     /**< Any variant of TDMA Enhanced Fullrate encoded data (TIA/EIA-136-410) */
-    OMX_AUDIO_CodingQCELP8,      /**< Any variant of QCELP 8kbps encoded data */
-    OMX_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
-    OMX_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
-    OMX_AUDIO_CodingSMV,         /**< Any variant of SMV encoded data */
-    OMX_AUDIO_CodingG711,        /**< Any variant of G.711 encoded data */
-    OMX_AUDIO_CodingG723,        /**< Any variant of G.723 dot 1 encoded data */
-    OMX_AUDIO_CodingG726,        /**< Any variant of G.726 encoded data */
-    OMX_AUDIO_CodingG729,        /**< Any variant of G.729 encoded data */
-    OMX_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data */
-    OMX_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
-    OMX_AUDIO_CodingSBC,         /**< Any variant of SBC encoded data */
-    OMX_AUDIO_CodingVORBIS,      /**< Any variant of VORBIS encoded data */
-    OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
-    OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
-    OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
-    OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_CodingMax = 0x7FFFFFFF
-} OMX_AUDIO_CODINGTYPE;
-
-
-/** The PortDefinition structure is used to define all of the parameters
- *  necessary for the compliant component to setup an input or an output audio
- *  path.  If additional information is needed to define the parameters of the
- *  port (such as frequency), additional structures must be sent such as the
- *  OMX_AUDIO_PARAM_PCMMODETYPE structure to supply the extra parameters for the port.
- */
-typedef struct OMX_AUDIO_PORTDEFINITIONTYPE {
-    OMX_STRING cMIMEType;            /**< MIME type of data for the port */
-    OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
-                                               for an output device,
-                                               otherwise this field is 0 */
-    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is
-                                          supported by the OMX component */
-    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this
-                                          port (e.g. PCM, AMR, MP3, etc) */
-} OMX_AUDIO_PORTDEFINITIONTYPE;
-
-
-/**  Port format parameter.  This structure is used to enumerate
-  *  the various data input/output format supported by the port.
-  */
-typedef struct OMX_AUDIO_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_U32 nPortIndex;             /**< Indicates which port to set */
-    OMX_U32 nIndex;                 /**< Indicates the enumeration index for the format from 0x0 to N-1 */
-    OMX_AUDIO_CODINGTYPE eEncoding; /**< Type of data expected for this port (e.g. PCM, AMR, MP3, etc) */
-} OMX_AUDIO_PARAM_PORTFORMATTYPE;
-
-
-/** PCM mode type  */
-typedef enum OMX_AUDIO_PCMMODETYPE {
-    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */
-    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */
-    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */
-    OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_PCMModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_PCMModeMax = 0x7FFFFFFF
-} OMX_AUDIO_PCMMODETYPE;
-
-
-typedef enum OMX_AUDIO_CHANNELTYPE {
-    OMX_AUDIO_ChannelNone = 0x0,    /**< Unused or empty */
-    OMX_AUDIO_ChannelLF   = 0x1,    /**< Left front */
-    OMX_AUDIO_ChannelRF   = 0x2,    /**< Right front */
-    OMX_AUDIO_ChannelCF   = 0x3,    /**< Center front */
-    OMX_AUDIO_ChannelLS   = 0x4,    /**< Left surround */
-    OMX_AUDIO_ChannelRS   = 0x5,    /**< Right surround */
-    OMX_AUDIO_ChannelLFE  = 0x6,    /**< Low frequency effects */
-    OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
-    OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
-    OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
-    OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_ChannelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_ChannelMax  = 0x7FFFFFFF
-} OMX_AUDIO_CHANNELTYPE;
-
-#define OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
-#define OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */
-
-/** PCM format description */
-typedef struct OMX_AUDIO_PARAM_PCMMODETYPE {
-    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
-    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
-    OMX_U32 nPortIndex;               /**< port that this structure applies to */
-    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */
-    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */
-    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */
-    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for
-                                           non-interleaved data (e.g. block data) */
-    OMX_U32 nBitPerSample;            /**< Bit per sample */
-    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for
-                                           variable or unknown sampling rate. */
-    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */
-    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */
-
-} OMX_AUDIO_PARAM_PCMMODETYPE;
-
-
-/** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
- * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC.
- */
-typedef enum OMX_AUDIO_CHANNELMODETYPE {
-    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those
-                                          two channels changes accordingly to each channel information */
-    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between
-                                           2 channels for higher compression gain */
-    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half
-                                           the bitrate of the overall bitrate */
-    OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
-    OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_ChannelModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
-} OMX_AUDIO_CHANNELMODETYPE;
-
-
-typedef enum OMX_AUDIO_MP3STREAMFORMATTYPE {
-    OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
-    OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
-    OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
-    OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_MP3StreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_MP3STREAMFORMATTYPE;
-
-/** MP3 params */
-typedef struct OMX_AUDIO_PARAM_MP3TYPE {
-    OMX_U32 nSize;                 /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< port that this structure applies to */
-    OMX_U32 nChannels;             /**< Number of channels */
-    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
-                                        rate or unknown bit rates */
-    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
-                                        variable or unknown sampling rate. */
-    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
-                                        limit the audio signal. Use 0 to let encoder decide */
-    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
-    OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;  /**< MP3 stream format */
-} OMX_AUDIO_PARAM_MP3TYPE;
-
-
-typedef enum OMX_AUDIO_AACSTREAMFORMATTYPE {
-    OMX_AUDIO_AACStreamFormatMP2ADTS = 0, /**< AAC Audio Data Transport Stream 2 format */
-    OMX_AUDIO_AACStreamFormatMP4ADTS,     /**< AAC Audio Data Transport Stream 4 format */
-    OMX_AUDIO_AACStreamFormatMP4LOAS,     /**< AAC Low Overhead Audio Stream format */
-    OMX_AUDIO_AACStreamFormatMP4LATM,     /**< AAC Low overhead Audio Transport Multiplex */
-    OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
-    OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
-    OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
-    OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_AACStreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_AACSTREAMFORMATTYPE;
-
-
-/** AAC mode type.  Note that the term profile is used with the MPEG-2
- * standard and the term object type and profile is used with MPEG-4 */
-typedef enum OMX_AUDIO_AACPROFILETYPE{
-  OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
-  OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
-  OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
-  OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
-  OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
-  OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
-  OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
-  OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
-  OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
-  OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
-  OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-  OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
-} OMX_AUDIO_AACPROFILETYPE;
-
-
-/** AAC tool usage (for nAACtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
- * Required for encoder configuration and optional as decoder info output.
- * For MP3, OMX_AUDIO_CHANNELMODETYPE is sufficient. */
-#define OMX_AUDIO_AACToolNone 0x00000000 /**< no AAC tools allowed (encoder config) or active (decoder info output) */
-#define OMX_AUDIO_AACToolMS   0x00000001 /**< MS: Mid/side joint coding tool allowed or active */
-#define OMX_AUDIO_AACToolIS   0x00000002 /**< IS: Intensity stereo tool allowed or active */
-#define OMX_AUDIO_AACToolTNS  0x00000004 /**< TNS: Temporal Noise Shaping tool allowed or active */
-#define OMX_AUDIO_AACToolPNS  0x00000008 /**< PNS: MPEG-4 Perceptual Noise substitution tool allowed or active */
-#define OMX_AUDIO_AACToolLTP  0x00000010 /**< LTP: MPEG-4 Long Term Prediction tool allowed or active */
-#define OMX_AUDIO_AACToolAll  0x7FFFFFFF /**< all AAC tools allowed or active (*/
-
-/** MPEG-4 AAC error resilience (ER) tool usage (for nAACERtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
- * Required for ER encoder configuration and optional as decoder info output */
-#define OMX_AUDIO_AACERNone  0x00000000  /**< no AAC ER tools allowed/used */
-#define OMX_AUDIO_AACERVCB11 0x00000001  /**< VCB11: Virtual Code Books for AAC section data */
-#define OMX_AUDIO_AACERRVLC  0x00000002  /**< RVLC: Reversible Variable Length Coding */
-#define OMX_AUDIO_AACERHCR   0x00000004  /**< HCR: Huffman Codeword Reordering */
-#define OMX_AUDIO_AACERAll   0x7FFFFFFF  /**< all AAC ER tools allowed/used */
-
-
-/** AAC params */
-typedef struct OMX_AUDIO_PARAM_AACPROFILETYPE {
-    OMX_U32 nSize;                 /**< Size of this structure, in Bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< Port that this structure applies to */
-    OMX_U32 nChannels;             /**< Number of channels */
-    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
-                                        variable or unknown sampling rate. */
-    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
-                                        rate or unknown bit rates */
-    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
-                                        limit the audio signal. Use 0 to let encoder decide */
-    OMX_U32 nFrameLength;          /**< Frame length (in audio samples per channel) of the codec.
-                                        Can be 1024 or 960 (AAC-LC), 2048 (HE-AAC), 480 or 512 (AAC-LD).
-                                        Use 0 to let encoder decide */
-    OMX_U32 nAACtools;             /**< AAC tool usage */
-    OMX_U32 nAACERtools;           /**< MPEG-4 AAC error resilience tool usage */
-    OMX_AUDIO_AACPROFILETYPE eAACProfile;   /**< AAC profile enumeration */
-    OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat; /**< AAC stream format enumeration */
-    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
-} OMX_AUDIO_PARAM_AACPROFILETYPE;
-
-
-/** VORBIS params */
-typedef struct OMX_AUDIO_PARAM_VORBISTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nChannels;        /**< Number of channels */
-    OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
-                                   rate or unknown bit rates. Encoding is set to the
-                                   bitrate closest to specified  value (in bps) */
-    OMX_U32 nMinBitRate;      /**< Sets minimum bitrate (in bps). */
-    OMX_U32 nMaxBitRate;      /**< Sets maximum bitrate (in bps). */
-
-    OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
-                                   variable or unknown sampling rate. */
-    OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
-                                   limit the audio signal. Use 0 to let encoder decide */
-    OMX_S32 nQuality;		  /**< Sets encoding quality to n, between -1 (low) and 10 (high).
-                                   In the default mode of operation, teh quality level is 3.
-                                   Normal quality range is 0 - 10. */
-    OMX_BOOL bManaged;		  /**< Set  bitrate  management  mode. This turns off the
-                                   normal VBR encoding, but allows hard or soft bitrate
-                                   constraints to be enforced by the encoder. This mode can
-                                   be slower, and may also be lower quality. It is
-                                   primarily useful for streaming. */
-    OMX_BOOL bDownmix;		  /**< Downmix input from stereo to mono (has no effect on
-                                   non-stereo streams). Useful for lower-bitrate encoding. */
-} OMX_AUDIO_PARAM_VORBISTYPE;
-
-
-/** WMA Version */
-typedef enum OMX_AUDIO_WMAFORMATTYPE {
-  OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
-  OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
-  OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
-  OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
-  OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-  OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_WMAFORMATTYPE;
-
-
-/** WMA Profile */
-typedef enum OMX_AUDIO_WMAPROFILETYPE {
-  OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
-  OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
-  OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
-  OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
-  OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-  OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
-} OMX_AUDIO_WMAPROFILETYPE;
-
-
-/** WMA params */
-typedef struct OMX_AUDIO_PARAM_WMATYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U16 nChannels;        /**< Number of channels */
-    OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
-                                   rate or unknown bit rates */
-    OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
-	OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
-    OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
-    OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
-    OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
-    OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
-} OMX_AUDIO_PARAM_WMATYPE;
-
-/**
- * RealAudio format
- */
-typedef enum OMX_AUDIO_RAFORMATTYPE {
-    OMX_AUDIO_RAFormatUnused = 0, /**< Format unused or unknown */
-    OMX_AUDIO_RA8,                /**< RealAudio 8 codec */
-    OMX_AUDIO_RA9,                /**< RealAudio 9 codec */
-    OMX_AUDIO_RA10_AAC,           /**< MPEG-4 AAC codec for bitrates of more than 128kbps */
-    OMX_AUDIO_RA10_CODEC,         /**< RealAudio codec for bitrates less than 128 kbps */
-    OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
-    OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
-    OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
-    OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_RAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_RAFORMATTYPE;
-
-/** RA (Real Audio) params */
-typedef struct OMX_AUDIO_PARAM_RATYPE {
-    OMX_U32 nSize;              /**< Size of this structure, in Bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
-    OMX_U32 nChannels;          /**< Number of channels */
-    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */
-    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */
-    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */
-    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */
-    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */
-    OMX_U32 nNumRegions;        /**< is the number of regions value */
-    OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
-} OMX_AUDIO_PARAM_RATYPE;
-
-
-/** SBC Allocation Method Type */
-typedef enum OMX_AUDIO_SBCALLOCMETHODTYPE {
-  OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
-  OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
-  OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-  OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
-} OMX_AUDIO_SBCALLOCMETHODTYPE;
-
-
-/** SBC params */
-typedef struct OMX_AUDIO_PARAM_SBCTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_U32 nChannels;         /**< Number of channels */
-    OMX_U32 nBitRate;          /**< Bit rate of the input data.  Use 0 for variable
-                                    rate or unknown bit rates */
-    OMX_U32 nSampleRate;       /**< Sampling rate of the source data.  Use 0 for
-                                    variable or unknown sampling rate. */
-    OMX_U32 nBlocks;           /**< Number of blocks */
-    OMX_U32 nSubbands;         /**< Number of subbands */
-    OMX_U32 nBitPool;          /**< Bitpool value */
-    OMX_BOOL bEnableBitrate;   /**< Use bitrate value instead of bitpool */
-    OMX_AUDIO_CHANNELMODETYPE eChannelMode; /**< Channel mode enumeration */
-    OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;   /**< SBC Allocation method type */
-} OMX_AUDIO_PARAM_SBCTYPE;
-
-
-/** ADPCM stream format parameters */
-typedef struct OMX_AUDIO_PARAM_ADPCMTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U32 nChannels;          /**< Number of channels in the data stream (not
-                                     necessarily the same as the number of channels
-                                     to be rendered. */
-    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */
-    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for
-                                    variable or unknown sampling rate. */
-} OMX_AUDIO_PARAM_ADPCMTYPE;
-
-
-/** G723 rate */
-typedef enum OMX_AUDIO_G723RATE {
-    OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
-    OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
-    OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
-    OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_G723ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
-} OMX_AUDIO_G723RATE;
-
-
-/** G723 - Sample rate must be 8 KHz */
-typedef struct OMX_AUDIO_PARAM_G723TYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-    OMX_BOOL bPostFilter;         /**< Enable Post Filter */
-} OMX_AUDIO_PARAM_G723TYPE;
-
-
-/** ITU G726 (ADPCM) rate */
-typedef enum OMX_AUDIO_G726MODE {
-    OMX_AUDIO_G726ModeUnused = 0,  /**< G726 Mode unused / unknown */
-    OMX_AUDIO_G726Mode16,          /**< 16 kbps */
-    OMX_AUDIO_G726Mode24,          /**< 24 kbps */
-    OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
-    OMX_AUDIO_G726Mode40,          /**< 40 kbps */
-    OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_G726ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
-} OMX_AUDIO_G726MODE;
-
-
-/** G.726 stream format parameters - must be at 8KHz */
-typedef struct OMX_AUDIO_PARAM_G726TYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U32 nChannels;          /**< Number of channels in the data stream (not
-                                     necessarily the same as the number of channels
-                                     to be rendered. */
-     OMX_AUDIO_G726MODE eG726Mode;
-} OMX_AUDIO_PARAM_G726TYPE;
-
-
-/** G729 coder type */
-typedef enum OMX_AUDIO_G729TYPE {
-    OMX_AUDIO_G729 = 0,           /**< ITU G.729  encoded data */
-    OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
-    OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
-    OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
-    OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_G729VendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_G729Max = 0x7FFFFFFF
-} OMX_AUDIO_G729TYPE;
-
-
-/** G729 stream format parameters - fixed 6KHz sample rate */
-typedef struct OMX_AUDIO_PARAM_G729TYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nChannels;        /**< Number of channels in the data stream (not
-                                   necessarily the same as the number of channels
-                                   to be rendered. */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_AUDIO_G729TYPE eBitType;
-} OMX_AUDIO_PARAM_G729TYPE;
-
-
-/** AMR Frame format */
-typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE {
-    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance
-                                                   (Standard) Format */
-    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface
-                                                   Format 1 */
-    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface
-                                                   Format 2*/
-    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage
-                                                   Format */
-    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time
-                                                   Transport Protocol Payload Format */
-    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */
-    OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_AMRFrameFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_AMRFRAMEFORMATTYPE;
-
-
-/** AMR band mode */
-typedef enum OMX_AUDIO_AMRBANDMODETYPE {
-    OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
-    OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
-    OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
-    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */
-    OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
-    OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
-    OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
-    OMX_AUDIO_AMRBandModeNB6,                 /**< AMRNB Mode 6 = 10200 bps */
-    OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
-    OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
-    OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
-    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */
-    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */
-    OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
-    OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
-    OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
-    OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
-    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */
-    OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_AMRBandModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
-} OMX_AUDIO_AMRBANDMODETYPE;
-
-
-/** AMR Discontinuous Transmission mode */
-typedef enum OMX_AUDIO_AMRDTXMODETYPE {
-    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */
-    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using
-                                             Voice Activity Detector 1 (VAD1) is enabled */
-    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using
-                                             Voice Activity Detector 2 (VAD2) is enabled */
-    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between
-                                             Off, VAD1 or VAD2 modes */
-
-    OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */
-
-    OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_AMRDTXModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF
-} OMX_AUDIO_AMRDTXMODETYPE;
-
-
-/** AMR params */
-typedef struct OMX_AUDIO_PARAM_AMRTYPE {
-    OMX_U32 nSize;                          /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;               /**< OMX specification version information */
-    OMX_U32 nPortIndex;                     /**< port that this structure applies to */
-    OMX_U32 nChannels;                      /**< Number of channels */
-    OMX_U32 nBitRate;                       /**< Bit rate read only field */
-    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */
-    OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
-    OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
-} OMX_AUDIO_PARAM_AMRTYPE;
-
-
-/** GSM_FR (ETSI 06.10, 3GPP 46.010) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_GSMFRTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_GSMFRTYPE;
-
-
-/** GSM-HR (ETSI 06.20, 3GPP 46.020) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_GSMHRTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_GSMHRTYPE;
-
-
-/** GSM-EFR (ETSI 06.60, 3GPP 46.060) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_GSMEFRTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_GSMEFRTYPE;
-
-
-/** TDMA FR (TIA/EIA-136-420, VSELP 7.95kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_TDMAFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_TDMAFRTYPE;
-
-
-/** TDMA EFR (TIA/EIA-136-410, ACELP 7.4kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_TDMAEFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_TDMAEFRTYPE;
-
-
-/** PDC FR ( RCR-27, VSELP 6.7kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_PDCFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_PDCFRTYPE;
-
-
-/** PDC EFR ( RCR-27, ACELP 6.7kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_PDCEFRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_PDCEFRTYPE;
-
-/** PDC HR ( RCR-27, PSI-CELP 3.45kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_PDCHRTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
-} OMX_AUDIO_PARAM_PDCHRTYPE;
-
-
-/** CDMA Rate types */
-typedef enum OMX_AUDIO_CDMARATETYPE {
-    OMX_AUDIO_CDMARateBlank = 0,          /**< CDMA encoded frame is blank */
-    OMX_AUDIO_CDMARateFull,               /**< CDMA encoded frame in full rate */
-    OMX_AUDIO_CDMARateHalf,               /**< CDMA encoded frame in half rate */
-    OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
-    OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
-    OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
-    OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_CDMARateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
-} OMX_AUDIO_CDMARATETYPE;
-
-
-/** QCELP8 (TIA/EIA-96, up to 8kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_QCELP8TYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_U32 nBitRate;             /**< Bit rate of the input data.  Use 0 for variable
-                                       rate or unknown bit rates */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
-} OMX_AUDIO_PARAM_QCELP8TYPE;
-
-
-/** QCELP13 ( CDMA, EIA/TIA-733, 13.3kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_QCELP13TYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
-} OMX_AUDIO_PARAM_QCELP13TYPE;
-
-
-/** EVRC ( CDMA, EIA/TIA-127, RCELP up to 8.55kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_EVRCTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< actual Frame rate */
-    OMX_BOOL bRATE_REDUCon;       /**< RATE_REDUCtion is requested for this frame */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
-    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter */
-    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
-    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter */
-} OMX_AUDIO_PARAM_EVRCTYPE;
-
-
-/** SMV ( up to 8.55kbps coder) stream format parameters */
-typedef struct OMX_AUDIO_PARAM_SMVTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
-                                       necessarily the same as the number of channels
-                                       to be rendered. */
-    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
-    OMX_BOOL bRATE_REDUCon;           /**< RATE_REDUCtion is requested for this frame */
-    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 ??*/
-    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 ??*/
-    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter ??*/
-    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
-    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter ??*/
-} OMX_AUDIO_PARAM_SMVTYPE;
-
-
-/** MIDI Format
- * @ingroup midi
- */
-typedef enum OMX_AUDIO_MIDIFORMATTYPE
-{
-    OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
-    OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
-    OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
-    OMX_AUDIO_MIDIFormatSMF2,        /**< Standard MIDI File Type 2 */
-    OMX_AUDIO_MIDIFormatSPMIDI,      /**< SP-MIDI */
-    OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
-    OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
-    OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
-    OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_MIDIFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
-} OMX_AUDIO_MIDIFORMATTYPE;
-
-
-/** MIDI params
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_PARAM_MIDITYPE {
-    OMX_U32 nSize;                 /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< port that this structure applies to */
-    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire
-                                        MIDI file passed in, otherwise if 0x0, the MIDI data
-                                        is merged and streamed (instead of passed as an
-                                        entire MIDI file) */
-    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic
-                                        voices. A value of zero indicates that the default
-                                        polyphony of the device is used  */
-    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound
-                                        bank at initialization */
-    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */
-} OMX_AUDIO_PARAM_MIDITYPE;
-
-
-/** Type of the MIDI sound bank
- * @ingroup midi
- */
-typedef enum OMX_AUDIO_MIDISOUNDBANKTYPE {
-    OMX_AUDIO_MIDISoundBankUnused = 0,           /**< unused/unknown soundbank type */
-    OMX_AUDIO_MIDISoundBankDLS1,                 /**< DLS version 1 */
-    OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
-    OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
-    OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
-    OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_MIDISoundBankVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
-} OMX_AUDIO_MIDISOUNDBANKTYPE;
-
-
-/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank
- * @ingroup midi
- */
-typedef enum OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
-   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
-   OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
-   OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
-   OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
-   OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-   OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-   OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
-} OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;
-
-
-/** MIDI params to load/unload user soundbank
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nDLSIndex;        /**< DLS file index to be loaded */
-    OMX_U32 nDLSSize;         /**< Size in bytes */
-    OMX_PTR pDLSData;         /**< Pointer to DLS file data */
-    OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;   /**< Midi sound bank type enumeration */
-    OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout; /**< Midi sound bank layout enumeration */
-} OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;
-
-
-/** Structure for Live MIDI events and MIP messages.
- * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.)
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
-    OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
-    OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
-                                   array for the MIP message buffer, where the size is
-                                   indicated by nMidiEventSize */
-} OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;
-
-
-/** MIDI sound bank/ program pair in a given channel
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
-    OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
-    OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
-    OMX_U16 nIDSoundBank;       /**< Sound bank ID */
-    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks
-                                     by index if multiple banks are present */
-} OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;
-
-
-/** MIDI control
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10
-                                       format based on JAVA MMAPI (JSR-135) requirement */
-    OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
-                                       number based on JSR-135 requirement */
-    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10
-                                       fixed-point number based on JSR-135 requirement */
-    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic
-                                       voices. A value of zero indicates that the default
-                                       polyphony of the device is used  */
-    OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
-    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback
-                                       will stop automatically.  Set to zero if not used */
-    OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
-    OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
-    OMX_U32 nTrack0031MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 0-31 */
-    OMX_U32 nTrack3263MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 32-63 */
-    OMX_U32 nTrack0031SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 0-31 */
-    OMX_U32 nTrack3263SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 32-63 */
-
-} OMX_AUDIO_CONFIG_MIDICONTROLTYPE;
-
-
-/** MIDI Playback States
- * @ingroup midi
- */
-typedef enum OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
-  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to
-  													other defined states */
-  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open.
-                                                    The MIDI engine is currently processing
-                                                    MIDI events. */
-  OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being
-                                                    primed. The MIDI engine is currently
-                                                    processing MIDI events. */
-  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but
-                                                    not playing. The MIDI engine is currently
-                                                    processing MIDI events. The transition to
-                                                    this state is only possible from the
-                                                    OMX_AUDIO_MIDIPlayBackStatePlaying state,
-                                                    when the 'playback head' reaches the end
-                                                    of media data or the playback stops due
-                                                    to stop time set.*/
-  OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
-                                                    playing. The MIDI engine is currently
-                                                    processing MIDI events.*/
-  OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
-                                                    resource constraints */
-  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
-                                                    SP-MIDI content constraints, there is
-                                                    no audible MIDI content during playback
-                                                    currently. The situation may change if
-                                                    resources are freed later.*/
-  OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-  OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
-} OMX_AUDIO_MIDIPLAYBACKSTATETYPE;
-
-
-/** MIDI status
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field.
-                                     NOTE: May not return a meaningful value until the entire
-                                     file is parsed and buffered.  */
-    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource
-                                     in milliseconds. NOTE: May not return a meaningful value
-                                     until the entire file is parsed and buffered.  */
-    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played
-                                     in milliseconds */
-    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful
-                                     value until the entire file is parsed and buffered. */
-    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently
-                                     open MIDI resource. NOTE: May not return a meaningful value
-                                     until the entire file is parsed and buffered.  */
-    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing
-                                     MIDI resource. NOTE: May not return a meaningful value until
-                                     the entire file is parsed and buffered. */
-    OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
-} OMX_AUDIO_CONFIG_MIDISTATUSTYPE;
-
-
-/** MIDI Meta Event structure one per Meta Event.
- *  MIDI Meta Events are like audio metadata, except that they are interspersed
- *  with the MIDI content throughout the file and are not localized in the header.
- *  As such, it is necessary to retrieve information about these Meta Events from
- *  the engine, as it encounters these Meta Events within the MIDI content.
- *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright,
- *  author, default tempo, etc.) scattered throughout the file.
- *  @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nIndex;           /**< Index of Meta Event */
-    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */
-    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */
-    OMX_U32 nTrack;           /**< track number for the meta event */
-    OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
-} OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE;
-
-
-/** MIDI Meta Event Data structure - one per Meta Event.
- * @ingroup midi
- */
-typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */
-    OMX_U32 nIndex;           /**< Index of Meta Event */
-    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */
-    OMX_U8 nData[1];          /**< array of one or more bytes of meta data
-                                   as indicated by the nMetaEventSize field */
-} OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE;
-
-
-/** Audio Volume adjustment for a port */
-typedef struct OMX_AUDIO_CONFIG_VOLUMETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to
-                                     set.  Select the input port to set
-                                     just that port's volume.  Select the
-                                     output port to adjust the master
-                                     volume. */
-    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100)
-                                     or logarithmic scale (mB) */
-    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
-                                     Volume logarithmic setting for this port.  The values
-                                     for volume are in mB (millibels = 1/100 dB) relative
-                                     to a gain of 1 (e.g. the output is the same as the
-                                     input level).  Values are in mB from nMax
-                                     (maximum volume) to nMin mB (typically negative).
-                                     Since the volume is "voltage"
-                                     and not a "power", it takes a setting of
-                                     -600 mB to decrease the volume by 1/2.  If
-                                     a component cannot accurately set the
-                                     volume to the requested value, it must
-                                     set the volume to the closest value BELOW
-                                     the requested value.  When getting the
-                                     volume setting, the current actual volume
-                                     must be returned. */
-} OMX_AUDIO_CONFIG_VOLUMETYPE;
-
-
-/** Audio Volume adjustment for a channel */
-typedef struct OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to
-                                     set.  Select the input port to set
-                                     just that port's volume.  Select the
-                                     output port to adjust the master
-                                     volume. */
-    OMX_U32 nChannel;           /**< channel to select from 0 to N-1,
-                                     using OMX_ALL to apply volume settings
-                                     to all channels */
-    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or
-                                     logarithmic scale (mB) */
-    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
-                                     Volume logarithmic setting for this port.
-                                     The values for volume are in mB
-                                     (millibels = 1/100 dB) relative to a gain
-                                     of 1 (e.g. the output is the same as the
-                                     input level).  Values are in mB from nMax
-                                     (maximum volume) to nMin mB (typically negative).
-                                     Since the volume is "voltage"
-                                     and not a "power", it takes a setting of
-                                     -600 mB to decrease the volume by 1/2.  If
-                                     a component cannot accurately set the
-                                     volume to the requested value, it must
-                                     set the volume to the closest value BELOW
-                                     the requested value.  When getting the
-                                     volume setting, the current actual volume
-                                     must be returned. */
-    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
-                                     FALSE otherwise */
-} OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE;
-
-
-/** Audio balance setting */
-typedef struct OMX_AUDIO_CONFIG_BALANCETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to
-                                     set.  Select the input port to set
-                                     just that port's balance.  Select the
-                                     output port to adjust the master
-                                     balance. */
-    OMX_S32 nBalance;           /**< balance setting for this port
-                                     (-100 to 100, where -100 indicates
-                                     all left, and no right */
-} OMX_AUDIO_CONFIG_BALANCETYPE;
-
-
-/** Audio Port mute */
-typedef struct OMX_AUDIO_CONFIG_MUTETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to
-                                     set.  Select the input port to set
-                                     just that port's mute.  Select the
-                                     output port to adjust the master
-                                     mute. */
-    OMX_BOOL bMute;             /**< Mute setting for this port */
-} OMX_AUDIO_CONFIG_MUTETYPE;
-
-
-/** Audio Channel mute */
-typedef struct OMX_AUDIO_CONFIG_CHANNELMUTETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U32 nChannel;           /**< channel to select from 0 to N-1,
-                                     using OMX_ALL to apply mute settings
-                                     to all channels */
-    OMX_BOOL bMute;             /**< Mute setting for this channel */
-    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
-                                     FALSE otherwise */
-} OMX_AUDIO_CONFIG_CHANNELMUTETYPE;
-
-
-
-/** Enable / Disable for loudness control, which boosts bass and to a
- *  smaller extent high end frequencies to compensate for hearing
- *  ability at the extreme ends of the audio spectrum
- */
-typedef struct OMX_AUDIO_CONFIG_LOUDNESSTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bLoudness;        /**< Enable/disable for loudness */
-} OMX_AUDIO_CONFIG_LOUDNESSTYPE;
-
-
-/** Enable / Disable for bass, which controls low frequencies
- */
-typedef struct OMX_AUDIO_CONFIG_BASSTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for bass control */
-    OMX_S32 nBass;             /**< bass setting for the port, as a
-                                    continuous value from -100 to 100
-                                    (0 means no change in bass level)*/
-} OMX_AUDIO_CONFIG_BASSTYPE;
-
-
-/** Enable / Disable for treble, which controls high frequencies tones
- */
-typedef struct OMX_AUDIO_CONFIG_TREBLETYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for treble control */
-    OMX_S32  nTreble;          /**< treble setting for the port, as a
-                                    continuous value from -100 to 100
-                                    (0 means no change in treble level) */
-} OMX_AUDIO_CONFIG_TREBLETYPE;
-
-
-/** An equalizer is typically used for two reasons: to compensate for an
- *  sub-optimal frequency response of a system to make it sound more natural
- *  or to create intentionally some unnatural coloring to the sound to create
- *  an effect.
- *  @ingroup effects
- */
-typedef struct OMX_AUDIO_CONFIG_EQUALIZERTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
-    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is
-                                    N-1, where N is the number of bands, lower limit is 0 */
-    OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
-                                    read only element and is used to determine
-                                    the lower, center and upper frequency of
-                                    this band.  */
-    OMX_BS32 sBandLevel;       /**< band level in millibels */
-} OMX_AUDIO_CONFIG_EQUALIZERTYPE;
-
-
-/** Stereo widening mode type
- * @ingroup effects
- */
-typedef enum OMX_AUDIO_STEREOWIDENINGTYPE {
-    OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
-    OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
-    OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_AUDIO_StereoWideningVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
-} OMX_AUDIO_STEREOWIDENINGTYPE;
-
-
-/** Control for stereo widening, which is a special 2-channel
- *  case of the audio virtualizer effect. For example, for 5.1-channel
- *  output, it translates to virtual surround sound.
- * @ingroup effects
- */
-typedef struct OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for stereo widening control */
-    OMX_AUDIO_STEREOWIDENINGTYPE eWideningType; /**< Stereo widening algorithm type */
-    OMX_U32  nStereoWidening;  /**< stereo widening setting for the port,
-                                    as a continuous value from 0 to 100  */
-} OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE;
-
-
-/** The chorus effect (or ``choralizer'') is any signal processor which makes
- *  one sound source (such as a voice) sound like many such sources singing
- *  (or playing) in unison. Since performance in unison is never exact, chorus
- *  effects simulate this by making independently modified copies of the input
- *  signal. Modifications may include (1) delay, (2) frequency shift, and
- *  (3) amplitude modulation.
- * @ingroup effects
- */
-typedef struct OMX_AUDIO_CONFIG_CHORUSTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bEnable;          /**< Enable/disable for chorus */
-    OMX_BU32 sDelay;           /**< average delay in milliseconds */
-    OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
-    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of
-                                    delay (i.e. 0 to 100) */
-    OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
-} OMX_AUDIO_CONFIG_CHORUSTYPE;
-
-
-/** Reverberation is part of the reflected sound that follows the early
- *  reflections. In a typical room, this consists of a dense succession of
- *  echoes whose energy decays exponentially. The reverberation effect structure
- *  as defined here includes both (early) reflections as well as (late) reverberations.
- * @ingroup effects
- */
-typedef struct OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
-    OMX_U32 nSize;                /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
-    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect
-                                       (i.e. both early reflections and late
-                                       reverberation) in millibels */
-    OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
-                                       relative to the intensity at low
-                                       frequencies in millibels */
-    OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
-                                       (relative to room value), in millibels */
-    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative
-                                       to the direct path, in milliseconds */
-    OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
-                                       relative to room level, in millibels */
-    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection
-                                       to the beginning of the late reverberation
-                                       section, in milliseconds */
-    OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
-                                       frequencies, in milliseconds */
-    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative
-                                       to low frequency decay time in percent  */
-    OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
-                                       in percent (i.e. 0 - 100) */
-    OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
-                                       in percent (i.e. 0 - 100) */
-    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is
-                                       the frequency used as the reference for all
-                                       the high-frequency settings above */
-
-} OMX_AUDIO_CONFIG_REVERBERATIONTYPE;
-
-
-/** Possible settings for the Echo Cancelation structure to use
- * @ingroup effects
- */
-typedef enum OMX_AUDIO_ECHOCANTYPE {
-   OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
-   OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation -
-                                     echo from plastics and face */
-   OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for
-                                     Hands Free operation */
-   OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for
-                                     Car Kit (longer echo) */
-   OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-   OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-   OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
-} OMX_AUDIO_ECHOCANTYPE;
-
-
-/** Enable / Disable for echo cancelation, which removes undesired echo's
- *  from the audio
- * @ingroup effects
- */
-typedef struct OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_AUDIO_ECHOCANTYPE eEchoCancelation; /**< Echo cancelation settings */
-} OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE;
-
-
-/** Enable / Disable for noise reduction, which undesired noise from
- * the audio
- * @ingroup effects
- */
-typedef struct OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_U32 nPortIndex;        /**< port that this structure applies to */
-    OMX_BOOL bNoiseReduction;  /**< Enable/disable for noise reduction */
-} OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE;
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
-
diff --git a/ilcore/inc/khronos/openmax/include/OMX_Component.h b/ilcore/inc/khronos/openmax/include/OMX_Component.h
deleted file mode 100644
index 8526f3a..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_Component.h
+++ /dev/null
@@ -1,579 +0,0 @@
-/*
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_Component.h - OpenMax IL version 1.1.2
- *  The OMX_Component header file contains the definitions used to define
- *  the public interface of a component.  This header file is intended to
- *  be used by both the application and the component.
- */
-
-#ifndef OMX_Component_h
-#define OMX_Component_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-
-/* Each OMX header must include all required header files to allow the
- *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully
- */
-
-#include <OMX_Audio.h>
-#include <OMX_Video.h>
-#include <OMX_Image.h>
-#include <OMX_Other.h>
-
-/** @ingroup comp */
-typedef enum OMX_PORTDOMAINTYPE {
-    OMX_PortDomainAudio,
-    OMX_PortDomainVideo,
-    OMX_PortDomainImage,
-    OMX_PortDomainOther,
-    OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_PortDomainVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_PortDomainMax = 0x7ffffff
-} OMX_PORTDOMAINTYPE;
-
-/** @ingroup comp */
-typedef struct OMX_PARAM_PORTDEFINITIONTYPE {
-    OMX_U32 nSize;                 /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
-    OMX_U32 nPortIndex;            /**< Port number the structure applies to */
-    OMX_DIRTYPE eDir;              /**< Direction (input or output) of this port */
-    OMX_U32 nBufferCountActual;    /**< The actual number of buffers allocated on this port */
-    OMX_U32 nBufferCountMin;       /**< The minimum number of buffers this port requires */
-    OMX_U32 nBufferSize;           /**< Size, in bytes, for buffers to be used for this channel */
-    OMX_BOOL bEnabled;             /**< Ports default to enabled and are enabled/disabled by
-                                        OMX_CommandPortEnable/OMX_CommandPortDisable.
-                                        When disabled a port is unpopulated. A disabled port
-                                        is not populated with buffers on a transition to IDLE. */
-    OMX_BOOL bPopulated;           /**< Port is populated with all of its buffers as indicated by
-                                        nBufferCountActual. A disabled port is always unpopulated.
-                                        An enabled port is populated on a transition to OMX_StateIdle
-                                        and unpopulated on a transition to loaded. */
-    OMX_PORTDOMAINTYPE eDomain;    /**< Domain of the port. Determines the contents of metadata below. */
-    union {
-        OMX_AUDIO_PORTDEFINITIONTYPE audio;
-        OMX_VIDEO_PORTDEFINITIONTYPE video;
-        OMX_IMAGE_PORTDEFINITIONTYPE image;
-        OMX_OTHER_PORTDEFINITIONTYPE other;
-    } format;
-    OMX_BOOL bBuffersContiguous;
-    OMX_U32 nBufferAlignment;
-} OMX_PARAM_PORTDEFINITIONTYPE;
-
-/** @ingroup comp */
-typedef struct OMX_PARAM_U32TYPE {
-    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
-    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
-    OMX_U32 nPortIndex;               /**< port that this structure applies to */
-    OMX_U32 nU32;                     /**< U32 value */
-} OMX_PARAM_U32TYPE;
-
-/** @ingroup rpm */
-typedef enum OMX_SUSPENSIONPOLICYTYPE {
-    OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
-    OMX_SuspensionEnabled,  /**< Suspension allowed */
-    OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_SuspensionPolicyMax = 0x7fffffff
-} OMX_SUSPENSIONPOLICYTYPE;
-
-/** @ingroup rpm */
-typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_SUSPENSIONPOLICYTYPE ePolicy;
-} OMX_PARAM_SUSPENSIONPOLICYTYPE;
-
-/** @ingroup rpm */
-typedef enum OMX_SUSPENSIONTYPE {
-    OMX_NotSuspended, /**< component is not suspended */
-    OMX_Suspended,    /**< component is suspended */
-    OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_SuspendMax = 0x7FFFFFFF
-} OMX_SUSPENSIONTYPE;
-
-/** @ingroup rpm */
-typedef struct OMX_PARAM_SUSPENSIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_SUSPENSIONTYPE eType;
-} OMX_PARAM_SUSPENSIONTYPE ;
-
-typedef struct OMX_CONFIG_BOOLEANTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_BOOL bEnabled;
-} OMX_CONFIG_BOOLEANTYPE;
-
-/* Parameter specifying the content uri to use. */
-/** @ingroup cp */
-typedef struct OMX_PARAM_CONTENTURITYPE
-{
-    OMX_U32 nSize;                      /**< size of the structure in bytes, including
-                                             actual URI name */
-    OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
-    OMX_U8 contentURI[1];               /**< The URI name */
-} OMX_PARAM_CONTENTURITYPE;
-
-/* Parameter specifying the pipe to use. */
-/** @ingroup cp */
-typedef struct OMX_PARAM_CONTENTPIPETYPE
-{
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_HANDLETYPE hPipe;       /**< The pipe handle*/
-} OMX_PARAM_CONTENTPIPETYPE;
-
-/** @ingroup rpm */
-typedef struct OMX_RESOURCECONCEALMENTTYPE {
-    OMX_U32 nSize;             /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment
-                                            methods (like degrading algorithm quality to
-                                            lower resource consumption or functional bypass)
-                                            on a component as a resolution to resource conflicts. */
-} OMX_RESOURCECONCEALMENTTYPE;
-
-
-/** @ingroup metadata */
-typedef enum OMX_METADATACHARSETTYPE {
-    OMX_MetadataCharsetUnknown = 0,
-    OMX_MetadataCharsetASCII,
-    OMX_MetadataCharsetBinary,
-    OMX_MetadataCharsetCodePage1252,
-    OMX_MetadataCharsetUTF8,
-    OMX_MetadataCharsetJavaConformantUTF8,
-    OMX_MetadataCharsetUTF7,
-    OMX_MetadataCharsetImapUTF7,
-    OMX_MetadataCharsetUTF16LE,
-    OMX_MetadataCharsetUTF16BE,
-    OMX_MetadataCharsetGB12345,
-    OMX_MetadataCharsetHZGB2312,
-    OMX_MetadataCharsetGB2312,
-    OMX_MetadataCharsetGB18030,
-    OMX_MetadataCharsetGBK,
-    OMX_MetadataCharsetBig5,
-    OMX_MetadataCharsetISO88591,
-    OMX_MetadataCharsetISO88592,
-    OMX_MetadataCharsetISO88593,
-    OMX_MetadataCharsetISO88594,
-    OMX_MetadataCharsetISO88595,
-    OMX_MetadataCharsetISO88596,
-    OMX_MetadataCharsetISO88597,
-    OMX_MetadataCharsetISO88598,
-    OMX_MetadataCharsetISO88599,
-    OMX_MetadataCharsetISO885910,
-    OMX_MetadataCharsetISO885913,
-    OMX_MetadataCharsetISO885914,
-    OMX_MetadataCharsetISO885915,
-    OMX_MetadataCharsetShiftJIS,
-    OMX_MetadataCharsetISO2022JP,
-    OMX_MetadataCharsetISO2022JP1,
-    OMX_MetadataCharsetISOEUCJP,
-    OMX_MetadataCharsetSMS7Bit,
-    OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_MetadataCharsetVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
-} OMX_METADATACHARSETTYPE;
-
-/** @ingroup metadata */
-typedef enum OMX_METADATASCOPETYPE
-{
-    OMX_MetadataScopeAllLevels,
-    OMX_MetadataScopeTopLevel,
-    OMX_MetadataScopePortLevel,
-    OMX_MetadataScopeNodeLevel,
-    OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_MetadataScopeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_MetadataScopeTypeMax = 0x7fffffff
-} OMX_METADATASCOPETYPE;
-
-/** @ingroup metadata */
-typedef enum OMX_METADATASEARCHMODETYPE
-{
-    OMX_MetadataSearchValueSizeByIndex,
-    OMX_MetadataSearchItemByIndex,
-    OMX_MetadataSearchNextItemByKey,
-    OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_MetadataSearchTypeMax = 0x7fffffff
-} OMX_METADATASEARCHMODETYPE;
-/** @ingroup metadata */
-typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE
-{
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_METADATASCOPETYPE eScopeMode;
-    OMX_U32 nScopeSpecifier;
-    OMX_U32 nMetadataItemCount;
-} OMX_CONFIG_METADATAITEMCOUNTTYPE;
-
-/** @ingroup metadata */
-typedef struct OMX_CONFIG_METADATAITEMTYPE
-{
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_METADATASCOPETYPE eScopeMode;
-    OMX_U32 nScopeSpecifier;
-    OMX_U32 nMetadataItemIndex;
-    OMX_METADATASEARCHMODETYPE eSearchMode;
-    OMX_METADATACHARSETTYPE eKeyCharset;
-    OMX_U8 nKeySizeUsed;
-    OMX_U8 nKey[128];
-    OMX_METADATACHARSETTYPE eValueCharset;
-    OMX_STRING sLanguageCountry;
-    OMX_U32 nValueMaxSize;
-    OMX_U32 nValueSizeUsed;
-    OMX_U8 nValue[1];
-} OMX_CONFIG_METADATAITEMTYPE;
-
-/* @ingroup metadata */
-typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE
-{
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_BOOL bAllKeys;
-    OMX_U32 nParentNodeID;
-    OMX_U32 nNumNodes;
-} OMX_CONFIG_CONTAINERNODECOUNTTYPE;
-
-/** @ingroup metadata */
-typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE
-{
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_BOOL bAllKeys;
-    OMX_U32 nParentNodeID;
-    OMX_U32 nNodeIndex;
-    OMX_U32 nNodeID;
-    OMX_STRING cNodeName;
-    OMX_BOOL bIsLeafType;
-} OMX_CONFIG_CONTAINERNODEIDTYPE;
-
-/** @ingroup metadata */
-typedef struct OMX_PARAM_METADATAFILTERTYPE
-{
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_BOOL bAllKeys;	/* if true then this structure refers to all keys and
-                         * the three key fields below are ignored */
-    OMX_METADATACHARSETTYPE eKeyCharset;
-    OMX_U32 nKeySizeUsed;
-    OMX_U8   nKey [128];
-    OMX_U32 nLanguageCountrySizeUsed;
-    OMX_U8 nLanguageCountry[128];
-    OMX_BOOL bEnabled;	/* if true then key is part of filter (e.g.
-                         * retained for query later). If false then
-                         * key is not part of filter */
-} OMX_PARAM_METADATAFILTERTYPE;
-
-/** The OMX_HANDLETYPE structure defines the component handle.  The component
- *  handle is used to access all of the component's public methods and also
- *  contains pointers to the component's private data area.  The component
- *  handle is initialized by the OMX core (with help from the component)
- *  during the process of loading the component.  After the component is
- *  successfully loaded, the application can safely access any of the
- *  component's public functions (although some may return an error because
- *  the state is inappropriate for the access).
- *
- *  @ingroup comp
- */
-typedef struct OMX_COMPONENTTYPE
-{
-    /** The size of this structure, in bytes.  It is the responsibility
-        of the allocator of this structure to fill in this value.  Since
-        this structure is allocated by the GetHandle function, this
-        function will fill in this value. */
-    OMX_U32 nSize;
-
-    /** nVersion is the version of the OMX specification that the structure
-        is built against.  It is the responsibility of the creator of this
-        structure to initialize this value and every user of this structure
-        should verify that it knows how to use the exact version of
-        this structure found herein. */
-    OMX_VERSIONTYPE nVersion;
-
-    /** pComponentPrivate is a pointer to the component private data area.
-        This member is allocated and initialized by the component when the
-        component is first loaded.  The application should not access this
-        data area. */
-    OMX_PTR pComponentPrivate;
-
-    /** pApplicationPrivate is a pointer that is a parameter to the
-        OMX_GetHandle method, and contains an application private value
-        provided by the IL client.  This application private data is
-        returned to the IL Client by OMX in all callbacks */
-    OMX_PTR pApplicationPrivate;
-
-    /** refer to OMX_GetComponentVersion in OMX_core.h or the OMX IL
-        specification for details on the GetComponentVersion method.
-     */
-    OMX_ERRORTYPE (*GetComponentVersion)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_OUT OMX_STRING pComponentName,
-            OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
-            OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
-            OMX_OUT OMX_UUIDTYPE* pComponentUUID);
-
-    /** refer to OMX_SendCommand in OMX_core.h or the OMX IL
-        specification for details on the SendCommand method.
-     */
-    OMX_ERRORTYPE (*SendCommand)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_COMMANDTYPE Cmd,
-            OMX_IN  OMX_U32 nParam1,
-            OMX_IN  OMX_PTR pCmdData);
-
-    /** refer to OMX_GetParameter in OMX_core.h or the OMX IL
-        specification for details on the GetParameter method.
-     */
-    OMX_ERRORTYPE (*GetParameter)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_INDEXTYPE nParamIndex,
-            OMX_INOUT OMX_PTR pComponentParameterStructure);
-
-
-    /** refer to OMX_SetParameter in OMX_core.h or the OMX IL
-        specification for details on the SetParameter method.
-     */
-    OMX_ERRORTYPE (*SetParameter)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_INDEXTYPE nIndex,
-            OMX_IN  OMX_PTR pComponentParameterStructure);
-
-
-    /** refer to OMX_GetConfig in OMX_core.h or the OMX IL
-        specification for details on the GetConfig method.
-     */
-    OMX_ERRORTYPE (*GetConfig)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_INDEXTYPE nIndex,
-            OMX_INOUT OMX_PTR pComponentConfigStructure);
-
-
-    /** refer to OMX_SetConfig in OMX_core.h or the OMX IL
-        specification for details on the SetConfig method.
-     */
-    OMX_ERRORTYPE (*SetConfig)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_INDEXTYPE nIndex,
-            OMX_IN  OMX_PTR pComponentConfigStructure);
-
-
-    /** refer to OMX_GetExtensionIndex in OMX_core.h or the OMX IL
-        specification for details on the GetExtensionIndex method.
-     */
-    OMX_ERRORTYPE (*GetExtensionIndex)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_STRING cParameterName,
-            OMX_OUT OMX_INDEXTYPE* pIndexType);
-
-
-    /** refer to OMX_GetState in OMX_core.h or the OMX IL
-        specification for details on the GetState method.
-     */
-    OMX_ERRORTYPE (*GetState)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_OUT OMX_STATETYPE* pState);
-
-
-    /** The ComponentTunnelRequest method will interact with another OMX
-        component to determine if tunneling is possible and to setup the
-        tunneling.  The return codes for this method can be used to
-        determine if tunneling is not possible, or if tunneling is not
-        supported.
-
-        Base profile components (i.e. non-interop) do not support this
-        method and should return OMX_ErrorNotImplemented
-
-        The interop profile component MUST support tunneling to another
-        interop profile component with a compatible port parameters.
-        A component may also support proprietary communication.
-
-        If proprietary communication is supported the negotiation of
-        proprietary communication is done outside of OMX in a vendor
-        specific way. It is only required that the proper result be
-        returned and the details of how the setup is done is left
-        to the component implementation.
-
-        When this method is invoked when nPort in an output port, the
-        component will:
-        1.  Populate the pTunnelSetup structure with the output port's
-            requirements and constraints for the tunnel.
-
-        When this method is invoked when nPort in an input port, the
-        component will:
-        1.  Query the necessary parameters from the output port to
-            determine if the ports are compatible for tunneling
-        2.  If the ports are compatible, the component should store
-            the tunnel step provided by the output port
-        3.  Determine which port (either input or output) is the buffer
-            supplier, and call OMX_SetParameter on the output port to
-            indicate this selection.
-
-        The component will return from this call within 5 msec.
-
-        @param [in] hComp
-            Handle of the component to be accessed.  This is the component
-            handle returned by the call to the OMX_GetHandle method.
-        @param [in] nPort
-            nPort is used to select the port on the component to be used
-            for tunneling.
-        @param [in] hTunneledComp
-            Handle of the component to tunnel with.  This is the component
-            handle returned by the call to the OMX_GetHandle method.  When
-            this parameter is 0x0 the component should setup the port for
-            communication with the application / IL Client.
-        @param [in] nPortOutput
-            nPortOutput is used indicate the port the component should
-            tunnel with.
-        @param [in] pTunnelSetup
-            Pointer to the tunnel setup structure.  When nPort is an output port
-            the component should populate the fields of this structure.  When
-            When nPort is an input port the component should review the setup
-            provided by the component with the output port.
-        @return OMX_ERRORTYPE
-            If the command successfully executes, the return code will be
-            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-        @ingroup tun
-    */
-
-    OMX_ERRORTYPE (*ComponentTunnelRequest)(
-        OMX_IN  OMX_HANDLETYPE hComp,
-        OMX_IN  OMX_U32 nPort,
-        OMX_IN  OMX_HANDLETYPE hTunneledComp,
-        OMX_IN  OMX_U32 nTunneledPort,
-        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup);
-
-    /** refer to OMX_UseBuffer in OMX_core.h or the OMX IL
-        specification for details on the UseBuffer method.
-        @ingroup buf
-     */
-    OMX_ERRORTYPE (*UseBuffer)(
-            OMX_IN OMX_HANDLETYPE hComponent,
-            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
-            OMX_IN OMX_U32 nPortIndex,
-            OMX_IN OMX_PTR pAppPrivate,
-            OMX_IN OMX_U32 nSizeBytes,
-            OMX_IN OMX_U8* pBuffer);
-
-    /** refer to OMX_AllocateBuffer in OMX_core.h or the OMX IL
-        specification for details on the AllocateBuffer method.
-        @ingroup buf
-     */
-    OMX_ERRORTYPE (*AllocateBuffer)(
-            OMX_IN OMX_HANDLETYPE hComponent,
-            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
-            OMX_IN OMX_U32 nPortIndex,
-            OMX_IN OMX_PTR pAppPrivate,
-            OMX_IN OMX_U32 nSizeBytes);
-
-    /** refer to OMX_FreeBuffer in OMX_core.h or the OMX IL
-        specification for details on the FreeBuffer method.
-        @ingroup buf
-     */
-    OMX_ERRORTYPE (*FreeBuffer)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_U32 nPortIndex,
-            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
-
-    /** refer to OMX_EmptyThisBuffer in OMX_core.h or the OMX IL
-        specification for details on the EmptyThisBuffer method.
-        @ingroup buf
-     */
-    OMX_ERRORTYPE (*EmptyThisBuffer)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
-
-    /** refer to OMX_FillThisBuffer in OMX_core.h or the OMX IL
-        specification for details on the FillThisBuffer method.
-        @ingroup buf
-     */
-    OMX_ERRORTYPE (*FillThisBuffer)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
-
-    /** The SetCallbacks method is used by the core to specify the callback
-        structure from the application to the component.  This is a blocking
-        call.  The component will return from this call within 5 msec.
-        @param [in] hComponent
-            Handle of the component to be accessed.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param [in] pCallbacks
-            pointer to an OMX_CALLBACKTYPE structure used to provide the
-            callback information to the component
-        @param [in] pAppData
-            pointer to an application defined value.  It is anticipated that
-            the application will pass a pointer to a data structure or a "this
-            pointer" in this area to allow the callback (in the application)
-            to determine the context of the call
-        @return OMX_ERRORTYPE
-            If the command successfully executes, the return code will be
-            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-     */
-    OMX_ERRORTYPE (*SetCallbacks)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_CALLBACKTYPE* pCallbacks,
-            OMX_IN  OMX_PTR pAppData);
-
-    /** ComponentDeInit method is used to deinitialize the component
-        providing a means to free any resources allocated at component
-        initialization.  NOTE:  After this call the component handle is
-        not valid for further use.
-        @param [in] hComponent
-            Handle of the component to be accessed.  This is the component
-            handle returned by the call to the GetHandle function.
-        @return OMX_ERRORTYPE
-            If the command successfully executes, the return code will be
-            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-     */
-    OMX_ERRORTYPE (*ComponentDeInit)(
-            OMX_IN  OMX_HANDLETYPE hComponent);
-
-    /** @ingroup buf */
-    OMX_ERRORTYPE (*UseEGLImage)(
-            OMX_IN OMX_HANDLETYPE hComponent,
-            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
-            OMX_IN OMX_U32 nPortIndex,
-            OMX_IN OMX_PTR pAppPrivate,
-            OMX_IN void* eglImage);
-
-    OMX_ERRORTYPE (*ComponentRoleEnum)(
-        OMX_IN OMX_HANDLETYPE hComponent,
-		OMX_OUT OMX_U8 *cRole,
-		OMX_IN OMX_U32 nIndex);
-
-} OMX_COMPONENTTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
diff --git a/ilcore/inc/khronos/openmax/include/OMX_ContentPipe.h b/ilcore/inc/khronos/openmax/include/OMX_ContentPipe.h
deleted file mode 100644
index 403ea55..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_ContentPipe.h
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_ContentPipe.h - OpenMax IL version 1.1.2
- *  The OMX_ContentPipe header file contains the definitions used to define
- *  the public interface for content piples.  This header file is intended to
- *  be used by the component.
- */
-
-#ifndef OMX_CONTENTPIPE_H
-#define OMX_CONTENTPIPE_H
-
-#ifndef KD_EACCES
-/* OpenKODE error codes. CPResult values may be zero (indicating success
-   or one of the following values) */
-#define KD_EACCES (1)
-#define KD_EADDRINUSE (2)
-#define KD_EAGAIN (5)
-#define KD_EBADF (7)
-#define KD_EBUSY (8)
-#define KD_ECONNREFUSED (9)
-#define KD_ECONNRESET (10)
-#define KD_EDEADLK (11)
-#define KD_EDESTADDRREQ (12)
-#define KD_ERANGE (35)
-#define KD_EEXIST (13)
-#define KD_EFBIG (14)
-#define KD_EHOSTUNREACH (15)
-#define KD_EINVAL (17)
-#define KD_EIO (18)
-#define KD_EISCONN (20)
-#define KD_EISDIR (21)
-#define KD_EMFILE (22)
-#define KD_ENAMETOOLONG (23)
-#define KD_ENOENT (24)
-#define KD_ENOMEM (25)
-#define KD_ENOSPC (26)
-#define KD_ENOSYS (27)
-#define KD_ENOTCONN (28)
-#define KD_EPERM (33)
-#define KD_ETIMEDOUT (36)
-#define KD_EILSEQ (19)
-#endif
-
-/** Map types from OMX standard types only here so interface is as generic as possible. */
-typedef OMX_U32    CPresult;
-typedef char *     CPstring;
-typedef void *     CPhandle;
-typedef OMX_U32    CPuint;
-typedef OMX_S32    CPint;
-typedef char       CPbyte;
-typedef OMX_BOOL   CPbool;
-
-/** enumeration of origin types used in the CP_PIPETYPE's Seek function
- * @ingroup cp
- */
-typedef enum CP_ORIGINTYPE {
-    CP_OriginBegin,
-    CP_OriginCur,
-    CP_OriginEnd,
-    CP_OriginKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    CP_OriginVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    CP_OriginMax = 0X7FFFFFFF
-} CP_ORIGINTYPE;
-
-/** enumeration of contact access types used in the CP_PIPETYPE's Open function
- * @ingroup cp
- */
-typedef enum CP_ACCESSTYPE {
-    CP_AccessRead,
-    CP_AccessWrite,
-    CP_AccessReadWrite ,
-    CP_AccessKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    CP_AccessVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    CP_AccessMax = 0X7FFFFFFF
-} CP_ACCESSTYPE;
-
-/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function
- * @ingroup cp
- */
-typedef enum CP_CHECKBYTESRESULTTYPE
-{
-    CP_CheckBytesOk,                    /**< There are at least the request number
-                                              of bytes available */
-    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes
-                                              and presently lacks sufficient bytes.
-                                              Client will be called when they are
-                                              sufficient bytes are available. */
-    CP_CheckBytesInsufficientBytes  ,     /**< The pipe has retrieved all bytes
-                                              but those available are less than those
-                                              requested */
-    CP_CheckBytesAtEndOfStream,         /**< The pipe has reached the end of stream
-                                              and no more bytes are available. */
-    CP_CheckBytesOutOfBuffers,          /**< All read/write buffers are currently in use. */
-    CP_CheckBytesKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    CP_CheckBytesVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    CP_CheckBytesMax = 0X7FFFFFFF
-} CP_CHECKBYTESRESULTTYPE;
-
-/** enumeration of content pipe events sent to the client callback.
- * @ingroup cp
- */
-typedef enum CP_EVENTTYPE{
-    CP_BytesAvailable,      	    /** bytes requested in a CheckAvailableBytes call are now available*/
-    CP_Overflow,  		           /** enumeration of content pipe events sent to the client callback*/
-    CP_PipeDisconnected  ,  		    /** enumeration of content pipe events sent to the client callback*/
-    CP_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    CP_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    CP_EventMax = 0X7FFFFFFF
-} CP_EVENTTYPE;
-
-/** content pipe definition
- * @ingroup cp
- */
-typedef struct CP_PIPETYPE
-{
-    /** Open a content stream for reading or writing. */
-    CPresult (*Open)( CPhandle* hContent, CPstring szURI, CP_ACCESSTYPE eAccess );
-
-    /** Close a content stream. */
-    CPresult (*Close)( CPhandle hContent );
-
-    /** Create a content source and open it for writing. */
-    CPresult (*Create)( CPhandle *hContent, CPstring szURI );
-
-    /** Check the that specified number of bytes are available for reading or writing (depending on access type).*/
-    CPresult (*CheckAvailableBytes)( CPhandle hContent, CPuint nBytesRequested, CP_CHECKBYTESRESULTTYPE *eResult );
-
-    /** Seek to certain position in the content relative to the specified origin. */
-    CPresult (*SetPosition)( CPhandle  hContent, CPint nOffset, CP_ORIGINTYPE eOrigin);
-
-    /** Retrieve the current position relative to the start of the content. */
-    CPresult (*GetPosition)( CPhandle hContent, CPuint *pPosition);
-
-    /** Retrieve data of the specified size from the content stream (advance content pointer by size of data).
-       Note: pipe client provides pointer. This function is appropriate for small high frequency reads. */
-    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize);
-
-    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes.
-       Buffer contains the next block of bytes, as specified by nSize, of the content. nSize also
-       returns the size of the block actually read. Content pointer advances the by the returned size.
-       Note: pipe provides pointer. This function is appropriate for large reads. The client must call
-       ReleaseReadBuffer when done with buffer.
-
-       In some cases the requested block may not reside in contiguous memory within the
-       pipe implementation. For instance if the pipe leverages a circular buffer then the requested
-       block may straddle the boundary of the circular buffer. By default a pipe implementation
-       performs a copy in this case to provide the block to the pipe client in one contiguous buffer.
-       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory
-       boundary. Here the client may retrieve the data in segments over successive calls. */
-    CPresult (*ReadBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint *nSize, CPbool bForbidCopy);
-
-    /** Release a buffer obtained by ReadBuffer back to the pipe. */
-    CPresult (*ReleaseReadBuffer)(CPhandle hContent, CPbyte *pBuffer);
-
-    /** Write data of the specified size to the content (advance content pointer by size of data).
-       Note: pipe client provides pointer. This function is appropriate for small high frequency writes. */
-    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize);
-
-    /** Retrieve a buffer allocated by the pipe used to write data to the content.
-       Client will fill buffer with output data. Note: pipe provides pointer. This function is appropriate
-       for large writes. The client must call WriteBuffer when done it has filled the buffer with data.*/
-    CPresult (*GetWriteBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint nSize);
-
-    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the
-       the contents of the buffer to content and advance content pointer by the size of the buffer */
-    CPresult (*WriteBuffer)( CPhandle hContent, CPbyte *pBuffer, CPuint nFilledSize);
-
-    /** Register a per-handle client callback with the content pipe. */
-    CPresult (*RegisterCallback)( CPhandle hContent, CPresult (*ClientCallback)(CP_EVENTTYPE eEvent, CPuint iParam));
-
-} CP_PIPETYPE;
-
-#endif
-
diff --git a/ilcore/inc/khronos/openmax/include/OMX_Core.h b/ilcore/inc/khronos/openmax/include/OMX_Core.h
deleted file mode 100644
index 6c858e4..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_Core.h
+++ /dev/null
@@ -1,1431 +0,0 @@
-/*
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_Core.h - OpenMax IL version 1.1.2
- *  The OMX_Core header file contains the definitions used by both the
- *  application and the component to access common items.
- */
-
-#ifndef OMX_Core_h
-#define OMX_Core_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/* Each OMX header shall include all required header files to allow the
- *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully
- */
-
-#include <OMX_Index.h>
-
-
-/** The OMX_COMMANDTYPE enumeration is used to specify the action in the
- *  OMX_SendCommand macro.
- *  @ingroup core
- */
-typedef enum OMX_COMMANDTYPE
-{
-    OMX_CommandStateSet,    /**< Change the component state */
-    OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
-    OMX_CommandPortDisable, /**< Disable a port on a component. */
-    OMX_CommandPortEnable,  /**< Enable a port on a component. */
-    OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
-    OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_CommandMax = 0X7FFFFFFF
-} OMX_COMMANDTYPE;
-
-
-
-/** The OMX_STATETYPE enumeration is used to indicate or change the component
- *  state.  This enumeration reflects the current state of the component when
- *  used with the OMX_GetState macro or becomes the parameter in a state change
- *  command when used with the OMX_SendCommand macro.
- *
- *  The component will be in the Loaded state after the component is initially
- *  loaded into memory.  In the Loaded state, the component is not allowed to
- *  allocate or hold resources other than to build it's internal parameter
- *  and configuration tables.  The application will send one or more
- *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
- *  component and the component will record each of these parameter and
- *  configuration changes for use later.  When the application sends the
- *  Idle command, the component will acquire the resources needed for the
- *  specified configuration and will transition to the idle state if the
- *  allocation is successful.  If the component cannot successfully
- *  transition to the idle state for any reason, the state of the component
- *  shall be fully rolled back to the Loaded state (e.g. all allocated
- *  resources shall be released).  When the component receives the command
- *  to go to the Executing state, it shall begin processing buffers by
- *  sending all input buffers it holds to the application.  While
- *  the component is in the Idle state, the application may also send the
- *  Pause command.  If the component receives the pause command while in the
- *  Idle state, the component shall send all input buffers it holds to the
- *  application, but shall not begin processing buffers.  This will allow the
- *  application to prefill buffers.
- *
- *  @ingroup comp
- */
-
-typedef enum OMX_STATETYPE
-{
-    OMX_StateInvalid,      /**< component has detected that it's internal data
-                                structures are corrupted to the point that
-                                it cannot determine it's state properly */
-    OMX_StateLoaded,      /**< component has been loaded but has not completed
-                                initialization.  The OMX_SetParameter macro
-                                and the OMX_GetParameter macro are the only
-                                valid macros allowed to be sent to the
-                                component in this state. */
-    OMX_StateIdle,        /**< component initialization has been completed
-                                successfully and the component is ready to
-                                to start. */
-    OMX_StateExecuting,   /**< component has accepted the start command and
-                                is processing data (if data is available) */
-    OMX_StatePause,       /**< component has received pause command */
-    OMX_StateWaitForResources, /**< component is waiting for resources, either after
-                                preemption or before it gets the resources requested.
-                                See specification for complete details. */
-    OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_StateMax = 0X7FFFFFFF
-} OMX_STATETYPE;
-
-/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These
- *  errors should cover most of the common failure cases.  However,
- *  vendors are free to add additional error messages of their own as
- *  long as they follow these rules:
- *  1.  Vendor error messages shall be in the range of 0x90000000 to
- *      0x9000FFFF.
- *  2.  Vendor error messages shall be defined in a header file provided
- *      with the component.  No error messages are allowed that are
- *      not defined.
- */
-typedef enum OMX_ERRORTYPE
-{
-  OMX_ErrorNone = 0,
-
-  /** There were insufficient resources to perform the requested operation */
-  OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,
-
-  /** There was an error, but the cause of the error could not be determined */
-  OMX_ErrorUndefined = (OMX_S32) 0x80001001,
-
-  /** The component name string was not valid */
-  OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,
-
-  /** No component with the specified name string was found */
-  OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,
-
-  /** The component specified did not have a "OMX_ComponentInit" or
-      "OMX_ComponentDeInit entry point */
-  OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,
-
-  /** One or more parameters were not valid */
-  OMX_ErrorBadParameter = (OMX_S32) 0x80001005,
-
-  /** The requested function is not implemented */
-  OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,
-
-  /** The buffer was emptied before the next buffer was ready */
-  OMX_ErrorUnderflow = (OMX_S32) 0x80001007,
-
-  /** The buffer was not available when it was needed */
-  OMX_ErrorOverflow = (OMX_S32) 0x80001008,
-
-  /** The hardware failed to respond as expected */
-  OMX_ErrorHardware = (OMX_S32) 0x80001009,
-
-  /** The component is in the state OMX_StateInvalid */
-  OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,
-
-  /** Stream is found to be corrupt */
-  OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,
-
-  /** Ports being connected are not compatible */
-  OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,
-
-  /** Resources allocated to an idle component have been
-      lost resulting in the component returning to the loaded state */
-  OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,
-
-  /** No more indicies can be enumerated */
-  OMX_ErrorNoMore = (OMX_S32) 0x8000100E,
-
-  /** The component detected a version mismatch */
-  OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,
-
-  /** The component is not ready to return data at this time */
-  OMX_ErrorNotReady = (OMX_S32) 0x80001010,
-
-  /** There was a timeout that occurred */
-  OMX_ErrorTimeout = (OMX_S32) 0x80001011,
-
-  /** This error occurs when trying to transition into the state you are already in */
-  OMX_ErrorSameState = (OMX_S32) 0x80001012,
-
-  /** Resources allocated to an executing or paused component have been
-      preempted, causing the component to return to the idle state */
-  OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013,
-
-  /** A non-supplier port sends this error to the IL client (via the EventHandler callback)
-      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
-      on a port restart) when it deems that it has waited an unusually long time for the supplier
-      to send it an allocated buffer via a UseBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,
-
-  /** A non-supplier port sends this error to the IL client (via the EventHandler callback)
-      during the deallocation of buffers (on a transition from the IDLE to LOADED state or
-      on a port stop) when it deems that it has waited an unusually long time for the supplier
-      to request the deallocation of a buffer header via a FreeBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,
-
-  /** A supplier port sends this error to the IL client (via the EventHandler callback)
-      during the stopping of a port (either on a transition from the IDLE to LOADED
-      state or a port stop) when it deems that it has waited an unusually long time for
-      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,
-
-  /** Attempting a state transtion that is not allowed */
-  OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,
-
-  /* Attempting a command that is not allowed during the present state. */
-  OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018,
-
-  /** The values encapsulated in the parameter or config structure are not supported. */
-  OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,
-
-  /** The parameter or config indicated by the given index is not supported. */
-  OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,
-
-  /** The port index supplied is incorrect. */
-  OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,
-
-  /** The port has lost one or more of its buffers and it thus unpopulated. */
-  OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,
-
-  /** Component suspended due to temporary loss of resources */
-  OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,
-
-  /** Component suspended due to an inability to acquire dynamic resources */
-  OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,
-
-  /** When the macroblock error reporting is enabled the component returns new error
-  for every frame that has errors */
-  OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,
-
-  /** A component reports this error when it cannot parse or determine the format of an input stream. */
-  OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020,
-
-  /** The content open operation failed. */
-  OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,
-
-  /** The content creation operation failed. */
-  OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,
-
-  /** Separate table information is being used */
-  OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,
-
-  /** Tunneling is unsupported by the component*/
-  OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,
-
-  OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-  OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_ErrorMax = 0x7FFFFFFF
-} OMX_ERRORTYPE;
-
-/** @ingroup core */
-typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);
-
-/** @ingroup core */
-typedef struct OMX_COMPONENTREGISTERTYPE
-{
-  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
-  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
-} OMX_COMPONENTREGISTERTYPE;
-
-/** @ingroup core */
-extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];
-
-/** @ingroup rpm */
-typedef struct OMX_PRIORITYMGMTTYPE {
- OMX_U32 nSize;             /**< size of the structure in bytes */
- OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
- OMX_U32 nGroupPriority;            /**< Priority of the component group */
- OMX_U32 nGroupID;                  /**< ID of the component group */
-} OMX_PRIORITYMGMTTYPE;
-
-/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
-#define OMX_MAX_STRINGNAME_SIZE 128
-
-/** @ingroup comp */
-typedef struct OMX_PARAM_COMPONENTROLETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
-} OMX_PARAM_COMPONENTROLETYPE;
-
-/** End of Stream Buffer Flag:
-  *
-  * A component sets EOS when it has no more data to emit on a particular
-  * output port. Thus an output port shall set EOS on the last buffer it
-  * emits. A component's determination of when an output port should
-  * cease sending data is implemenation specific.
-  * @ingroup buf
-  */
-
-#define OMX_BUFFERFLAG_EOS 0x00000001
-
-/** Start Time Buffer Flag:
- *
- * The source of a stream (e.g. a demux component) sets the STARTTIME
- * flag on the buffer that contains the starting timestamp for the
- * stream. The starting timestamp corresponds to the first data that
- * should be displayed at startup or after a seek.
- * The first timestamp of the stream is not necessarily the start time.
- * For instance, in the case of a seek to a particular video frame,
- * the target frame may be an interframe. Thus the first buffer of
- * the stream will be the intra-frame preceding the target frame and
- * the starttime will occur with the target frame (with any other
- * required frames required to reconstruct the target intervening).
- *
- * The STARTTIME flag is directly associated with the buffer's
- * timestamp ' thus its association to buffer data and its
- * propagation is identical to the timestamp's.
- *
- * When a Sync Component client receives a buffer with the
- * STARTTIME flag it shall perform a SetConfig on its sync port
- * using OMX_ConfigTimeClientStartTime and passing the buffer's
- * timestamp.
- *
- * @ingroup buf
- */
-
-#define OMX_BUFFERFLAG_STARTTIME 0x00000002
-
-
-
-/** Decode Only Buffer Flag:
- *
- * The source of a stream (e.g. a demux component) sets the DECODEONLY
- * flag on any buffer that should shall be decoded but should not be
- * displayed. This flag is used, for instance, when a source seeks to
- * a target interframe that requires the decode of frames preceding the
- * target to facilitate the target's reconstruction. In this case the
- * source would emit the frames preceding the target downstream
- * but mark them as decode only.
- *
- * The DECODEONLY is associated with buffer data and propagated in a
- * manner identical to the buffer timestamp.
- *
- * A component that renders data should ignore all buffers with
- * the DECODEONLY flag set.
- *
- * @ingroup buf
- */
-
-#define OMX_BUFFERFLAG_DECODEONLY 0x00000004
-
-
-/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt
- * @ingroup buf
- */
-
-#define OMX_BUFFERFLAG_DATACORRUPT 0x00000008
-
-/* End of Frame: The buffer contains exactly one end of frame and no data
- *  occurs after the end of frame. This flag is an optional hint. The absence
- *  of this flag does not imply the absence of an end of frame within the buffer.
- * @ingroup buf
-*/
-#define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
-
-/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame '
- *  a frame that has no dependency on any other frame information
- *  @ingroup buf
- */
-#define OMX_BUFFERFLAG_SYNCFRAME 0x00000020
-
-/* Extra data present flag: there is extra data appended to the data stream
- * residing in the buffer
- * @ingroup buf
- */
-#define OMX_BUFFERFLAG_EXTRADATA 0x00000040
-
-/** Codec Config Buffer Flag:
-* OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
-* output port when all bytes in the buffer form part or all of a set of
-* codec specific configuration data.  Examples include SPS/PPS nal units
-* for OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
-* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets
-* OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
-* with frame data in the same buffer, and shall send all buffers
-* containing codec configuration bytes before any buffers containing
-* frame data that those configurations bytes describe.
-* If the stream format for a particular codec has a frame specific
-* header at the start of each frame, for example OMX_AUDIO_CodingMP3 or
-* OMX_AUDIO_CodingAAC in ADTS mode, then these shall be presented as
-* normal without setting OMX_BUFFERFLAG_CODECCONFIG.
- * @ingroup buf
- */
-#define OMX_BUFFERFLAG_CODECCONFIG 0x00000080
-
-
-
-/** @ingroup buf */
-typedef struct OMX_BUFFERHEADERTYPE
-{
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U8* pBuffer;            /**< Pointer to actual block of memory
-                                     that is acting as the buffer */
-    OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
-    OMX_U32 nFilledLen;         /**< number of bytes currently in the
-                                     buffer */
-    OMX_U32 nOffset;            /**< start offset of valid data in bytes from
-                                     the start of the buffer */
-    OMX_PTR pAppPrivate;        /**< pointer to any data the application
-                                     wants to associate with this buffer */
-    OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
-                                     wants to associate with this buffer */
-    OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
-                                     wants to associate with this buffer */
-    OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
-                                     wants to associate with this buffer */
-    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a
-                                              mark event upon processing this buffer. */
-    OMX_PTR pMarkData;          /**< Application specific data associated with
-                                     the mark sent on a mark event to disambiguate
-                                     this mark from others. */
-    OMX_U32 nTickCount;         /**< Optional entry that the component and
-                                     application can update with a tick count
-                                     when they access the component.  This
-                                     value should be in microseconds.  Since
-                                     this is a value relative to an arbitrary
-                                     starting point, this value cannot be used
-                                     to determine absolute time.  This is an
-                                     optional entry and not all components
-                                     will update it.*/
- OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample
-                                     starting at the first logical sample
-                                     boundary in the buffer. Timestamps of
-                                     successive samples within the buffer may
-                                     be inferred by adding the duration of the
-                                     of the preceding buffer to the timestamp
-                                     of the preceding buffer.*/
-  OMX_U32     nFlags;           /**< buffer specific flags */
-  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using
-                                     this buffer */
-  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
-                                     this buffer */
-} OMX_BUFFERHEADERTYPE;
-
-/** The OMX_EXTRADATATYPE enumeration is used to define the
- * possible extra data payload types.
- * NB: this enum is binary backwards compatible with the previous
- * OMX_EXTRADATA_QUANT define.  This should be replaced with
- * OMX_ExtraDataQuantization.
- */
-typedef enum OMX_EXTRADATATYPE
-{
-   OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */
-   OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
-   OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-   OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-   OMX_ExtraDataMax = 0x7FFFFFFF
-} OMX_EXTRADATATYPE;
-
-
-typedef struct OMX_OTHER_EXTRADATATYPE  {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_EXTRADATATYPE eType;       /* Extra Data type */
-    OMX_U32 nDataSize;   /* Size of the supporting data to follow */
-    OMX_U8  data[1];     /* Supporting data hint  */
-} OMX_OTHER_EXTRADATATYPE;
-
-/** @ingroup comp */
-typedef struct OMX_PORT_PARAM_TYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPorts;             /**< The number of ports for this component */
-    OMX_U32 nStartPortNumber;   /** first port number for this type of port */
-} OMX_PORT_PARAM_TYPE;
-
-/** @ingroup comp */
-typedef enum OMX_EVENTTYPE
-{
-    OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
-    OMX_EventError,               /**< component has detected an error condition */
-    OMX_EventMark,                /**< component has detected a buffer mark */
-    OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
-    OMX_EventBufferFlag,          /**< component has detected an EOS */
-    OMX_EventResourcesAcquired,   /**< component has been granted resources and is
-                                       automatically starting the state change from
-                                       OMX_StateWaitForResources to OMX_StateIdle. */
-   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
-   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
-   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
-   OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-   OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-   OMX_EventMax = 0x7FFFFFFF
-} OMX_EVENTTYPE;
-
-typedef struct OMX_CALLBACKTYPE
-{
-    /** The EventHandler method is used to notify the application when an
-        event of interest occurs.  Events are defined in the OMX_EVENTTYPE
-        enumeration.  Please see that enumeration for details of what will
-        be returned for each type of event. Callbacks should not return
-        an error to the component, so if an error occurs, the application
-        shall handle it internally.  This is a blocking call.
-
-        The application should return from this call within 5 msec to avoid
-        blocking the component for an excessively long period of time.
-
-        @param hComponent
-            handle of the component to access.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param pAppData
-            pointer to an application defined value that was provided in the
-            pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application
-            can have a component specific context when receiving the callback.
-        @param eEvent
-            Event that the component wants to notify the application about.
-        @param nData1
-            nData will be the OMX_ERRORTYPE for an error event and will be
-            an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
-         @param nData2
-            nData2 will hold further information related to the event. Can be OMX_STATETYPE for
-            a OMX_CommandStateSet command or port index for a OMX_PortSettingsChanged event.
-            Default value is 0 if not used. )
-        @param pEventData
-            Pointer to additional event-specific data (see spec for meaning).
-      */
-
-   OMX_ERRORTYPE (*EventHandler)(
-        OMX_IN OMX_HANDLETYPE hComponent,
-        OMX_IN OMX_PTR pAppData,
-        OMX_IN OMX_EVENTTYPE eEvent,
-        OMX_IN OMX_U32 nData1,
-        OMX_IN OMX_U32 nData2,
-        OMX_IN OMX_PTR pEventData);
-
-    /** The EmptyBufferDone method is used to return emptied buffers from an
-        input port back to the application for reuse.  This is a blocking call
-        so the application should not attempt to refill the buffers during this
-        call, but should queue them and refill them in another thread.  There
-        is no error return, so the application shall handle any errors generated
-        internally.
-
-        The application should return from this call within 5 msec.
-
-        @param hComponent
-            handle of the component to access.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param pAppData
-            pointer to an application defined value that was provided in the
-            pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application
-            can have a component specific context when receiving the callback.
-        @param pBuffer
-            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-            or AllocateBuffer indicating the buffer that was emptied.
-        @ingroup buf
-     */
-    OMX_ERRORTYPE (*EmptyBufferDone)(
-        OMX_IN OMX_HANDLETYPE hComponent,
-        OMX_IN OMX_PTR pAppData,
-        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
-
-    /** The FillBufferDone method is used to return filled buffers from an
-        output port back to the application for emptying and then reuse.
-        This is a blocking call so the application should not attempt to
-        empty the buffers during this call, but should queue the buffers
-        and empty them in another thread.  There is no error return, so
-        the application shall handle any errors generated internally.  The
-        application shall also update the buffer header to indicate the
-        number of bytes placed into the buffer.
-
-        The application should return from this call within 5 msec.
-
-        @param hComponent
-            handle of the component to access.  This is the component
-            handle returned by the call to the GetHandle function.
-        @param pAppData
-            pointer to an application defined value that was provided in the
-            pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application
-            can have a component specific context when receiving the callback.
-        @param pBuffer
-            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-            or AllocateBuffer indicating the buffer that was filled.
-        @ingroup buf
-     */
-    OMX_ERRORTYPE (*FillBufferDone)(
-        OMX_OUT OMX_HANDLETYPE hComponent,
-        OMX_OUT OMX_PTR pAppData,
-        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
-
-} OMX_CALLBACKTYPE;
-
-/** The OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
-    preference when tunneling between two ports.
-    @ingroup tun buf
-*/
-typedef enum OMX_BUFFERSUPPLIERTYPE
-{
-    OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
-                                              or don't care */
-    OMX_BufferSupplyInput,             /**< input port supplies the buffers */
-    OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
-    OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_BufferSupplyMax = 0x7FFFFFFF
-} OMX_BUFFERSUPPLIERTYPE;
-
-
-/** buffer supplier parameter
- * @ingroup tun
- */
-typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
-    OMX_U32 nSize; /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex; /**< port that this structure applies to */
-    OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
-} OMX_PARAM_BUFFERSUPPLIERTYPE;
-
-
-/**< indicates that buffers received by an input port of a tunnel
-     may not modify the data in the buffers
-     @ingroup tun
- */
-#define OMX_PORTTUNNELFLAG_READONLY 0x00000001
-
-
-/** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
-    port to an input port as part the two ComponentTunnelRequest calls
-    resulting from a OMX_SetupTunnel call from the IL Client.
-    @ingroup tun
- */
-typedef struct OMX_TUNNELSETUPTYPE
-{
-    OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
-    OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
-} OMX_TUNNELSETUPTYPE;
-
-/* OMX Component headers is included to enable the core to use
-   macros for functions into the component for OMX release 1.0.
-   Developers should not access any structures or data from within
-   the component header directly */
-/* TO BE REMOVED - #include <OMX_Component.h> */
-
-/** GetComponentVersion will return information about the component.
-    This is a blocking call.  This macro will go directly from the
-    application to the component (via a core macro).  The
-    component will return from this call within 5 msec.
-    @param [in] hComponent
-        handle of component to execute the command
-    @param [out] pComponentName
-        pointer to an empty string of length 128 bytes.  The component
-        will write its name into this string.  The name will be
-        terminated by a single zero byte.  The name of a component will
-        be 127 bytes or less to leave room for the trailing zero byte.
-        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
-    @param [out] pComponentVersion
-        pointer to an OMX Version structure that the component will fill
-        in.  The component will fill in a value that indicates the
-        component version.  NOTE: the component version is NOT the same
-        as the OMX Specification version (found in all structures).  The
-        component version is defined by the vendor of the component and
-        its value is entirely up to the component vendor.
-    @param [out] pSpecVersion
-        pointer to an OMX Version structure that the component will fill
-        in.  The SpecVersion is the version of the specification that the
-        component was built against.  Please note that this value may or
-        may not match the structure's version.  For example, if the
-        component was built against the 2.0 specification, but the
-        application (which creates the structure is built against the
-        1.0 specification the versions would be different.
-    @param [out] pComponentUUID
-        pointer to the UUID of the component which will be filled in by
-        the component.  The UUID is a unique identifier that is set at
-        RUN time for the component and is unique to each instantion of
-        the component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_GetComponentVersion(                            \
-        hComponent,                                         \
-        pComponentName,                                     \
-        pComponentVersion,                                  \
-        pSpecVersion,                                       \
-        pComponentUUID)                                     \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetComponentVersion(  \
-        hComponent,                                         \
-        pComponentName,                                     \
-        pComponentVersion,                                  \
-        pSpecVersion,                                       \
-        pComponentUUID)                 /* Macro End */
-
-
-/** Send a command to the component.  This call is a non-blocking call.
-    The component should check the parameters and then queue the command
-    to the component thread to be executed.  The component thread shall
-    send the EventHandler() callback at the conclusion of the command.
-    This macro will go directly from the application to the component (via
-    a core macro).  The component will return from this call within 5 msec.
-
-    When the command is "OMX_CommandStateSet" the component will queue a
-    state transition to the new state idenfied in nParam.
-
-    When the command is "OMX_CommandFlush", to flush a port's buffer queues,
-    the command will force the component to return all buffers NOT CURRENTLY
-    BEING PROCESSED to the application, in the order in which the buffers
-    were received.
-
-    When the command is "OMX_CommandPortDisable" or
-    "OMX_CommandPortEnable", the component's port (given by the value of
-    nParam) will be stopped or restarted.
-
-    When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
-    pCmdData will point to a OMX_MARKTYPE structure containing the component
-    handle of the component to examine the buffer chain for the mark.  nParam1
-    contains the index of the port on which the buffer mark is applied.
-
-    Specification text for more details.
-
-    @param [in] hComponent
-        handle of component to execute the command
-    @param [in] Cmd
-        Command for the component to execute
-    @param [in] nParam
-        Parameter for the command to be executed.  When Cmd has the value
-        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has
-        the value OMX_CommandFlush, value of nParam indicates which port(s)
-        to flush. -1 is used to flush all ports a single port index will
-        only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
-        or "OMX_CommandPortEnable", the component's port is given by
-        the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
-        the components pot is given by the value of nParam.
-    @param [in] pCmdData
-        Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
-        "OMX_CommandMarkBuffer".
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_SendCommand(                                    \
-         hComponent,                                        \
-         Cmd,                                               \
-         nParam,                                            \
-         pCmdData)                                          \
-     ((OMX_COMPONENTTYPE*)hComponent)->SendCommand(         \
-         hComponent,                                        \
-         Cmd,                                               \
-         nParam,                                            \
-         pCmdData)                          /* Macro End */
-
-
-/** The OMX_GetParameter macro will get one of the current parameter
-    settings from the component.  This macro cannot only be invoked when
-    the component is in the OMX_StateInvalid state.  The nParamIndex
-    parameter is used to indicate which structure is being requested from
-    the component.  The application shall allocate the correct structure
-    and shall fill in the structure size and version information before
-    invoking this macro.  When the parameter applies to a port, the
-    caller shall fill in the appropriate nPortIndex value indicating the
-    port on which the parameter applies. If the component has not had
-    any settings changed, then the component should return a set of
-    valid DEFAULT  parameters for the component.  This is a blocking
-    call.
-
-    The component should return from this call within 20 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nParamIndex
-        Index of the structure to be filled.  This value is from the
-        OMX_INDEXTYPE enumeration.
-    @param [in,out] pComponentParameterStructure
-        Pointer to application allocated structure to be filled by the
-        component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_GetParameter(                                   \
-        hComponent,                                         \
-        nParamIndex,                                        \
-        pComponentParameterStructure)                        \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetParameter(         \
-        hComponent,                                         \
-        nParamIndex,                                        \
-        pComponentParameterStructure)    /* Macro End */
-
-
-/** The OMX_SetParameter macro will send an initialization parameter
-    structure to a component.  Each structure shall be sent one at a time,
-    in a separate invocation of the macro.  This macro can only be
-    invoked when the component is in the OMX_StateLoaded state, or the
-    port is disabled (when the parameter applies to a port). The
-    nParamIndex parameter is used to indicate which structure is being
-    passed to the component.  The application shall allocate the
-    correct structure and shall fill in the structure size and version
-    information (as well as the actual data) before invoking this macro.
-    The application is free to dispose of this structure after the call
-    as the component is required to copy any data it shall retain.  This
-    is a blocking call.
-
-    The component should return from this call within 20 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nIndex
-        Index of the structure to be sent.  This value is from the
-        OMX_INDEXTYPE enumeration.
-    @param [in] pComponentParameterStructure
-        pointer to application allocated structure to be used for
-        initialization by the component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_SetParameter(                                   \
-        hComponent,                                         \
-        nParamIndex,                                        \
-        pComponentParameterStructure)                        \
-    ((OMX_COMPONENTTYPE*)hComponent)->SetParameter(         \
-        hComponent,                                         \
-        nParamIndex,                                        \
-        pComponentParameterStructure)    /* Macro End */
-
-
-/** The OMX_GetConfig macro will get one of the configuration structures
-    from a component.  This macro can be invoked anytime after the
-    component has been loaded.  The nParamIndex call parameter is used to
-    indicate which structure is being requested from the component.  The
-    application shall allocate the correct structure and shall fill in the
-    structure size and version information before invoking this macro.
-    If the component has not had this configuration parameter sent before,
-    then the component should return a set of valid DEFAULT values for the
-    component.  This is a blocking call.
-
-    The component should return from this call within 5 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nIndex
-        Index of the structure to be filled.  This value is from the
-        OMX_INDEXTYPE enumeration.
-    @param [in,out] pComponentConfigStructure
-        pointer to application allocated structure to be filled by the
-        component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
-*/
-#define OMX_GetConfig(                                      \
-        hComponent,                                         \
-        nConfigIndex,                                       \
-        pComponentConfigStructure)                           \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetConfig(            \
-        hComponent,                                         \
-        nConfigIndex,                                       \
-        pComponentConfigStructure)       /* Macro End */
-
-
-/** The OMX_SetConfig macro will send one of the configuration
-    structures to a component.  Each structure shall be sent one at a time,
-    each in a separate invocation of the macro.  This macro can be invoked
-    anytime after the component has been loaded.  The application shall
-    allocate the correct structure and shall fill in the structure size
-    and version information (as well as the actual data) before invoking
-    this macro.  The application is free to dispose of this structure after
-    the call as the component is required to copy any data it shall retain.
-    This is a blocking call.
-
-    The component should return from this call within 5 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nConfigIndex
-        Index of the structure to be sent.  This value is from the
-        OMX_INDEXTYPE enumeration above.
-    @param [in] pComponentConfigStructure
-        pointer to application allocated structure to be used for
-        initialization by the component.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_SetConfig(                                      \
-        hComponent,                                         \
-        nConfigIndex,                                       \
-        pComponentConfigStructure)                           \
-    ((OMX_COMPONENTTYPE*)hComponent)->SetConfig(            \
-        hComponent,                                         \
-        nConfigIndex,                                       \
-        pComponentConfigStructure)       /* Macro End */
-
-
-/** The OMX_GetExtensionIndex macro will invoke a component to translate
-    a vendor specific configuration or parameter string into an OMX
-    structure index.  There is no requirement for the vendor to support
-    this command for the indexes already found in the OMX_INDEXTYPE
-    enumeration (this is done to save space in small components).  The
-    component shall support all vendor supplied extension indexes not found
-    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.
-
-    The component should return from this call within 5 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the GetHandle function.
-    @param [in] cParameterName
-        OMX_STRING that shall be less than 128 characters long including
-        the trailing null byte.  This is the string that will get
-        translated by the component into a configuration index.
-    @param [out] pIndexType
-        a pointer to a OMX_INDEXTYPE to receive the index value.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_GetExtensionIndex(                              \
-        hComponent,                                         \
-        cParameterName,                                     \
-        pIndexType)                                         \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex(    \
-        hComponent,                                         \
-        cParameterName,                                     \
-        pIndexType)                     /* Macro End */
-
-
-/** The OMX_GetState macro will invoke the component to get the current
-    state of the component and place the state value into the location
-    pointed to by pState.
-
-    The component should return from this call within 5 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] pState
-        pointer to the location to receive the state.  The value returned
-        is one of the OMX_STATETYPE members
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp
- */
-#define OMX_GetState(                                       \
-        hComponent,                                         \
-        pState)                                             \
-    ((OMX_COMPONENTTYPE*)hComponent)->GetState(             \
-        hComponent,                                         \
-        pState)                         /* Macro End */
-
-
-/** The OMX_UseBuffer macro will request that the component use
-    a buffer (and allocate its own buffer header) already allocated
-    by another component, or by the IL Client. This is a blocking
-    call.
-
-    The component should return from this call within 20 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the
-        pointer to the buffer header
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-
-#define OMX_UseBuffer(                                      \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           nSizeBytes,                                      \
-           pBuffer)                                         \
-    ((OMX_COMPONENTTYPE*)hComponent)->UseBuffer(            \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           nSizeBytes,                                      \
-           pBuffer)
-
-
-/** The OMX_AllocateBuffer macro will request that the component allocate
-    a new buffer and buffer header.  The component will allocate the
-    buffer and the buffer header and return a pointer to the buffer
-    header.  This is a blocking call.
-
-    The component should return from this call within 5 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive
-        the pointer to the buffer header
-    @param [in] nPortIndex
-        nPortIndex is used to select the port on the component the buffer will
-        be used with.  The port can be found by using the nPortIndex
-        value as an index into the Port Definition array of the component.
-    @param [in] pAppPrivate
-        pAppPrivate is used to initialize the pAppPrivate member of the
-        buffer header structure.
-    @param [in] nSizeBytes
-        size of the buffer to allocate.  Used when bAllocateNew is true.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-#define OMX_AllocateBuffer(                                 \
-        hComponent,                                         \
-        ppBuffer,                                           \
-        nPortIndex,                                         \
-        pAppPrivate,                                        \
-        nSizeBytes)                                         \
-    ((OMX_COMPONENTTYPE*)hComponent)->AllocateBuffer(       \
-        hComponent,                                         \
-        ppBuffer,                                           \
-        nPortIndex,                                         \
-        pAppPrivate,                                        \
-        nSizeBytes)                     /* Macro End */
-
-
-/** The OMX_FreeBuffer macro will release a buffer header from the component
-    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If
-    the component allocated the buffer (see the OMX_UseBuffer macro) then
-    the component shall free the buffer and buffer header. This is a
-    blocking call.
-
-    The component should return from this call within 20 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] nPortIndex
-        nPortIndex is used to select the port on the component the buffer will
-        be used with.
-    @param [in] pBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-        or AllocateBuffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-#define OMX_FreeBuffer(                                     \
-        hComponent,                                         \
-        nPortIndex,                                         \
-        pBuffer)                                            \
-    ((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer(           \
-        hComponent,                                         \
-        nPortIndex,                                         \
-        pBuffer)                        /* Macro End */
-
-
-/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an
-    input port of a component.  The buffer will be emptied by the component
-    and returned to the application via the EmptyBufferDone call back.
-    This is a non-blocking call in that the component will record the buffer
-    and return immediately and then empty the buffer, later, at the proper
-    time.  As expected, this macro may be invoked only while the component
-    is in the OMX_StateExecuting.  If nPortIndex does not specify an input
-    port, the component shall return an error.
-
-    The component should return from this call within 5 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] pBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-        or AllocateBuffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-#define OMX_EmptyThisBuffer(                                \
-        hComponent,                                         \
-        pBuffer)                                            \
-    ((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer(      \
-        hComponent,                                         \
-        pBuffer)                        /* Macro End */
-
-
-/** The OMX_FillThisBuffer macro will send an empty buffer to an
-    output port of a component.  The buffer will be filled by the component
-    and returned to the application via the FillBufferDone call back.
-    This is a non-blocking call in that the component will record the buffer
-    and return immediately and then fill the buffer, later, at the proper
-    time.  As expected, this macro may be invoked only while the component
-    is in the OMX_ExecutingState.  If nPortIndex does not specify an output
-    port, the component shall return an error.
-
-    The component should return from this call within 5 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [in] pBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
-        or AllocateBuffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-#define OMX_FillThisBuffer(                                 \
-        hComponent,                                         \
-        pBuffer)                                            \
-    ((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer(       \
-        hComponent,                                         \
-        pBuffer)                        /* Macro End */
-
-
-
-/** The OMX_UseEGLImage macro will request that the component use
-    a EGLImage provided by EGL (and allocate its own buffer header)
-    This is a blocking call.
-
-    The component should return from this call within 20 msec.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the OMX_GetHandle function.
-    @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the
-        pointer to the buffer header.  Note that the memory location used
-        for this buffer is NOT visible to the IL Client.
-    @param [in] nPortIndex
-        nPortIndex is used to select the port on the component the buffer will
-        be used with.  The port can be found by using the nPortIndex
-        value as an index into the Port Definition array of the component.
-    @param [in] pAppPrivate
-        pAppPrivate is used to initialize the pAppPrivate member of the
-        buffer header structure.
-    @param [in] eglImage
-        eglImage contains the handle of the EGLImage to use as a buffer on the
-        specified port.  The component is expected to validate properties of
-        the EGLImage against the configuration of the port to ensure the component
-        can use the EGLImage as a buffer.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup comp buf
- */
-#define OMX_UseEGLImage(                                    \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           eglImage)                                        \
-    ((OMX_COMPONENTTYPE*)hComponent)->UseEGLImage(          \
-           hComponent,                                      \
-           ppBufferHdr,                                     \
-           nPortIndex,                                      \
-           pAppPrivate,                                     \
-           eglImage)
-
-/** The OMX_Init method is used to initialize the OMX core.  It shall be the
-    first call made into OMX and it should only be executed one time without
-    an interviening OMX_Deinit call.
-
-    The core should return from this call within 20 msec.
-
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);
-
-
-/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be
-    the last call made into OMX. In the event that the core determines that
-    thare are components loaded when this call is made, the core may return
-    with an error rather than try to unload the components.
-
-    The core should return from this call within 20 msec.
-
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void);
-
-
-/** The OMX_ComponentNameEnum method will enumerate through all the names of
-    recognised valid components in the system. This function is provided
-    as a means to detect all the components in the system run-time. There is
-    no strict ordering to the enumeration order of component names, although
-    each name will only be enumerated once.  If the OMX core supports run-time
-    installation of new components, it is only requried to detect newly
-    installed components when the first call to enumerate component names
-    is made (i.e. when nIndex is 0x0).
-
-    The core should return from this call in 20 msec.
-
-    @param [out] cComponentName
-        pointer to a null terminated string with the component name.  The
-        names of the components are strings less than 127 bytes in length
-        plus the trailing null for a maximum size of 128 bytes.  An example
-        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are
-        assigned by the vendor, but shall start with "OMX." and then have
-        the Vendor designation next.
-    @param [in] nNameLength
-        number of characters in the cComponentName string.  With all
-        component name strings restricted to less than 128 characters
-        (including the trailing null) it is recomended that the caller
-        provide a input string for the cComponentName of 128 characters.
-    @param [in] nIndex
-        number containing the enumeration index for the component.
-        Multiple calls to OMX_ComponentNameEnum with increasing values
-        of nIndex will enumerate through the component names in the
-        system until OMX_ErrorNoMore is returned.  The value of nIndex
-        is 0 to (N-1), where N is the number of valid installed components
-        in the system.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  When the value of nIndex exceeds the number of
-        components in the system minus 1, OMX_ErrorNoMore will be
-        returned. Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
-    OMX_OUT OMX_STRING cComponentName,
-    OMX_IN  OMX_U32 nNameLength,
-    OMX_IN  OMX_U32 nIndex);
-
-
-/** The OMX_GetHandle method will locate the component specified by the
-    component name given, load that component into memory and then invoke
-    the component's methods to create an instance of the component.
-
-    The core should return from this call within 20 msec.
-
-    @param [out] pHandle
-        pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
-    @param [in] cComponentName
-        pointer to a null terminated string with the component name.  The
-        names of the components are strings less than 127 bytes in length
-        plus the trailing null for a maximum size of 128 bytes.  An example
-        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are
-        assigned by the vendor, but shall start with "OMX." and then have
-        the Vendor designation next.
-    @param [in] pAppData
-        pointer to an application defined value that will be returned
-        during callbacks so that the application can identify the source
-        of the callback.
-    @param [in] pCallBacks
-        pointer to a OMX_CALLBACKTYPE structure that will be passed to the
-        component to initialize it with.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
-    OMX_OUT OMX_HANDLETYPE* pHandle,
-    OMX_IN  OMX_STRING cComponentName,
-    OMX_IN  OMX_PTR pAppData,
-    OMX_IN  OMX_CALLBACKTYPE* pCallBacks);
-
-
-/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle
-    method.  If the component reference count goes to zero, the component will
-    be unloaded from memory.
-
-    The core should return from this call within 20 msec when the component is
-    in the OMX_StateLoaded state.
-
-    @param [in] hComponent
-        Handle of the component to be accessed.  This is the component
-        handle returned by the call to the GetHandle function.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
-    OMX_IN  OMX_HANDLETYPE hComponent);
-
-
-
-/** The OMX_SetupTunnel method will handle the necessary calls to the components
-    to setup the specified tunnel the two components.  NOTE: This is
-    an actual method (not a #define macro).  This method will make calls into
-    the component ComponentTunnelRequest method to do the actual tunnel
-    connection.
-
-    The ComponentTunnelRequest method on both components will be called.
-    This method shall not be called unless the component is in the
-    OMX_StateLoaded state except when the ports used for the tunnel are
-    disabled. In this case, the component may be in the OMX_StateExecuting,
-    OMX_StatePause, or OMX_StateIdle states.
-
-    The core should return from this call within 20 msec.
-
-    @param [in] hOutput
-        Handle of the component to be accessed.  Also this is the handle
-        of the component whose port, specified in the nPortOutput parameter
-        will be used the source for the tunnel. This is the component handle
-        returned by the call to the OMX_GetHandle function.  There is a
-        requirement that hOutput be the source for the data when
-        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
-        specified in hInput will have it's port specified in nPortInput
-        setup for communication with the application / IL client.
-    @param [in] nPortOutput
-        nPortOutput is used to select the source port on component to be
-        used in the tunnel.
-    @param [in] hInput
-        This is the component to setup the tunnel with. This is the handle
-        of the component whose port, specified in the nPortInput parameter
-        will be used the destination for the tunnel. This is the component handle
-        returned by the call to the OMX_GetHandle function.  There is a
-        requirement that hInput be the destination for the data when
-        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
-        specified in hOutput will have it's port specified in nPortPOutput
-        setup for communication with the application / IL client.
-    @param [in] nPortInput
-        nPortInput is used to select the destination port on component to be
-        used in the tunnel.
-    @return OMX_ERRORTYPE
-        If the command successfully executes, the return code will be
-        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-        When OMX_ErrorNotImplemented is returned, one or both components is
-        a non-interop component and does not support tunneling.
-
-        On failure, the ports of both components are setup for communication
-        with the application / IL Client.
-    @ingroup core tun
- */
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
-    OMX_IN  OMX_HANDLETYPE hOutput,
-    OMX_IN  OMX_U32 nPortOutput,
-    OMX_IN  OMX_HANDLETYPE hInput,
-    OMX_IN  OMX_U32 nPortInput);
-
-/** @ingroup cp */
-OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
-    OMX_OUT OMX_HANDLETYPE *hPipe,
-    OMX_IN OMX_STRING szURI);
-
-/** The OMX_GetComponentsOfRole method will return the number of components that support the given
-    role and (if the compNames field is non-NULL) the names of those components. The call will fail if
-    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
-    client should:
-        * first call this function with the compNames field NULL to determine the number of component names
-        * second call this function with the compNames field pointing to an array of names allocated
-          according to the number returned by the first call.
-
-    The core should return from this call within 5 msec.
-
-    @param [in] role
-        This is generic standard component name consisting only of component class
-        name and the type within that class (e.g. 'audio_decoder.aac').
-    @param [inout] pNumComps
-        This is used both as input and output.
-
-        If compNames is NULL, the input is ignored and the output specifies how many components support
-        the given role.
-
-        If compNames is not NULL, on input it bounds the size of the input structure and
-        on output, it specifies the number of components string names listed within the compNames parameter.
-    @param [inout] compNames
-        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts
-        a list of the names of all physical components that implement the specified standard component name.
-        Each name is NULL terminated. numComps indicates the number of names.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole (
-	OMX_IN      OMX_STRING role,
-    OMX_INOUT   OMX_U32 *pNumComps,
-    OMX_INOUT   OMX_U8  **compNames);
-
-/** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
-    component and (if the roles field is non-NULL) the names of those roles. The call will fail if
-    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
-    client should:
-        * first call this function with the roles field NULL to determine the number of role names
-        * second call this function with the roles field pointing to an array of names allocated
-          according to the number returned by the first call.
-
-    The core should return from this call within 5 msec.
-
-    @param [in] compName
-        This is the name of the component being queried about.
-    @param [inout] pNumRoles
-        This is used both as input and output.
-
-        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
-
-        If compNames is not NULL, on input it bounds the size of the input structure and
-        on output, it specifies the number of roles string names listed within the roles parameter.
-    @param [out] roles
-        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings
-        which accepts a list of the names of all standard components roles implemented on the
-        specified component name. numComps indicates the number of names.
-    @ingroup core
- */
-OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent (
-	OMX_IN      OMX_STRING compName,
-    OMX_INOUT   OMX_U32 *pNumRoles,
-    OMX_OUT     OMX_U8 **roles);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
-
diff --git a/ilcore/inc/khronos/openmax/include/OMX_IVCommon.h b/ilcore/inc/khronos/openmax/include/OMX_IVCommon.h
deleted file mode 100644
index c86baf1..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_IVCommon.h
+++ /dev/null
@@ -1,953 +0,0 @@
-/**
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/**
- * @file OMX_IVCommon.h - OpenMax IL version 1.1.2
- *  The structures needed by Video and Image components to exchange
- *  parameters and configuration data with the components.
- */
-#ifndef OMX_IVCommon_h
-#define OMX_IVCommon_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/**
- * Each OMX header must include all required header files to allow the header
- * to compile without errors.  The includes below are required for this header
- * file to compile successfully
- */
-
-#include <OMX_Core.h>
-
-/** @defgroup iv OpenMAX IL Imaging and Video Domain
- * Common structures for OpenMAX IL Imaging and Video domains
- * @{
- */
-
-
-/**
- * Enumeration defining possible uncompressed image/video formats.
- *
- * ENUMS:
- *  Unused                 : Placeholder value when format is N/A
- *  Monochrome             : black and white
- *  8bitRGB332             : Red 7:5, Green 4:2, Blue 1:0
- *  12bitRGB444            : Red 11:8, Green 7:4, Blue 3:0
- *  16bitARGB4444          : Alpha 15:12, Red 11:8, Green 7:4, Blue 3:0
- *  16bitARGB1555          : Alpha 15, Red 14:10, Green 9:5, Blue 4:0
- *  16bitRGB565            : Red 15:11, Green 10:5, Blue 4:0
- *  16bitBGR565            : Blue 15:11, Green 10:5, Red 4:0
- *  18bitRGB666            : Red 17:12, Green 11:6, Blue 5:0
- *  18bitARGB1665          : Alpha 17, Red 16:11, Green 10:5, Blue 4:0
- *  19bitARGB1666          : Alpha 18, Red 17:12, Green 11:6, Blue 5:0
- *  24bitRGB888            : Red 24:16, Green 15:8, Blue 7:0
- *  24bitBGR888            : Blue 24:16, Green 15:8, Red 7:0
- *  24bitARGB1887          : Alpha 23, Red 22:15, Green 14:7, Blue 6:0
- *  25bitARGB1888          : Alpha 24, Red 23:16, Green 15:8, Blue 7:0
- *  32bitBGRA8888          : Blue 31:24, Green 23:16, Red 15:8, Alpha 7:0
- *  32bitARGB8888          : Alpha 31:24, Red 23:16, Green 15:8, Blue 7:0
- *  YUV411Planar           : U,Y are subsampled by a factor of 4 horizontally
- *  YUV411PackedPlanar     : packed per payload in planar slices
- *  YUV420Planar           : Three arrays Y,U,V.
- *  YUV420PackedPlanar     : packed per payload in planar slices
- *  YUV420SemiPlanar       : Two arrays, one is all Y, the other is U and V
- *  YUV422Planar           : Three arrays Y,U,V.
- *  YUV422PackedPlanar     : packed per payload in planar slices
- *  YUV422SemiPlanar       : Two arrays, one is all Y, the other is U and V
- *  YCbYCr                 : Organized as 16bit YUYV (i.e. YCbYCr)
- *  YCrYCb                 : Organized as 16bit YVYU (i.e. YCrYCb)
- *  CbYCrY                 : Organized as 16bit UYVY (i.e. CbYCrY)
- *  CrYCbY                 : Organized as 16bit VYUY (i.e. CrYCbY)
- *  YUV444Interleaved      : Each pixel contains equal parts YUV
- *  RawBayer8bit           : SMIA camera output format
- *  RawBayer10bit          : SMIA camera output format
- *  RawBayer8bitcompressed : SMIA camera output format
- */
-typedef enum OMX_COLOR_FORMATTYPE {
-    OMX_COLOR_FormatUnused,
-    OMX_COLOR_FormatMonochrome,
-    OMX_COLOR_Format8bitRGB332,
-    OMX_COLOR_Format12bitRGB444,
-    OMX_COLOR_Format16bitARGB4444,
-    OMX_COLOR_Format16bitARGB1555,
-    OMX_COLOR_Format16bitRGB565,
-    OMX_COLOR_Format16bitBGR565,
-    OMX_COLOR_Format18bitRGB666,
-    OMX_COLOR_Format18bitARGB1665,
-    OMX_COLOR_Format19bitARGB1666,
-    OMX_COLOR_Format24bitRGB888,
-    OMX_COLOR_Format24bitBGR888,
-    OMX_COLOR_Format24bitARGB1887,
-    OMX_COLOR_Format25bitARGB1888,
-    OMX_COLOR_Format32bitBGRA8888,
-    OMX_COLOR_Format32bitARGB8888,
-    OMX_COLOR_FormatYUV411Planar,
-    OMX_COLOR_FormatYUV411PackedPlanar,
-    OMX_COLOR_FormatYUV420Planar,
-    OMX_COLOR_FormatYUV420PackedPlanar,
-    OMX_COLOR_FormatYUV420SemiPlanar,
-    OMX_COLOR_FormatYUV422Planar,
-    OMX_COLOR_FormatYUV422PackedPlanar,
-    OMX_COLOR_FormatYUV422SemiPlanar,
-    OMX_COLOR_FormatYCbYCr,
-    OMX_COLOR_FormatYCrYCb,
-    OMX_COLOR_FormatCbYCrY,
-    OMX_COLOR_FormatCrYCbY,
-    OMX_COLOR_FormatYUV444Interleaved,
-    OMX_COLOR_FormatRawBayer8bit,
-    OMX_COLOR_FormatRawBayer10bit,
-    OMX_COLOR_FormatRawBayer8bitcompressed,
-    OMX_COLOR_FormatL2,
-    OMX_COLOR_FormatL4,
-    OMX_COLOR_FormatL8,
-    OMX_COLOR_FormatL16,
-    OMX_COLOR_FormatL24,
-    OMX_COLOR_FormatL32,
-    OMX_COLOR_FormatYUV420PackedSemiPlanar,
-    OMX_COLOR_FormatYUV422PackedSemiPlanar,
-    OMX_COLOR_Format18BitBGR666,
-    OMX_COLOR_Format24BitARGB6666,
-    OMX_COLOR_Format24BitABGR6666,
-    OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_COLOR_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_COLOR_FormatMax = 0x7FFFFFFF
-} OMX_COLOR_FORMATTYPE;
-
-
-/**
- * Defines the matrix for conversion from RGB to YUV or vice versa.
- * iColorMatrix should be initialized with the fixed point values
- * used in converting between formats.
- */
-typedef struct OMX_CONFIG_COLORCONVERSIONTYPE {
-    OMX_U32 nSize;              /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */
-    OMX_U32 nPortIndex;         /**< Port that this struct applies to */
-    OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
-    OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
-}OMX_CONFIG_COLORCONVERSIONTYPE;
-
-
-/**
- * Structure defining percent to scale each frame dimension.  For example:
- * To make the width 50% larger, use fWidth = 1.5 and to make the width
- * 1/2 the original size, use fWidth = 0.5
- */
-typedef struct OMX_CONFIG_SCALEFACTORTYPE {
-    OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */
-    OMX_U32 nPortIndex;       /**< Port that this struct applies to */
-    OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
-    OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
-}OMX_CONFIG_SCALEFACTORTYPE;
-
-
-/**
- * Enumeration of possible image filter types
- */
-typedef enum OMX_IMAGEFILTERTYPE {
-    OMX_ImageFilterNone,
-    OMX_ImageFilterNoise,
-    OMX_ImageFilterEmboss,
-    OMX_ImageFilterNegative,
-    OMX_ImageFilterSketch,
-    OMX_ImageFilterOilPaint,
-    OMX_ImageFilterHatch,
-    OMX_ImageFilterGpen,
-    OMX_ImageFilterAntialias,
-    OMX_ImageFilterDeRing,
-    OMX_ImageFilterSolarize,
-    OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_ImageFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_ImageFilterMax = 0x7FFFFFFF
-} OMX_IMAGEFILTERTYPE;
-
-
-/**
- * Image filter configuration
- *
- * STRUCT MEMBERS:
- *  nSize        : Size of the structure in bytes
- *  nVersion     : OMX specification version information
- *  nPortIndex   : Port that this structure applies to
- *  eImageFilter : Image filter type enumeration
- */
-typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGEFILTERTYPE eImageFilter;
-} OMX_CONFIG_IMAGEFILTERTYPE;
-
-
-/**
- * Customized U and V for color enhancement
- *
- * STRUCT MEMBERS:
- *  nSize             : Size of the structure in bytes
- *  nVersion          : OMX specification version information
- *  nPortIndex        : Port that this structure applies to
- *  bColorEnhancement : Enable/disable color enhancement
- *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for
- *                      U component
- *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for
- *                      V component
- */
-typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bColorEnhancement;
-    OMX_U8 nCustomizedU;
-    OMX_U8 nCustomizedV;
-} OMX_CONFIG_COLORENHANCEMENTTYPE;
-
-
-/**
- * Define color key and color key mask
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
- *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
- */
-typedef struct OMX_CONFIG_COLORKEYTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nARGBColor;
-    OMX_U32 nARGBMask;
-} OMX_CONFIG_COLORKEYTYPE;
-
-/*
-** A pointer to this struct is passed to the OMX_SetParameter when the extension
-** index for the 'OMX.google.android.index.enableAndroidNativeBuffers' extension
-** is given.
-**
-** When Android native buffer use is disabled for a port (the default state),
-** the OMX node should operate as normal, and expect UseBuffer calls to set its
-** buffers.  This is the mode that will be used when CPU access to the buffer is
-** required.
-**
-** When Android native buffer use has been enabled for a given port, the video
-** color format for the port is to be interpreted as an Android pixel format
-** rather than an OMX color format.  The node should then expect to receive
-** UseAndroidNativeBuffer calls (via OMX_SetParameter) rather than UseBuffer
-** calls for that port.
-*/
-typedef struct OMX_GOOGLE_ENABLE_ANDROID_BUFFERS{
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL enable;
-}OMX_GOOGLE_ENABLE_ANDROID_BUFFERS;
-
-// A pointer to this struct is passed to OMX_GetParameter when the extension
-// index for the 'OMX.google.android.index.getAndroidNativeBufferUsage'
-// extension is given.  The usage bits returned from this query will be used to
-// allocate the Gralloc buffers that get passed to the useAndroidNativeBuffer
-// command.
-typedef struct OMX_GOOGLE_ANDROID_BUFFERS_USAGE {
-    OMX_U32 nSize;              // IN
-    OMX_VERSIONTYPE nVersion;   // IN
-    OMX_U32 nPortIndex;         // IN
-    OMX_U32 nUsage;             // OUT
-}OMX_GOOGLE_ANDROID_BUFFERS_USAGE;
-/**
- * List of color blend types for pre/post processing
- *
- * ENUMS:
- *  None          : No color blending present
- *  AlphaConstant : Function is (alpha_constant * src) +
- *                  (1 - alpha_constant) * dst)
- *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
- *  Alternate     : Function is alternating pixels from src and dst
- *  And           : Function is (src & dst)
- *  Or            : Function is (src | dst)
- *  Invert        : Function is ~src
- */
-typedef enum OMX_COLORBLENDTYPE {
-    OMX_ColorBlendNone,
-    OMX_ColorBlendAlphaConstant,
-    OMX_ColorBlendAlphaPerPixel,
-    OMX_ColorBlendAlternate,
-    OMX_ColorBlendAnd,
-    OMX_ColorBlendOr,
-    OMX_ColorBlendInvert,
-    OMX_ColorBlendKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_ColorBlendVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_ColorBlendMax = 0x7FFFFFFF
-} OMX_COLORBLENDTYPE;
-
-
-/**
- * Color blend configuration
- *
- * STRUCT MEMBERS:
- *  nSize             : Size of the structure in bytes
- *  nVersion          : OMX specification version information
- *  nPortIndex        : Port that this structure applies to
- *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
- *  eColorBlend       : Color blend type enumeration
- */
-typedef struct OMX_CONFIG_COLORBLENDTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nRGBAlphaConstant;
-    OMX_COLORBLENDTYPE  eColorBlend;
-} OMX_CONFIG_COLORBLENDTYPE;
-
-
-/**
- * Hold frame dimension
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nWidth     : Frame width in pixels
- *  nHeight    : Frame height in pixels
- */
-typedef struct OMX_FRAMESIZETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nWidth;
-    OMX_U32 nHeight;
-} OMX_FRAMESIZETYPE;
-
-
-/**
- * Rotation configuration
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nRotation  : +/- integer rotation value
- */
-typedef struct OMX_CONFIG_ROTATIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nRotation;
-} OMX_CONFIG_ROTATIONTYPE;
-
-
-/**
- * Possible mirroring directions for pre/post processing
- *
- * ENUMS:
- *  None       : No mirroring
- *  Vertical   : Vertical mirroring, flip on X axis
- *  Horizontal : Horizontal mirroring, flip on Y axis
- *  Both       : Both vertical and horizontal mirroring
- */
-typedef enum OMX_MIRRORTYPE {
-    OMX_MirrorNone = 0,
-    OMX_MirrorVertical,
-    OMX_MirrorHorizontal,
-    OMX_MirrorBoth,
-    OMX_MirrorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_MirrorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_MirrorMax = 0x7FFFFFFF
-} OMX_MIRRORTYPE;
-
-
-/**
- * Mirroring configuration
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  eMirror    : Mirror type enumeration
- */
-typedef struct OMX_CONFIG_MIRRORTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_MIRRORTYPE  eMirror;
-} OMX_CONFIG_MIRRORTYPE;
-
-
-/**
- * Position information only
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nX         : X coordinate for the point
- *  nY         : Y coordinate for the point
- */
-typedef struct OMX_CONFIG_POINTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nX;
-    OMX_S32 nY;
-} OMX_CONFIG_POINTTYPE;
-
-
-/**
- * Frame size plus position
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nLeft      : X Coordinate of the top left corner of the rectangle
- *  nTop       : Y Coordinate of the top left corner of the rectangle
- *  nWidth     : Width of the rectangle
- *  nHeight    : Height of the rectangle
- */
-typedef struct OMX_CONFIG_RECTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nLeft;
-    OMX_S32 nTop;
-    OMX_U32 nWidth;
-    OMX_U32 nHeight;
-} OMX_CONFIG_RECTTYPE;
-
-
-/**
- * Deblocking state; it is required to be set up before starting the codec
- *
- * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes
- *  nVersion    : OMX specification version information
- *  nPortIndex  : Port that this structure applies to
- *  bDeblocking : Enable/disable deblocking mode
- */
-typedef struct OMX_PARAM_DEBLOCKINGTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bDeblocking;
-} OMX_PARAM_DEBLOCKINGTYPE;
-
-
-/**
- * Stabilization state
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  bStab      : Enable/disable frame stabilization state
- */
-typedef struct OMX_CONFIG_FRAMESTABTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bStab;
-} OMX_CONFIG_FRAMESTABTYPE;
-
-
-/**
- * White Balance control type
- *
- * STRUCT MEMBERS:
- *  SunLight : Referenced in JSR-234
- *  Flash    : Optimal for device's integrated flash
- */
-typedef enum OMX_WHITEBALCONTROLTYPE {
-    OMX_WhiteBalControlOff = 0,
-    OMX_WhiteBalControlAuto,
-    OMX_WhiteBalControlSunLight,
-    OMX_WhiteBalControlCloudy,
-    OMX_WhiteBalControlShade,
-    OMX_WhiteBalControlTungsten,
-    OMX_WhiteBalControlFluorescent,
-    OMX_WhiteBalControlIncandescent,
-    OMX_WhiteBalControlFlash,
-    OMX_WhiteBalControlHorizon,
-    OMX_WhiteBalControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_WhiteBalControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_WhiteBalControlMax = 0x7FFFFFFF
-} OMX_WHITEBALCONTROLTYPE;
-
-
-/**
- * White Balance control configuration
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes
- *  nVersion         : OMX specification version information
- *  nPortIndex       : Port that this structure applies to
- *  eWhiteBalControl : White balance enumeration
- */
-typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_WHITEBALCONTROLTYPE eWhiteBalControl;
-} OMX_CONFIG_WHITEBALCONTROLTYPE;
-
-
-/**
- * Exposure control type
- */
-typedef enum OMX_EXPOSURECONTROLTYPE {
-    OMX_ExposureControlOff = 0,
-    OMX_ExposureControlAuto,
-    OMX_ExposureControlNight,
-    OMX_ExposureControlBackLight,
-    OMX_ExposureControlSpotLight,
-    OMX_ExposureControlSports,
-    OMX_ExposureControlSnow,
-    OMX_ExposureControlBeach,
-    OMX_ExposureControlLargeAperture,
-    OMX_ExposureControlSmallApperture,
-    OMX_ExposureControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_ExposureControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_ExposureControlMax = 0x7FFFFFFF
-} OMX_EXPOSURECONTROLTYPE;
-
-
-/**
- * White Balance control configuration
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes
- *  nVersion         : OMX specification version information
- *  nPortIndex       : Port that this structure applies to
- *  eExposureControl : Exposure control enumeration
- */
-typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_EXPOSURECONTROLTYPE eExposureControl;
-} OMX_CONFIG_EXPOSURECONTROLTYPE;
-
-
-/**
- * Defines sensor supported mode.
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nFrameRate : Single shot mode is indicated by a 0
- *  bOneShot   : Enable for single shot, disable for streaming
- *  sFrameSize : Framesize
- */
-typedef struct OMX_PARAM_SENSORMODETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nFrameRate;
-    OMX_BOOL bOneShot;
-    OMX_FRAMESIZETYPE sFrameSize;
-} OMX_PARAM_SENSORMODETYPE;
-
-
-/**
- * Defines contrast level
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
- */
-typedef struct OMX_CONFIG_CONTRASTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nContrast;
-} OMX_CONFIG_CONTRASTTYPE;
-
-
-/**
- * Defines brightness level
- *
- * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes
- *  nVersion    : OMX specification version information
- *  nPortIndex  : Port that this structure applies to
- *  nBrightness : 0-100%
- */
-typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nBrightness;
-} OMX_CONFIG_BRIGHTNESSTYPE;
-
-
-/**
- * Defines backlight level configuration for a video sink, e.g. LCD panel
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nBacklight : Values allowed for backlight 0-100%
- *  nTimeout   : Number of milliseconds before backlight automatically turns
- *               off.  A value of 0x0 disables backight timeout
- */
-typedef struct OMX_CONFIG_BACKLIGHTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nBacklight;
-    OMX_U32 nTimeout;
-} OMX_CONFIG_BACKLIGHTTYPE;
-
-
-/**
- * Defines setting for Gamma
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
- */
-typedef struct OMX_CONFIG_GAMMATYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nGamma;
-} OMX_CONFIG_GAMMATYPE;
-
-
-/**
- * Define for setting saturation
- *
- * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes
- *  nVersion    : OMX specification version information
- *  nPortIndex  : Port that this structure applies to
- *  nSaturation : Values allowed for saturation -100 to 100, zero means
- *                no change
- */
-typedef struct OMX_CONFIG_SATURATIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nSaturation;
-} OMX_CONFIG_SATURATIONTYPE;
-
-
-/**
- * Define for setting Lightness
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nLightness : Values allowed for lightness -100 to 100, zero means no
- *               change
- */
-typedef struct OMX_CONFIG_LIGHTNESSTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_S32 nLightness;
-} OMX_CONFIG_LIGHTNESSTYPE;
-
-
-/**
- * Plane blend configuration
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Index of input port associated with the plane.
- *  nDepth     : Depth of the plane in relation to the screen. Higher
- *               numbered depths are "behind" lower number depths.
- *               This number defaults to the Port Index number.
- *  nAlpha     : Transparency blending component for the entire plane.
- *               See blending modes for more detail.
- */
-typedef struct OMX_CONFIG_PLANEBLENDTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nDepth;
-    OMX_U32 nAlpha;
-} OMX_CONFIG_PLANEBLENDTYPE;
-
-
-/**
- * Define interlace type
- *
- * STRUCT MEMBERS:
- *  nSize                 : Size of the structure in bytes
- *  nVersion              : OMX specification version information
- *  nPortIndex            : Port that this structure applies to
- *  bEnable               : Enable control variable for this functionality
- *                          (see below)
- *  nInterleavePortIndex  : Index of input or output port associated with
- *                          the interleaved plane.
- *  pPlanarPortIndexes[4] : Index of input or output planar ports.
- */
-typedef struct OMX_PARAM_INTERLEAVETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bEnable;
-    OMX_U32 nInterleavePortIndex;
-} OMX_PARAM_INTERLEAVETYPE;
-
-
-/**
- * Defines the picture effect used for an input picture
- */
-typedef enum OMX_TRANSITIONEFFECTTYPE {
-    OMX_EffectNone,
-    OMX_EffectFadeFromBlack,
-    OMX_EffectFadeToBlack,
-    OMX_EffectUnspecifiedThroughConstantColor,
-    OMX_EffectDissolve,
-    OMX_EffectWipe,
-    OMX_EffectUnspecifiedMixOfTwoScenes,
-    OMX_EffectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_EffectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_EffectMax = 0x7FFFFFFF
-} OMX_TRANSITIONEFFECTTYPE;
-
-
-/**
- * Structure used to configure current transition effect
- *
- * STRUCT MEMBERS:
- * nSize      : Size of the structure in bytes
- * nVersion   : OMX specification version information
- * nPortIndex : Port that this structure applies to
- * eEffect    : Effect to enable
- */
-typedef struct OMX_CONFIG_TRANSITIONEFFECTTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_TRANSITIONEFFECTTYPE eEffect;
-} OMX_CONFIG_TRANSITIONEFFECTTYPE;
-
-
-/**
- * Defines possible data unit types for encoded video data. The data unit
- * types are used both for encoded video input for playback as well as
- * encoded video output from recording.
- */
-typedef enum OMX_DATAUNITTYPE {
-    OMX_DataUnitCodedPicture,
-    OMX_DataUnitVideoSegment,
-    OMX_DataUnitSeveralSegments,
-    OMX_DataUnitArbitraryStreamSection,
-    OMX_DataUnitKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_DataUnitVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_DataUnitMax = 0x7FFFFFFF
-} OMX_DATAUNITTYPE;
-
-
-/**
- * Defines possible encapsulation types for coded video data unit. The
- * encapsulation information is used both for encoded video input for
- * playback as well as encoded video output from recording.
- */
-typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
-    OMX_DataEncapsulationElementaryStream,
-    OMX_DataEncapsulationGenericPayload,
-    OMX_DataEncapsulationRtpPayload,
-    OMX_DataEncapsulationKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_DataEncapsulationVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_DataEncapsulationMax = 0x7FFFFFFF
-} OMX_DATAUNITENCAPSULATIONTYPE;
-
-
-/**
- * Structure used to configure the type of being decoded/encoded
- */
-typedef struct OMX_PARAM_DATAUNITTYPE {
-    OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
-    OMX_DATAUNITTYPE eUnitType;
-    OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
-} OMX_PARAM_DATAUNITTYPE;
-
-
-/**
- * Defines dither types
- */
-typedef enum OMX_DITHERTYPE {
-    OMX_DitherNone,
-    OMX_DitherOrdered,
-    OMX_DitherErrorDiffusion,
-    OMX_DitherOther,
-    OMX_DitherKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_DitherVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_DitherMax = 0x7FFFFFFF
-} OMX_DITHERTYPE;
-
-
-/**
- * Structure used to configure current type of dithering
- */
-typedef struct OMX_CONFIG_DITHERTYPE {
-    OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
-    OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
-} OMX_CONFIG_DITHERTYPE;
-
-typedef struct OMX_CONFIG_CAPTUREMODETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;     /**< Port that this structure applies to */
-    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture
-                             *   data as fast as possible (otherwise obey port's frame rate). */
-    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the
-                             *   specified number of frames (otherwise the port does not
-                             *   terminate the capture until instructed to do so by the client).
-                             *   Even if set, the client may manually terminate the capture prior
-                             *   to reaching the limit. */
-    OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
-                               *   valid if bFrameLimited is set). */
-} OMX_CONFIG_CAPTUREMODETYPE;
-
-typedef enum OMX_METERINGTYPE {
-
-    OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
-    OMX_MeteringModeSpot,  	      /**< Spot (partial) metering. */
-    OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
-
-    OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_MeteringVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_EVModeMax = 0x7fffffff
-} OMX_METERINGTYPE;
-
-typedef struct OMX_CONFIG_EXPOSUREVALUETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_METERINGTYPE eMetering;
-    OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
-    OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
-    OMX_BOOL bAutoAperture;		/**< Whether aperture number is defined automatically */
-    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */
-    OMX_BOOL bAutoShutterSpeed;	/**< Whether shutter speed is defined automatically */
-    OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
-    OMX_BOOL bAutoSensitivity;	/**< Whether sensitivity is defined automatically */
-} OMX_CONFIG_EXPOSUREVALUETYPE;
-
-/**
- * Focus region configuration
- *
- * STRUCT MEMBERS:
- *  nSize           : Size of the structure in bytes
- *  nVersion        : OMX specification version information
- *  nPortIndex      : Port that this structure applies to
- *  bCenter         : Use center region as focus region of interest
- *  bLeft           : Use left region as focus region of interest
- *  bRight          : Use right region as focus region of interest
- *  bTop            : Use top region as focus region of interest
- *  bBottom         : Use bottom region as focus region of interest
- *  bTopLeft        : Use top left region as focus region of interest
- *  bTopRight       : Use top right region as focus region of interest
- *  bBottomLeft     : Use bottom left region as focus region of interest
- *  bBottomRight    : Use bottom right region as focus region of interest
- */
-typedef struct OMX_CONFIG_FOCUSREGIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bCenter;
-    OMX_BOOL bLeft;
-    OMX_BOOL bRight;
-    OMX_BOOL bTop;
-    OMX_BOOL bBottom;
-    OMX_BOOL bTopLeft;
-    OMX_BOOL bTopRight;
-    OMX_BOOL bBottomLeft;
-    OMX_BOOL bBottomRight;
-} OMX_CONFIG_FOCUSREGIONTYPE;
-
-/**
- * Focus Status type
- */
-typedef enum OMX_FOCUSSTATUSTYPE {
-    OMX_FocusStatusOff = 0,
-    OMX_FocusStatusRequest,
-    OMX_FocusStatusReached,
-    OMX_FocusStatusUnableToReach,
-    OMX_FocusStatusLost,
-    OMX_FocusStatusKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_FocusStatusVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_FocusStatusMax = 0x7FFFFFFF
-} OMX_FOCUSSTATUSTYPE;
-
-/**
- * Focus status configuration
- *
- * STRUCT MEMBERS:
- *  nSize               : Size of the structure in bytes
- *  nVersion            : OMX specification version information
- *  nPortIndex          : Port that this structure applies to
- *  eFocusStatus        : Specifies the focus status
- *  bCenterStatus       : Use center region as focus region of interest
- *  bLeftStatus         : Use left region as focus region of interest
- *  bRightStatus        : Use right region as focus region of interest
- *  bTopStatus          : Use top region as focus region of interest
- *  bBottomStatus       : Use bottom region as focus region of interest
- *  bTopLeftStatus      : Use top left region as focus region of interest
- *  bTopRightStatus     : Use top right region as focus region of interest
- *  bBottomLeftStatus   : Use bottom left region as focus region of interest
- *  bBottomRightStatus  : Use bottom right region as focus region of interest
- */
-typedef struct OMX_PARAM_FOCUSSTATUSTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_FOCUSSTATUSTYPE eFocusStatus;
-    OMX_BOOL bCenterStatus;
-    OMX_BOOL bLeftStatus;
-    OMX_BOOL bRightStatus;
-    OMX_BOOL bTopStatus;
-    OMX_BOOL bBottomStatus;
-    OMX_BOOL bTopLeftStatus;
-    OMX_BOOL bTopRightStatus;
-    OMX_BOOL bBottomLeftStatus;
-    OMX_BOOL bBottomRightStatus;
-} OMX_PARAM_FOCUSSTATUSTYPE;
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
diff --git a/ilcore/inc/khronos/openmax/include/OMX_Image.h b/ilcore/inc/khronos/openmax/include/OMX_Image.h
deleted file mode 100644
index 599fb2d..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_Image.h
+++ /dev/null
@@ -1,328 +0,0 @@
-/**
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * @file OMX_Image.h - OpenMax IL version 1.1.2
- * The structures needed by Image components to exchange parameters and
- * configuration data with the components.
- */
-#ifndef OMX_Image_h
-#define OMX_Image_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/**
- * Each OMX header must include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-
-#include <OMX_IVCommon.h>
-
-/** @defgroup imaging OpenMAX IL Imaging Domain
- * @ingroup iv
- * Structures for OpenMAX IL Imaging domain
- * @{
- */
-
-/**
- * Enumeration used to define the possible image compression coding.
- */
-typedef enum OMX_IMAGE_CODINGTYPE {
-    OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
-    OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
-    OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
-    OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
-    OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
-    OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
-    OMX_IMAGE_CodingGIF,         /**< Graphics image format */
-    OMX_IMAGE_CodingPNG,         /**< PNG image format */
-    OMX_IMAGE_CodingLZW,         /**< LZW image format */
-    OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
-    OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_IMAGE_CodingMax = 0x7FFFFFFF
-} OMX_IMAGE_CODINGTYPE;
-
-
-/**
- * Data structure used to define an image path. The number of image paths
- * for input and output will vary by type of the image component.
- *
- *  Input (aka Source) : Zero Inputs, one Output,
- *  Splitter           : One Input, 2 or more Outputs,
- *  Processing Element : One Input, one output,
- *  Mixer              : 2 or more inputs, one output,
- *  Output (aka Sink)  : One Input, zero outputs.
- *
- * The PortDefinition structure is used to define all of the parameters
- * necessary for the compliant component to setup an input or an output
- * image path.  If additional vendor specific data is required, it should
- * be transmitted to the component using the CustomCommand function.
- * Compliant components will prepopulate this structure with optimal
- * values during the OMX_GetParameter() command.
- *
- * STRUCT MEMBERS:
- *  cMIMEType             : MIME type of data for the port
- *  pNativeRender         : Platform specific reference for a display if a
- *                          sync, otherwise this field is 0
- *  nFrameWidth           : Width of frame to be used on port if
- *                          uncompressed format is used.  Use 0 for
- *                          unknown, don't care or variable
- *  nFrameHeight          : Height of frame to be used on port if
- *                          uncompressed format is used. Use 0 for
- *                          unknown, don't care or variable
- *  nStride               : Number of bytes per span of an image (i.e.
- *                          indicates the number of bytes to get from
- *                          span N to span N+1, where negative stride
- *                          indicates the image is bottom up
- *  nSliceHeight          : Height used when encoding in slices
- *  bFlagErrorConcealment : Turns on error concealment if it is supported by
- *                          the OMX component
- *  eCompressionFormat    : Compression format used in this instance of
- *                          the component. When OMX_IMAGE_CodingUnused is
- *                          specified, eColorFormat is valid
- *  eColorFormat          : Decompressed format used by this component
- *  pNativeWindow         : Platform specific reference for a window object if a
- *                          display sink , otherwise this field is 0x0.
- */
-typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
-    OMX_STRING cMIMEType;
-    OMX_NATIVE_DEVICETYPE pNativeRender;
-    OMX_U32 nFrameWidth;
-    OMX_U32 nFrameHeight;
-    OMX_S32 nStride;
-    OMX_U32 nSliceHeight;
-    OMX_BOOL bFlagErrorConcealment;
-    OMX_IMAGE_CODINGTYPE eCompressionFormat;
-    OMX_COLOR_FORMATTYPE eColorFormat;
-    OMX_NATIVE_WINDOWTYPE pNativeWindow;
-} OMX_IMAGE_PORTDEFINITIONTYPE;
-
-
-/**
- * Port format parameter.  This structure is used to enumerate the various
- * data input/output format supported by the port.
- *
- * STRUCT MEMBERS:
- *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information
- *  nPortIndex         : Indicates which port to set
- *  nIndex             : Indicates the enumeration index for the format from
- *                       0x0 to N-1
- *  eCompressionFormat : Compression format used in this instance of the
- *                       component. When OMX_IMAGE_CodingUnused is specified,
- *                       eColorFormat is valid
- *  eColorFormat       : Decompressed format used by this component
- */
-typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nIndex;
-    OMX_IMAGE_CODINGTYPE eCompressionFormat;
-    OMX_COLOR_FORMATTYPE eColorFormat;
-} OMX_IMAGE_PARAM_PORTFORMATTYPE;
-
-
-/**
- * Flash control type
- *
- * ENUMS
- *  Torch : Flash forced constantly on
- */
-typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
-    OMX_IMAGE_FlashControlOn = 0,
-    OMX_IMAGE_FlashControlOff,
-    OMX_IMAGE_FlashControlAuto,
-    OMX_IMAGE_FlashControlRedEyeReduction,
-    OMX_IMAGE_FlashControlFillin,
-    OMX_IMAGE_FlashControlTorch,
-    OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_IMAGE_FlashControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
-} OMX_IMAGE_FLASHCONTROLTYPE;
-
-
-/**
- * Flash control configuration
- *
- * STRUCT MEMBERS:
- *  nSize         : Size of the structure in bytes
- *  nVersion      : OMX specification version information
- *  nPortIndex    : Port that this structure applies to
- *  eFlashControl : Flash control type
- */
-typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
-} OMX_IMAGE_PARAM_FLASHCONTROLTYPE;
-
-
-/**
- * Focus control type
- */
-typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
-    OMX_IMAGE_FocusControlOn = 0,
-    OMX_IMAGE_FocusControlOff,
-    OMX_IMAGE_FocusControlAuto,
-    OMX_IMAGE_FocusControlAutoLock,
-    OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_IMAGE_FocusControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
-} OMX_IMAGE_FOCUSCONTROLTYPE;
-
-
-/**
- * Focus control configuration
- *
- * STRUCT MEMBERS:
- *  nSize           : Size of the structure in bytes
- *  nVersion        : OMX specification version information
- *  nPortIndex      : Port that this structure applies to
- *  eFocusControl   : Focus control
- *  nFocusSteps     : Focus can take on values from 0 mm to infinity.
- *                    Interest is only in number of steps over this range.
- *  nFocusStepIndex : Current focus step index
- */
-typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGE_FOCUSCONTROLTYPE eFocusControl;
-    OMX_U32 nFocusSteps;
-    OMX_U32 nFocusStepIndex;
-} OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;
-
-
-/**
- * Q Factor for JPEG compression, which controls the tradeoff between image
- * quality and size.  Q Factor provides a more simple means of controlling
- * JPEG compression quality, without directly programming Quantization
- * tables for chroma and luma
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1
- *               produces the smallest, worst quality images, and a factor
- *               of 100 produces the largest, best quality images.  A
- *               typical default is 75 for small good quality images
- */
-typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nQFactor;
-} OMX_IMAGE_PARAM_QFACTORTYPE;
-
-/**
- * Quantization table type
- */
-
-typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
-    OMX_IMAGE_QuantizationTableLuma = 0,
-    OMX_IMAGE_QuantizationTableChroma,
-    OMX_IMAGE_QuantizationTableChromaCb,
-    OMX_IMAGE_QuantizationTableChromaCr,
-    OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_IMAGE_QuantizationTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
-} OMX_IMAGE_QUANTIZATIONTABLETYPE;
-
-/**
- * JPEG quantization tables are used to determine DCT compression for
- * YUV data, as an alternative to specifying Q factor, providing exact
- * control of compression
- *
- * STRUCT MEMBERS:
- *  nSize                   : Size of the structure in bytes
- *  nVersion                : OMX specification version information
- *  nPortIndex              : Port that this structure applies to
- *  eQuantizationTable      : Quantization table type
- *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored
- *                            in increasing columns then by rows of data (i.e.
- *                            row 1, ... row 8). Quantization values are in
- *                            the range 0-255 and stored in linear order
- *                            (i.e. the component will zig-zag the
- *                            quantization table data if required internally)
- */
-typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGE_QUANTIZATIONTABLETYPE eQuantizationTable;
-    OMX_U8 nQuantizationMatrix[64];
-} OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;
-
-
-/**
- * Huffman table type, the same Huffman table is applied for chroma and
- * luma component
- */
-typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
-    OMX_IMAGE_HuffmanTableAC = 0,
-    OMX_IMAGE_HuffmanTableDC,
-    OMX_IMAGE_HuffmanTableACLuma,
-    OMX_IMAGE_HuffmanTableACChroma,
-    OMX_IMAGE_HuffmanTableDCLuma,
-    OMX_IMAGE_HuffmanTableDCChroma,
-    OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_IMAGE_HuffmanTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
-} OMX_IMAGE_HUFFMANTABLETYPE;
-
-/**
- * JPEG Huffman table
- *
- * STRUCT MEMBERS:
- *  nSize                            : Size of the structure in bytes
- *  nVersion                         : OMX specification version information
- *  nPortIndex                       : Port that this structure applies to
- *  eHuffmanTable                    : Huffman table type
- *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each
- *                                     possible length
- *  nHuffmanTable[256]               : 0-255, the size used for AC and DC
- *                                     HuffmanTable are 16 and 162
- */
-typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
-    OMX_U8 nNumberOfHuffmanCodeOfLength[16];
-    OMX_U8 nHuffmanTable[256];
-}OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
-
-/** @} */
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
diff --git a/ilcore/inc/khronos/openmax/include/OMX_Index.h b/ilcore/inc/khronos/openmax/include/OMX_Index.h
deleted file mode 100644
index 74e8a17..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_Index.h
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** @file OMX_Index.h - OpenMax IL version 1.1.2
- *  The OMX_Index header file contains the definitions for both applications
- *  and components .
- */
-
-
-#ifndef OMX_Index_h
-#define OMX_Index_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/* Each OMX header must include all required header files to allow the
- *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully
- */
-#include <OMX_Types.h>
-
-
-/** The OMX_INDEXTYPE enumeration is used to select a structure when either
- *  getting or setting parameters and/or configuration data.  Each entry in
- *  this enumeration maps to an OMX specified structure.  When the
- *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
- *  are used, the second parameter will always be an entry from this enumeration
- *  and the third entry will be the structure shown in the comments for the entry.
- *  For example, if the application is initializing a cropping function, the
- *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter
- *  and would send a pointer to an initialized OMX_RECTTYPE structure as the
- *  third parameter.
- *
- *  The enumeration entries named with the OMX_Config prefix are sent using
- *  the OMX_SetConfig command and the enumeration entries named with the
- *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
- */
-typedef enum OMX_INDEXTYPE {
-
-    OMX_IndexComponentStartUnused = 0x01000000,
-    OMX_IndexParamPriorityMgmt,             /**< reference: OMX_PRIORITYMGMTTYPE */
-    OMX_IndexParamAudioInit,                /**< reference: OMX_PORT_PARAM_TYPE */
-    OMX_IndexParamImageInit,                /**< reference: OMX_PORT_PARAM_TYPE */
-    OMX_IndexParamVideoInit,                /**< reference: OMX_PORT_PARAM_TYPE */
-    OMX_IndexParamOtherInit,                /**< reference: OMX_PORT_PARAM_TYPE */
-    OMX_IndexParamNumAvailableStreams,      /**< reference: OMX_PARAM_U32TYPE */
-    OMX_IndexParamActiveStream,             /**< reference: OMX_PARAM_U32TYPE */
-    OMX_IndexParamSuspensionPolicy,         /**< reference: OMX_PARAM_SUSPENSIONPOLICYTYPE */
-    OMX_IndexParamComponentSuspended,       /**< reference: OMX_PARAM_SUSPENSIONTYPE */
-    OMX_IndexConfigCapturing,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
-    OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */
-    OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */
-    OMX_IndexParamContentURI,               /**< reference: OMX_PARAM_CONTENTURITYPE */
-    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */
-    OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
-    OMX_IndexConfigMetadataItemCount,       /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
-    OMX_IndexConfigContainerNodeCount,      /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
-    OMX_IndexConfigMetadataItem,            /**< reference: OMX_CONFIG_METADATAITEMTYPE */
-    OMX_IndexConfigCounterNodeID,           /**< reference: OMX_CONFIG_CONTAINERNODEIDTYPE */
-    OMX_IndexParamMetadataFilterType,       /**< reference: OMX_PARAM_METADATAFILTERTYPE */
-    OMX_IndexParamMetadataKeyFilter,        /**< reference: OMX_PARAM_METADATAFILTERTYPE */
-    OMX_IndexConfigPriorityMgmt,            /**< reference: OMX_PRIORITYMGMTTYPE */
-    OMX_IndexParamStandardComponentRole,    /**< reference: OMX_PARAM_COMPONENTROLETYPE */
-
-    OMX_IndexPortStartUnused = 0x02000000,
-    OMX_IndexParamPortDefinition,           /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
-    OMX_IndexParamCompBufferSupplier,       /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE */
-    OMX_IndexReservedStartUnused = 0x03000000,
-
-    /* Audio parameters and configurations */
-    OMX_IndexAudioStartUnused = 0x04000000,
-    OMX_IndexParamAudioPortFormat,          /**< reference: OMX_AUDIO_PARAM_PORTFORMATTYPE */
-    OMX_IndexParamAudioPcm,                 /**< reference: OMX_AUDIO_PARAM_PCMMODETYPE */
-    OMX_IndexParamAudioAac,                 /**< reference: OMX_AUDIO_PARAM_AACPROFILETYPE */
-    OMX_IndexParamAudioRa,                  /**< reference: OMX_AUDIO_PARAM_RATYPE */
-    OMX_IndexParamAudioMp3,                 /**< reference: OMX_AUDIO_PARAM_MP3TYPE */
-    OMX_IndexParamAudioAdpcm,               /**< reference: OMX_AUDIO_PARAM_ADPCMTYPE */
-    OMX_IndexParamAudioG723,                /**< reference: OMX_AUDIO_PARAM_G723TYPE */
-    OMX_IndexParamAudioG729,                /**< reference: OMX_AUDIO_PARAM_G729TYPE */
-    OMX_IndexParamAudioAmr,                 /**< reference: OMX_AUDIO_PARAM_AMRTYPE */
-    OMX_IndexParamAudioWma,                 /**< reference: OMX_AUDIO_PARAM_WMATYPE */
-    OMX_IndexParamAudioSbc,                 /**< reference: OMX_AUDIO_PARAM_SBCTYPE */
-    OMX_IndexParamAudioMidi,                /**< reference: OMX_AUDIO_PARAM_MIDITYPE */
-    OMX_IndexParamAudioGsm_FR,              /**< reference: OMX_AUDIO_PARAM_GSMFRTYPE */
-    OMX_IndexParamAudioMidiLoadUserSound,   /**< reference: OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE */
-    OMX_IndexParamAudioG726,                /**< reference: OMX_AUDIO_PARAM_G726TYPE */
-    OMX_IndexParamAudioGsm_EFR,             /**< reference: OMX_AUDIO_PARAM_GSMEFRTYPE */
-    OMX_IndexParamAudioGsm_HR,              /**< reference: OMX_AUDIO_PARAM_GSMHRTYPE */
-    OMX_IndexParamAudioPdc_FR,              /**< reference: OMX_AUDIO_PARAM_PDCFRTYPE */
-    OMX_IndexParamAudioPdc_EFR,             /**< reference: OMX_AUDIO_PARAM_PDCEFRTYPE */
-    OMX_IndexParamAudioPdc_HR,              /**< reference: OMX_AUDIO_PARAM_PDCHRTYPE */
-    OMX_IndexParamAudioTdma_FR,             /**< reference: OMX_AUDIO_PARAM_TDMAFRTYPE */
-    OMX_IndexParamAudioTdma_EFR,            /**< reference: OMX_AUDIO_PARAM_TDMAEFRTYPE */
-    OMX_IndexParamAudioQcelp8,              /**< reference: OMX_AUDIO_PARAM_QCELP8TYPE */
-    OMX_IndexParamAudioQcelp13,             /**< reference: OMX_AUDIO_PARAM_QCELP13TYPE */
-    OMX_IndexParamAudioEvrc,                /**< reference: OMX_AUDIO_PARAM_EVRCTYPE */
-    OMX_IndexParamAudioSmv,                 /**< reference: OMX_AUDIO_PARAM_SMVTYPE */
-    OMX_IndexParamAudioVorbis,              /**< reference: OMX_AUDIO_PARAM_VORBISTYPE */
-
-    OMX_IndexConfigAudioMidiImmediateEvent, /**< reference: OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE */
-    OMX_IndexConfigAudioMidiControl,        /**< reference: OMX_AUDIO_CONFIG_MIDICONTROLTYPE */
-    OMX_IndexConfigAudioMidiSoundBankProgram, /**< reference: OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE */
-    OMX_IndexConfigAudioMidiStatus,         /**< reference: OMX_AUDIO_CONFIG_MIDISTATUSTYPE */
-    OMX_IndexConfigAudioMidiMetaEvent,      /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE */
-    OMX_IndexConfigAudioMidiMetaEventData,  /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE */
-    OMX_IndexConfigAudioVolume,             /**< reference: OMX_AUDIO_CONFIG_VOLUMETYPE */
-    OMX_IndexConfigAudioBalance,            /**< reference: OMX_AUDIO_CONFIG_BALANCETYPE */
-    OMX_IndexConfigAudioChannelMute,        /**< reference: OMX_AUDIO_CONFIG_CHANNELMUTETYPE */
-    OMX_IndexConfigAudioMute,               /**< reference: OMX_AUDIO_CONFIG_MUTETYPE */
-    OMX_IndexConfigAudioLoudness,           /**< reference: OMX_AUDIO_CONFIG_LOUDNESSTYPE */
-    OMX_IndexConfigAudioEchoCancelation,    /**< reference: OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE */
-    OMX_IndexConfigAudioNoiseReduction,     /**< reference: OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE */
-    OMX_IndexConfigAudioBass,               /**< reference: OMX_AUDIO_CONFIG_BASSTYPE */
-    OMX_IndexConfigAudioTreble,             /**< reference: OMX_AUDIO_CONFIG_TREBLETYPE */
-    OMX_IndexConfigAudioStereoWidening,     /**< reference: OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE */
-    OMX_IndexConfigAudioChorus,             /**< reference: OMX_AUDIO_CONFIG_CHORUSTYPE */
-    OMX_IndexConfigAudioEqualizer,          /**< reference: OMX_AUDIO_CONFIG_EQUALIZERTYPE */
-    OMX_IndexConfigAudioReverberation,      /**< reference: OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
-    OMX_IndexConfigAudioChannelVolume,      /**< reference: OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */
-
-    /* Image specific parameters and configurations */
-    OMX_IndexImageStartUnused = 0x05000000,
-    OMX_IndexParamImagePortFormat,          /**< reference: OMX_IMAGE_PARAM_PORTFORMATTYPE */
-    OMX_IndexParamFlashControl,             /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
-    OMX_IndexConfigFocusControl,            /**< reference: OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE */
-    OMX_IndexParamQFactor,                  /**< reference: OMX_IMAGE_PARAM_QFACTORTYPE */
-    OMX_IndexParamQuantizationTable,        /**< reference: OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
-    OMX_IndexParamHuffmanTable,             /**< reference: OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
-    OMX_IndexConfigFlashControl,            /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
-
-    /* Video specific parameters and configurations */
-    OMX_IndexVideoStartUnused = 0x06000000,
-    OMX_IndexParamVideoPortFormat,          /**< reference: OMX_VIDEO_PARAM_PORTFORMATTYPE */
-    OMX_IndexParamVideoQuantization,        /**< reference: OMX_VIDEO_PARAM_QUANTIZATIONTYPE */
-    OMX_IndexParamVideoFastUpdate,          /**< reference: OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE */
-    OMX_IndexParamVideoBitrate,             /**< reference: OMX_VIDEO_PARAM_BITRATETYPE */
-    OMX_IndexParamVideoMotionVector,        /**< reference: OMX_VIDEO_PARAM_MOTIONVECTORTYPE */
-    OMX_IndexParamVideoIntraRefresh,        /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
-    OMX_IndexParamVideoErrorCorrection,     /**< reference: OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE */
-    OMX_IndexParamVideoVBSMC,               /**< reference: OMX_VIDEO_PARAM_VBSMCTYPE */
-    OMX_IndexParamVideoMpeg2,               /**< reference: OMX_VIDEO_PARAM_MPEG2TYPE */
-    OMX_IndexParamVideoMpeg4,               /**< reference: OMX_VIDEO_PARAM_MPEG4TYPE */
-    OMX_IndexParamVideoWmv,                 /**< reference: OMX_VIDEO_PARAM_WMVTYPE */
-    OMX_IndexParamVideoRv,                  /**< reference: OMX_VIDEO_PARAM_RVTYPE */
-    OMX_IndexParamVideoAvc,                 /**< reference: OMX_VIDEO_PARAM_AVCTYPE */
-    OMX_IndexParamVideoH263,                /**< reference: OMX_VIDEO_PARAM_H263TYPE */
-    OMX_IndexParamVideoProfileLevelQuerySupported, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
-    OMX_IndexParamVideoProfileLevelCurrent, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
-    OMX_IndexConfigVideoBitrate,            /**< reference: OMX_VIDEO_CONFIG_BITRATETYPE */
-    OMX_IndexConfigVideoFramerate,          /**< reference: OMX_CONFIG_FRAMERATETYPE */
-    OMX_IndexConfigVideoIntraVOPRefresh,    /**< reference: OMX_CONFIG_INTRAREFRESHVOPTYPE */
-    OMX_IndexConfigVideoIntraMBRefresh,     /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
-    OMX_IndexConfigVideoMBErrorReporting,   /**< reference: OMX_CONFIG_MBERRORREPORTINGTYPE */
-    OMX_IndexParamVideoMacroblocksPerFrame, /**< reference: OMX_PARAM_MACROBLOCKSTYPE */
-    OMX_IndexConfigVideoMacroBlockErrorMap, /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
-    OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
-    OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
-    OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */
-
-    /* Image & Video common Configurations */
-    OMX_IndexCommonStartUnused = 0x07000000,
-    OMX_IndexParamCommonDeblocking,         /**< reference: OMX_PARAM_DEBLOCKINGTYPE */
-    OMX_IndexParamCommonSensorMode,         /**< reference: OMX_PARAM_SENSORMODETYPE */
-    OMX_IndexParamCommonInterleave,         /**< reference: OMX_PARAM_INTERLEAVETYPE */
-    OMX_IndexConfigCommonColorFormatConversion, /**< reference: OMX_CONFIG_COLORCONVERSIONTYPE */
-    OMX_IndexConfigCommonScale,             /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
-    OMX_IndexConfigCommonImageFilter,       /**< reference: OMX_CONFIG_IMAGEFILTERTYPE */
-    OMX_IndexConfigCommonColorEnhancement,  /**< reference: OMX_CONFIG_COLORENHANCEMENTTYPE */
-    OMX_IndexConfigCommonColorKey,          /**< reference: OMX_CONFIG_COLORKEYTYPE */
-    OMX_IndexConfigCommonColorBlend,        /**< reference: OMX_CONFIG_COLORBLENDTYPE */
-    OMX_IndexConfigCommonFrameStabilisation,/**< reference: OMX_CONFIG_FRAMESTABTYPE */
-    OMX_IndexConfigCommonRotate,            /**< reference: OMX_CONFIG_ROTATIONTYPE */
-    OMX_IndexConfigCommonMirror,            /**< reference: OMX_CONFIG_MIRRORTYPE */
-    OMX_IndexConfigCommonOutputPosition,    /**< reference: OMX_CONFIG_POINTTYPE */
-    OMX_IndexConfigCommonInputCrop,         /**< reference: OMX_CONFIG_RECTTYPE */
-    OMX_IndexConfigCommonOutputCrop,        /**< reference: OMX_CONFIG_RECTTYPE */
-    OMX_IndexConfigCommonDigitalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
-    OMX_IndexConfigCommonOpticalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE*/
-    OMX_IndexConfigCommonWhiteBalance,      /**< reference: OMX_CONFIG_WHITEBALCONTROLTYPE */
-    OMX_IndexConfigCommonExposure,          /**< reference: OMX_CONFIG_EXPOSURECONTROLTYPE */
-    OMX_IndexConfigCommonContrast,          /**< reference: OMX_CONFIG_CONTRASTTYPE */
-    OMX_IndexConfigCommonBrightness,        /**< reference: OMX_CONFIG_BRIGHTNESSTYPE */
-    OMX_IndexConfigCommonBacklight,         /**< reference: OMX_CONFIG_BACKLIGHTTYPE */
-    OMX_IndexConfigCommonGamma,             /**< reference: OMX_CONFIG_GAMMATYPE */
-    OMX_IndexConfigCommonSaturation,        /**< reference: OMX_CONFIG_SATURATIONTYPE */
-    OMX_IndexConfigCommonLightness,         /**< reference: OMX_CONFIG_LIGHTNESSTYPE */
-    OMX_IndexConfigCommonExclusionRect,     /**< reference: OMX_CONFIG_RECTTYPE */
-    OMX_IndexConfigCommonDithering,         /**< reference: OMX_CONFIG_DITHERTYPE */
-    OMX_IndexConfigCommonPlaneBlend,        /**< reference: OMX_CONFIG_PLANEBLENDTYPE */
-    OMX_IndexConfigCommonExposureValue,     /**< reference: OMX_CONFIG_EXPOSUREVALUETYPE */
-    OMX_IndexConfigCommonOutputSize,        /**< reference: OMX_FRAMESIZETYPE */
-    OMX_IndexParamCommonExtraQuantData,     /**< reference: OMX_OTHER_EXTRADATATYPE */
-    OMX_IndexConfigCommonFocusRegion,       /**< reference: OMX_CONFIG_FOCUSREGIONTYPE */
-    OMX_IndexConfigCommonFocusStatus,       /**< reference: OMX_PARAM_FOCUSSTATUSTYPE */
-    OMX_IndexConfigCommonTransitionEffect,  /**< reference: OMX_CONFIG_TRANSITIONEFFECTTYPE */
-
-    /* Reserved Configuration range */
-    OMX_IndexOtherStartUnused = 0x08000000,
-    OMX_IndexParamOtherPortFormat,          /**< reference: OMX_OTHER_PARAM_PORTFORMATTYPE */
-    OMX_IndexConfigOtherPower,              /**< reference: OMX_OTHER_CONFIG_POWERTYPE */
-    OMX_IndexConfigOtherStats,              /**< reference: OMX_OTHER_CONFIG_STATSTYPE */
-
-
-    /* Reserved Time range */
-    OMX_IndexTimeStartUnused = 0x09000000,
-    OMX_IndexConfigTimeScale,               /**< reference: OMX_TIME_CONFIG_SCALETYPE */
-    OMX_IndexConfigTimeClockState,          /**< reference: OMX_TIME_CONFIG_CLOCKSTATETYPE */
-    OMX_IndexConfigTimeActiveRefClock,      /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
-    OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
-    OMX_IndexConfigTimeCurrentWallTime,     /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
-    OMX_IndexConfigTimeCurrentAudioReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
-    OMX_IndexConfigTimeCurrentVideoReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
-    OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
-    OMX_IndexConfigTimeClientStartTime,     /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
-    OMX_IndexConfigTimePosition,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
-    OMX_IndexConfigTimeSeekMode,            /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */
-
-
-    OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    /* Vendor specific area */
-    OMX_IndexVendorStartUnused = 0x7F000000,
-    OMX_IndexIntelPrivateInfo,
-    /* Vendor specific structures should be in the range of 0x7F000000
-       to 0x7FFFFFFE.  This range is not broken out by vendor, so
-       private indexes are not guaranteed unique and therefore should
-       only be sent to the appropriate component. */
-
-    OMX_IndexMax = 0x7FFFFFFF
-
-} OMX_INDEXTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
diff --git a/ilcore/inc/khronos/openmax/include/OMX_IndexExt.h b/ilcore/inc/khronos/openmax/include/OMX_IndexExt.h
deleted file mode 100644
index b9ad3fa..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_IndexExt.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** @file OMX_IndexExt.h - OpenMax IL version 1.1.2
- * The OMX_IndexExt header file contains extensions to the definitions
- * for both applications and components .
- */
-
-#ifndef OMX_IndexExt_h
-#define OMX_IndexExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header shall include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-#include <OMX_Index.h>
-
-
-/** Khronos standard extension indices.
-
-This enum lists the current Khronos extension indices to OpenMAX IL.
-*/
-typedef enum OMX_INDEXEXTTYPE {
-
-    /* Component parameters and configurations */
-    OMX_IndexExtComponentStartUnused = OMX_IndexKhronosExtensions + 0x00100000,
-    OMX_IndexConfigCallbackRequest,                 /**< reference: OMX_CONFIG_CALLBACKREQUESTTYPE */
-    OMX_IndexConfigCommitMode,                      /**< reference: OMX_CONFIG_COMMITMODETYPE */
-    OMX_IndexConfigCommit,                          /**< reference: OMX_CONFIG_COMMITTYPE */
-
-    /* Port parameters and configurations */
-    OMX_IndexExtPortStartUnused = OMX_IndexKhronosExtensions + 0x00200000,
-
-    /* Audio parameters and configurations */
-    OMX_IndexExtAudioStartUnused = OMX_IndexKhronosExtensions + 0x00400000,
-
-    /* Image parameters and configurations */
-    OMX_IndexExtImageStartUnused = OMX_IndexKhronosExtensions + 0x00500000,
-
-    /* Video parameters and configurations */
-    OMX_IndexExtVideoStartUnused = OMX_IndexKhronosExtensions + 0x00600000,
-    OMX_IndexParamNalStreamFormatSupported,         /**< reference: OMX_NALSTREAMFORMATTYPE */
-    OMX_IndexParamNalStreamFormat,                  /**< reference: OMX_NALSTREAMFORMATTYPE */
-    OMX_IndexParamNalStreamFormatSelect,            /**< reference: OMX_NALSTREAMFORMATTYPE */
-    OMX_IndexParamVideoBytestream,                  /**< reference: OMX_VIDEO_PARAM_BYTESTREAMTYPE */
-    OMX_IndexParamIntelBitrate,                     /**< reference: OMX_VIDEO_PARAM_INTEL_BITRATETYPE */
-    OMX_IndexConfigIntelBitrate,                    /**< reference: OMX_VIDEO_CONFIG_INTEL_BITRATETYPE */
-    OMX_IndexParamIntelAVCDecodeSettings,           /**< reference: OMX_VIDEO_PARAM_INTEL_AVC_DECODE_SETTINGS */
-    OMX_IndexConfigIntelSliceNumbers,               /**< reference: OMX_VIDEO_CONFIG_INTEL_SLICE_NUMBERS */
-    OMX_IndexConfigIntelAIR,                         /**< reference: OMX_VIDEO_CONFIG_INTEL_AIR */
-    OMX_IndexParamGoogleNativeBuffers,               /**< reference: EnableAndroidNativeBuffersParams in Android */
-    OMX_IndexParamGoogleNativeBufferUsage,           /**< reference: GetAndroidNativeBufferUsageParams */
-    OMX_IndexParamGoogleMetaDataInBuffers,
-    OMX_IndexParamGoogleThumbNail,
-    OMX_IndexParamIntelXDisplay,                      /**< reference: OMX_VIDEO_PARAM_X_DISPLAY */
-    OMX_IndexParamIntelGlxPictures,                      /**< reference: OMX_VIDEO_PARAM_GLX_PICTURES */
-    /* Image & Video common configurations */
-    OMX_IndexExtCommonStartUnused = OMX_IndexKhronosExtensions + 0x00700000,
-
-    /* Other configurations */
-    OMX_IndexExtOtherStartUnused = OMX_IndexKhronosExtensions + 0x00800000,
-
-    /* Time configurations */
-    OMX_IndexExtTimeStartUnused = OMX_IndexKhronosExtensions + 0x00900000,
-
-    OMX_IndexExtMax = 0x7FFFFFFF
-} OMX_INDEXEXTTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_IndexExt_h */
-/* File EOF */
diff --git a/ilcore/inc/khronos/openmax/include/OMX_IntelErrorTypes.h b/ilcore/inc/khronos/openmax/include/OMX_IntelErrorTypes.h
deleted file mode 100644
index a2af96a..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_IntelErrorTypes.h
+++ /dev/null
@@ -1,24 +0,0 @@
-#ifndef OMX_IntelErrorTypes_h
-#define OMX_IntelErrorTypes_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#include <OMX_Core.h>
-
-typedef enum OMX_INTELERRORTYPE
-{
-      OMX_ErrorIntelExtSliceSizeOverflow = OMX_ErrorVendorStartUnused + (OMX_S32)0x00001001,
-      OMX_ErrorIntelVideoNotPermitted    = OMX_ErrorVendorStartUnused + (OMX_S32)0x00001002,
-      OMX_ErrorIntelProcessStream        = OMX_ErrorVendorStartUnused + (OMX_S32)0x00001003,
-      OMX_ErrorIntelMissingConfig        = OMX_ErrorVendorStartUnused + (OMX_S32)0x00001004,
-
-} OMX_INTELERRORTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
-
diff --git a/ilcore/inc/khronos/openmax/include/OMX_Other.h b/ilcore/inc/khronos/openmax/include/OMX_Other.h
deleted file mode 100644
index a3abbec..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_Other.h
+++ /dev/null
@@ -1,337 +0,0 @@
-/*
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** @file OMX_Other.h - OpenMax IL version 1.1.2
- *  The structures needed by Other components to exchange
- *  parameters and configuration data with the components.
- */
-
-#ifndef OMX_Other_h
-#define OMX_Other_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/* Each OMX header must include all required header files to allow the
- *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully
- */
-
-#include <OMX_Core.h>
-
-
-/**
- * Enumeration of possible data types which match to multiple domains or no
- * domain at all.  For types which are vendor specific, a value above
- * OMX_OTHER_VENDORTSTART should be used.
- */
-typedef enum OMX_OTHER_FORMATTYPE {
-    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time,
-                                   time deltas, etc */
-    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power
-                                   management, setting clocks? */
-    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames
-                                   dropped, etc */
-    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
-    OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific
-                                                formats */
-
-    OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_OTHER_FormatMax = 0x7FFFFFFF
-} OMX_OTHER_FORMATTYPE;
-
-/**
- * Enumeration of seek modes.
- */
-typedef enum OMX_TIME_SEEKMODETYPE {
-    OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
-                                * of the requested seek position over
-                                * the actual seek position if it
-                                * results in a faster seek. */
-    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek
-                                * position over an approximation
-                                * of the requested seek position even
-                                * if it results in a slower seek. */
-    OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_TIME_SeekModeMax = 0x7FFFFFFF
-} OMX_TIME_SEEKMODETYPE;
-
-/* Structure representing the seekmode of the component */
-typedef struct OMX_TIME_CONFIG_SEEKMODETYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
-} OMX_TIME_CONFIG_SEEKMODETYPE;
-
-/** Structure representing a time stamp used with the following configs
- * on the Clock Component (CC):
- *
- * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall
- *     time
- * OMX_IndexConfigTimeCurrentMediaTime: query of the CCs current media
- *     time
- * OMX_IndexConfigTimeCurrentAudioReference and
- * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference
- *     clock sending SC its reference time
- * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends
- *     this structure to the Clock Component via a SetConfig on its
- *     client port when it receives a buffer with
- *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
- *     specified by that buffer for nStartTimestamp.
- *
- * Its also used with the following config on components in general:
- *
- * OMX_IndexConfigTimePosition: IL client querying component position
- * (GetConfig) or commanding a component to seek to the given location
- * (SetConfig)
- */
-typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
-    OMX_U32 nSize;               /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;    /**< OMX specification version
-                                  *   information */
-    OMX_U32 nPortIndex;     /**< port that this structure applies to */
-    OMX_TICKS nTimestamp;  	     /**< timestamp .*/
-} OMX_TIME_CONFIG_TIMESTAMPTYPE;
-
-/** Enumeration of possible reference clocks to the media time. */
-typedef enum OMX_TIME_UPDATETYPE {
-      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
-      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
-      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
-      OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-      OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-      OMX_TIME_UpdateMax = 0x7FFFFFFF
-} OMX_TIME_UPDATETYPE;
-
-/** Enumeration of possible reference clocks to the media time. */
-typedef enum OMX_TIME_REFCLOCKTYPE {
-      OMX_TIME_RefClockNone,    /**< Use no references. */
-      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
-      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
-      OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-      OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-      OMX_TIME_RefClockMax = 0x7FFFFFFF
-} OMX_TIME_REFCLOCKTYPE;
-
-/** Enumeration of clock states. */
-typedef enum OMX_TIME_CLOCKSTATE {
-      OMX_TIME_ClockStateRunning,             /**< Clock running. */
-      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the
-                                               *   prescribed clients emit their
-                                               *   start time. */
-      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
-      OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-      OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-      OMX_TIME_ClockStateMax = 0x7FFFFFFF
-} OMX_TIME_CLOCKSTATE;
-
-/** Structure representing a media time request to the clock component.
- *
- *  A client component sends this structure to the Clock Component via a SetConfig
- *  on its client port to specify a media timestamp the Clock Component
- *  should emit.  The Clock Component should fulfill the request by sending a
- *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested
- *  timestamp.
- *
- *  The client may require a media time request be fulfilled slightly
- *  earlier than the media time specified. In this case the client specifies
- *  an offset which is equal to the difference between wall time corresponding
- *  to the requested media time and the wall time when it will be
- *  fulfilled.
- *
- *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
- *  time events according to timestamps. If a client must perform an operation O at
- *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a
- *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
- *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
- *  structure back to the client component, the client may perform operation O (perhaps having
- *  to wait a slight amount more time itself as specified by the return values).
- */
-
-typedef struct OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time
-                                 *   from others (e.g. the number of the frame to deliver).
-                                 *   Duplicated in the media time structure that fulfills
-                                 *   this request. A value of zero is reserved for time scale
-                                 *   updates. */
-    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/
-    OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
-                                 *   request should be fulfilled early */
-} OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;
-
-/**< Structure sent from the clock component client either when fulfilling
- *   a media time request or when the time scale has changed.
- *
- *   In the former case the Clock Component fills this structure and times its emission
- *   to a client component (via the client port) according to the corresponding media
- *   time request sent by the client. The Clock Component should time the emission to occur
- *   when the requested timestamp matches the Clock Component's media time but also the
- *   prescribed offset early.
- *
- *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
- *   media time and sets the nScale to the new scale via the client port. It emits a
- *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to
- *   alter processing to accomodate scaling. For instance a video component might skip inter-frames
- *   in the case of extreme fastforward. Likewise an audio component might add or remove samples
- *   from an audio frame to scale audio data.
- *
- *   It is expected that some clock components may not be able to fulfill requests
- *   at exactly the prescribed time. This is acceptable so long as the request is
- *   fulfilled at least as early as described and not later. This structure provides
- *   fields the client may use to wait for the remaining time.
- *
- *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the
- *   wall time until the nMediaTimestamp actually occurs. In the latter case the
- *   client can get a more accurate value for offset by getting the current wall
- *   from the cloc component and subtracting it from nWallTimeAtMedia.
- */
-
-typedef struct OMX_TIME_MEDIATIMETYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time
-                                     *   from others. Copied from the media time request.
-                                     *   A value of zero is reserved for time scale updates. */
-    OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
-    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was
-                                     *   requested then this is the current media time. */
-    OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
-                                     *   request was actually fulfilled early */
-
-    OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
-                                     *   A client may compare this value to current
-                                     *   media time obtained from the Clock Component to determine
-                                     *   the wall time until the media timestamp is really
-                                     *   current. */
-    OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
-    OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
-                                    /**< State of the media time. */
-} OMX_TIME_MEDIATIMETYPE;
-
-/** Structure representing the current media time scale factor. Applicable only to clock
- *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
- *  the clock component client ports. Upon recieving this config the clock component changes
- *  the rate by which the media time increases or decreases effectively implementing trick modes.
- */
-typedef struct OMX_TIME_CONFIG_SCALETYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
-                                     * scaling the media time */
-} OMX_TIME_CONFIG_SCALETYPE;
-
-/** Bits used to identify a clock port. Used in OMX_TIME_CONFIG_CLOCKSTATETYPEs nWaitMask field */
-#define OMX_CLOCKPORT0 0x00000001
-#define OMX_CLOCKPORT1 0x00000002
-#define OMX_CLOCKPORT2 0x00000004
-#define OMX_CLOCKPORT3 0x00000008
-#define OMX_CLOCKPORT4 0x00000010
-#define OMX_CLOCKPORT5 0x00000020
-#define OMX_CLOCKPORT6 0x00000040
-#define OMX_CLOCKPORT7 0x00000080
-
-/** Structure representing the current mode of the media clock.
- *  IL Client uses this config to change or query the mode of the
- *  media clock of the clock component. Applicable only to clock
- *  component.
- *
- *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
- *  starts immediately at the prescribed start time. If
- *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
- *  the given nStartTime and waits for all clients specified in the
- *  nWaitMask to send starttimes (via
- *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts
- *  the media clock using the earliest start time supplied. */
-typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version
-                                 *   information */
-    OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
-    OMX_TICKS nStartTime;       /**< Start time of the media time. */
-    OMX_TICKS nOffset;          /**< Time to offset the media time by
-                                 * (e.g. preroll). Media time will be
-                                 * reported to be nOffset ticks earlier.
-                                 */
-    OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
-} OMX_TIME_CONFIG_CLOCKSTATETYPE;
-
-/** Structure representing the reference clock currently being used to
- *  compute media time. IL client uses this config to change or query the
- *  clock component's active reference clock */
-typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
-    OMX_U32 nSize;                  /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */
-} OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;
-
-/** Descriptor for setting specifics of power type.
- *  Note: this structure is listed for backwards compatibility. */
-typedef struct OMX_OTHER_CONFIG_POWERTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
-} OMX_OTHER_CONFIG_POWERTYPE;
-
-
-/** Descriptor for setting specifics of stats type.
- *  Note: this structure is listed for backwards compatibility. */
-typedef struct OMX_OTHER_CONFIG_STATSTYPE {
-    OMX_U32 nSize;            /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    /* what goes here */
-} OMX_OTHER_CONFIG_STATSTYPE;
-
-
-/**
- * The PortDefinition structure is used to define all of the parameters
- * necessary for the compliant component to setup an input or an output other
- * path.
- */
-typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
-    OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
-} OMX_OTHER_PORTDEFINITIONTYPE;
-
-/**  Port format parameter.  This structure is used to enumerate
-  *  the various data input/output format supported by the port.
-  */
-typedef struct OMX_OTHER_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize; /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
-    OMX_U32 nPortIndex; /**< Indicates which port to set */
-    OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
-    OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
-} OMX_OTHER_PARAM_PORTFORMATTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
diff --git a/ilcore/inc/khronos/openmax/include/OMX_Types.h b/ilcore/inc/khronos/openmax/include/OMX_Types.h
deleted file mode 100644
index 264532d..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_Types.h
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_Types.h - OpenMax IL version 1.1.2
- *  The OMX_Types header file contains the primitive type definitions used by
- *  the core, the application and the component.  This file may need to be
- *  modified to be used on systems that do not have "char" set to 8 bits,
- *  "short" set to 16 bits and "long" set to 32 bits.
- */
-
-#ifndef OMX_Types_h
-#define OMX_Types_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/** The OMX_API and OMX_APIENTRY are platform specific definitions used
- *  to declare OMX function prototypes.  They are modified to meet the
- *  requirements for a particular platform */
-#ifdef __SYMBIAN32__
-#   ifdef __OMX_EXPORTS
-#       define OMX_API __declspec(dllexport)
-#   else
-#       ifdef _WIN32
-#           define OMX_API __declspec(dllexport)
-#       else
-#           define OMX_API __declspec(dllimport)
-#       endif
-#   endif
-#else
-#   ifdef _WIN32
-#      ifdef __OMX_EXPORTS
-#          define OMX_API __declspec(dllexport)
-#      else
-#          define OMX_API __declspec(dllimport)
-#      endif
-#   else
-#      ifdef __OMX_EXPORTS
-#          define OMX_API
-#      else
-#          define OMX_API extern
-#      endif
-#   endif
-#endif
-
-#ifndef OMX_APIENTRY
-#define OMX_APIENTRY
-#endif
-
-/** OMX_IN is used to identify inputs to an OMX function.  This designation
-    will also be used in the case of a pointer that points to a parameter
-    that is used as an output. */
-#ifndef OMX_IN
-#define OMX_IN
-#endif
-
-/** OMX_OUT is used to identify outputs from an OMX function.  This
-    designation will also be used in the case of a pointer that points
-    to a parameter that is used as an input. */
-#ifndef OMX_OUT
-#define OMX_OUT
-#endif
-
-
-/** OMX_INOUT is used to identify parameters that may be either inputs or
-    outputs from an OMX function at the same time.  This designation will
-    also be used in the case of a pointer that  points to a parameter that
-    is used both as an input and an output. */
-#ifndef OMX_INOUT
-#define OMX_INOUT
-#endif
-
-/** OMX_ALL is used to as a wildcard to select all entities of the same type
- *  when specifying the index, or referring to a object by an index.  (i.e.
- *  use OMX_ALL to indicate all N channels). When used as a port index
- *  for a config or parameter this OMX_ALL denotes that the config or
- *  parameter applies to the entire component not just one port. */
-#define OMX_ALL 0xFFFFFFFF
-
-/** In the following we define groups that help building doxygen documentation */
-
-/** @defgroup core OpenMAX IL core
- * Functions and structure related to the OMX IL core
- */
-
- /** @defgroup comp OpenMAX IL component
- * Functions and structure related to the OMX IL component
- */
-
-/** @defgroup rpm Resource and Policy Management
- * Structures for resource and policy management of components
- */
-
-/** @defgroup buf Buffer Management
- * Buffer handling functions and structures
- */
-
-/** @defgroup tun Tunneling
- * @ingroup core comp
- * Structures and functions to manage tunnels among component ports
- */
-
-/** @defgroup cp Content Pipes
- *  @ingroup core
- */
-
- /** @defgroup metadata Metadata handling
-  *
-  */
-
-/** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
-typedef unsigned char OMX_U8;
-
-/** OMX_S8 is an 8 bit signed quantity that is byte aligned */
-typedef signed char OMX_S8;
-
-/** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
-typedef unsigned short OMX_U16;
-
-/** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
-typedef signed short OMX_S16;
-
-/** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
-typedef unsigned long OMX_U32;
-
-/** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
-typedef signed long OMX_S32;
-
-
-/* Users with compilers that cannot accept the "long long" designation should
-   define the OMX_SKIP64BIT macro.  It should be noted that this may cause
-   some components to fail to compile if the component was written to require
-   64 bit integral types.  However, these components would NOT compile anyway
-   since the compiler does not support the way the component was written.
-*/
-#ifndef OMX_SKIP64BIT
-#ifdef __SYMBIAN32__
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
-typedef unsigned long long OMX_U64;
-
-/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
-typedef signed long long OMX_S64;
-
-#elif defined(WIN32)
-
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
-typedef unsigned __int64  OMX_U64;
-
-/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
-typedef signed   __int64  OMX_S64;
-
-#else /* WIN32 */
-
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
-typedef unsigned long long OMX_U64;
-
-/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
-typedef signed long long OMX_S64;
-
-#endif /* WIN32 */
-#endif
-
-
-/** The OMX_BOOL type is intended to be used to represent a true or a false
-    value when passing parameters to and from the OMX core and components.  The
-    OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
- */
-typedef enum OMX_BOOL {
-    OMX_FALSE = 0,
-    OMX_TRUE = !OMX_FALSE,
-    OMX_BOOL_MAX = 0x7FFFFFFF
-} OMX_BOOL;
-
-/** The OMX_PTR type is intended to be used to pass pointers between the OMX
-    applications and the OMX Core and components.  This is a 32 bit pointer and
-    is aligned on a 32 bit boundary.
- */
-typedef void* OMX_PTR;
-
-/** The OMX_STRING type is intended to be used to pass "C" type strings between
-    the application and the core and component.  The OMX_STRING type is a 32
-    bit pointer to a zero terminated string.  The  pointer is word aligned and
-    the string is byte aligned.
- */
-typedef char* OMX_STRING;
-
-/** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
-    buffers between the application and the component and core.  The OMX_BYTE
-    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
-    aligned and the string is byte aligned.
- */
-typedef unsigned char* OMX_BYTE;
-
-/** OMX_UUIDTYPE is a very long unique identifier to uniquely identify
-    at runtime.  This identifier should be generated by a component in a way
-    that guarantees that every instance of the identifier running on the system
-    is unique. */
-typedef unsigned char OMX_UUIDTYPE[128];
-
-/** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
-    an output port.  This enumeration is common across all component types.
- */
-typedef enum OMX_DIRTYPE
-{
-    OMX_DirInput,              /**< Port is an input port */
-    OMX_DirOutput,             /**< Port is an output port */
-    OMX_DirMax = 0x7FFFFFFF
-} OMX_DIRTYPE;
-
-/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering
-    for numerical data (i.e. big endian, or little endian).
- */
-typedef enum OMX_ENDIANTYPE
-{
-    OMX_EndianBig, /**< big endian */
-    OMX_EndianLittle, /**< little endian */
-    OMX_EndianMax = 0x7FFFFFFF
-} OMX_ENDIANTYPE;
-
-
-/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data
-    is signed or unsigned
- */
-typedef enum OMX_NUMERICALDATATYPE
-{
-    OMX_NumericalDataSigned, /**< signed data */
-    OMX_NumericalDataUnsigned, /**< unsigned data */
-    OMX_NumercialDataMax = 0x7FFFFFFF
-} OMX_NUMERICALDATATYPE;
-
-
-/** Unsigned bounded value type */
-typedef struct OMX_BU32 {
-    OMX_U32 nValue; /**< actual value */
-    OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
-    OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
-} OMX_BU32;
-
-
-/** Signed bounded value type */
-typedef struct OMX_BS32 {
-    OMX_S32 nValue; /**< actual value */
-    OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
-    OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
-} OMX_BS32;
-
-
-/** Structure representing some time or duration in microseconds. This structure
-  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate
-  *  negative deltas and preroll scenarios. The quantity is represented in microseconds
-  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
-  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g.
-  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to
-  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
-  *  or minus 35 minutes).
-  *
-  *  Implementations with limited precision may convert the signed 64 bit value to
-  *  a signed 32 bit value internally but risk loss of precision.
-  */
-#ifndef OMX_SKIP64BIT
-typedef OMX_S64 OMX_TICKS;
-#else
-typedef struct OMX_TICKS
-{
-    OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
-    OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
-} OMX_TICKS;
-#endif
-#define OMX_TICKS_PER_SECOND 1000000
-
-/** Define the public interface for the OMX Handle.  The core will not use
-    this value internally, but the application should only use this value.
- */
-typedef void* OMX_HANDLETYPE;
-
-typedef struct OMX_MARKTYPE
-{
-    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will
-                                                generate a mark event upon
-                                                processing the mark. */
-    OMX_PTR pMarkData;   /**< Application specific data associated with
-                              the mark sent on a mark event to disambiguate
-                              this mark from others. */
-} OMX_MARKTYPE;
-
-
-/** OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
- *  platform & operating specific object used to reference the display
- *  or can be used by a audio port for native audio rendering */
-typedef void* OMX_NATIVE_DEVICETYPE;
-
-/** OMX_NATIVE_WINDOWTYPE is used to map a OMX video port to the
- *  platform & operating specific object used to reference the window */
-typedef void* OMX_NATIVE_WINDOWTYPE;
-
-/** The OMX_VERSIONTYPE union is used to specify the version for
-    a structure or component.  For a component, the version is entirely
-    specified by the component vendor.  Components doing the same function
-    from different vendors may or may not have the same version.  For
-    structures, the version shall be set by the entity that allocates the
-    structure.  For structures specified in the OMX 1.1 specification, the
-    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
-    OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
-    by accessing one of the structure elements to, for example, check only
-    the Major revision.
- */
-typedef union OMX_VERSIONTYPE
-{
-    struct
-    {
-        OMX_U8 nVersionMajor;   /**< Major version accessor element */
-        OMX_U8 nVersionMinor;   /**< Minor version accessor element */
-        OMX_U8 nRevision;       /**< Revision version accessor element */
-        OMX_U8 nStep;           /**< Step version accessor element */
-    } s;
-    OMX_U32 nVersion;           /**< 32 bit value to make accessing the
-                                    version easily done in a single word
-                                    size copy/compare operation */
-} OMX_VERSIONTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
diff --git a/ilcore/inc/khronos/openmax/include/OMX_Video.h b/ilcore/inc/khronos/openmax/include/OMX_Video.h
deleted file mode 100644
index caf6048..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_Video.h
+++ /dev/null
@@ -1,1079 +0,0 @@
-/**
- * Copyright (c) 2008 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/**
- *  @file OMX_Video.h - OpenMax IL version 1.1.2
- *  The structures is needed by Video components to exchange parameters
- *  and configuration data with OMX components.
- */
-#ifndef OMX_Video_h
-#define OMX_Video_h
-
-/** @defgroup video OpenMAX IL Video Domain
- * @ingroup iv
- * Structures for OpenMAX IL Video domain
- * @{
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-
-/**
- * Each OMX header must include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-
-#include <OMX_IVCommon.h>
-
-
-/**
- * Enumeration used to define the possible video compression codings.
- * NOTE:  This essentially refers to file extensions. If the coding is
- *        being used to specify the ENCODE type, then additional work
- *        must be done to configure the exact flavor of the compression
- *        to be used.  For decode cases where the user application can
- *        not differentiate between MPEG-4 and H.264 bit streams, it is
- *        up to the codec to handle this.
- */
-typedef enum OMX_VIDEO_CODINGTYPE {
-    OMX_VIDEO_CodingUnused,     /**< Value when coding is N/A */
-    OMX_VIDEO_CodingAutoDetect, /**< Autodetection of coding type */
-    OMX_VIDEO_CodingMPEG2,      /**< AKA: H.262 */
-    OMX_VIDEO_CodingH263,       /**< H.263 */
-    OMX_VIDEO_CodingMPEG4,      /**< MPEG-4 */
-    OMX_VIDEO_CodingWMV,        /**< all versions of Windows Media Video */
-    OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
-    OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
-    OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
-    OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_CodingMax = 0x7FFFFFFF
-} OMX_VIDEO_CODINGTYPE;
-
-
-/**
- * Data structure used to define a video path.  The number of Video paths for
- * input and output will vary by type of the Video component.
- *
- *    Input (aka Source) : zero Inputs, one Output,
- *    Splitter           : one Input, 2 or more Outputs,
- *    Processing Element : one Input, one output,
- *    Mixer              : 2 or more inputs, one output,
- *    Output (aka Sink)  : one Input, zero outputs.
- *
- * The PortDefinition structure is used to define all of the parameters
- * necessary for the compliant component to setup an input or an output video
- * path.  If additional vendor specific data is required, it should be
- * transmitted to the component using the CustomCommand function.  Compliant
- * components will prepopulate this structure with optimal values during the
- * GetDefaultInitParams command.
- *
- * STRUCT MEMBERS:
- *  cMIMEType             : MIME type of data for the port
- *  pNativeRender         : Platform specific reference for a display if a
- *                          sync, otherwise this field is 0
- *  nFrameWidth           : Width of frame to be used on channel if
- *                          uncompressed format is used.  Use 0 for unknown,
- *                          don't care or variable
- *  nFrameHeight          : Height of frame to be used on channel if
- *                          uncompressed format is used. Use 0 for unknown,
- *                          don't care or variable
- *  nStride               : Number of bytes per span of an image
- *                          (i.e. indicates the number of bytes to get
- *                          from span N to span N+1, where negative stride
- *                          indicates the image is bottom up
- *  nSliceHeight          : Height used when encoding in slices
- *  nBitrate              : Bit rate of frame to be used on channel if
- *                          compressed format is used. Use 0 for unknown,
- *                          don't care or variable
- *  xFramerate            : Frame rate to be used on channel if uncompressed
- *                          format is used. Use 0 for unknown, don't care or
- *                          variable.  Units are Q16 frames per second.
- *  bFlagErrorConcealment : Turns on error concealment if it is supported by
- *                          the OMX component
- *  eCompressionFormat    : Compression format used in this instance of the
- *                          component. When OMX_VIDEO_CodingUnused is
- *                          specified, eColorFormat is used
- *  eColorFormat : Decompressed format used by this component
- *  pNativeWindow : Platform specific reference for a window object if a
- *                          display sink , otherwise this field is 0x0.
- */
-typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
-    OMX_STRING cMIMEType;
-    OMX_NATIVE_DEVICETYPE pNativeRender;
-    OMX_U32 nFrameWidth;
-    OMX_U32 nFrameHeight;
-    OMX_S32 nStride;
-    OMX_U32 nSliceHeight;
-    OMX_U32 nBitrate;
-    OMX_U32 xFramerate;
-    OMX_BOOL bFlagErrorConcealment;
-    OMX_VIDEO_CODINGTYPE eCompressionFormat;
-    OMX_COLOR_FORMATTYPE eColorFormat;
-    OMX_NATIVE_WINDOWTYPE pNativeWindow;
-} OMX_VIDEO_PORTDEFINITIONTYPE;
-
-/**
- * Port format parameter.  This structure is used to enumerate the various
- * data input/output format supported by the port.
- *
- * STRUCT MEMBERS:
- *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information
- *  nPortIndex         : Indicates which port to set
- *  nIndex             : Indicates the enumeration index for the format from
- *                       0x0 to N-1
- *  eCompressionFormat : Compression format used in this instance of the
- *                       component. When OMX_VIDEO_CodingUnused is specified,
- *                       eColorFormat is used
- *  eColorFormat       : Decompressed format used by this component
- *  xFrameRate         : Indicates the video frame rate in Q16 format
- */
-typedef struct OMX_VIDEO_PARAM_PORTFORMATTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nIndex;
-    OMX_VIDEO_CODINGTYPE eCompressionFormat;
-    OMX_COLOR_FORMATTYPE eColorFormat;
-    OMX_U32 xFramerate;
-} OMX_VIDEO_PARAM_PORTFORMATTYPE;
-
-
-/**
- * This is a structure for configuring video compression quantization
- * parameter values.  Codecs may support different QP values for different
- * frame types.
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version info
- *  nPortIndex : Port that this structure applies to
- *  nQpI       : QP value to use for index frames
- *  nQpP       : QP value to use for P frames
- *  nQpB       : QP values to use for bidirectional frames
- */
-typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nQpI;
-    OMX_U32 nQpP;
-    OMX_U32 nQpB;
-} OMX_VIDEO_PARAM_QUANTIZATIONTYPE;
-
-
-/**
- * Structure for configuration of video fast update parameters.
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version info
- *  nPortIndex : Port that this structure applies to
- *  bEnableVFU : Enable/Disable video fast update
- *  nFirstGOB  : Specifies the number of the first macroblock row
- *  nFirstMB   : specifies the first MB relative to the specified first GOB
- *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB
- *               and nFirstMB
- */
-typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bEnableVFU;
-    OMX_U32 nFirstGOB;
-    OMX_U32 nFirstMB;
-    OMX_U32 nNumMBs;
-} OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;
-
-
-/**
- * Enumeration of possible bitrate control types
- */
-typedef enum OMX_VIDEO_CONTROLRATETYPE {
-    OMX_Video_ControlRateDisable,
-    OMX_Video_ControlRateVariable,
-    OMX_Video_ControlRateConstant,
-    OMX_Video_ControlRateVariableSkipFrames,
-    OMX_Video_ControlRateConstantSkipFrames,
-    OMX_Video_ControlRateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_Video_ControlRateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_Video_ControlRateMax = 0x7FFFFFFF
-} OMX_VIDEO_CONTROLRATETYPE;
-
-
-/**
- * Structure for configuring bitrate mode of a codec.
- *
- * STRUCT MEMBERS:
- *  nSize          : Size of the struct in bytes
- *  nVersion       : OMX spec version info
- *  nPortIndex     : Port that this struct applies to
- *  eControlRate   : Control rate type enum
- *  nTargetBitrate : Target bitrate to encode with
- */
-typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_CONTROLRATETYPE eControlRate;
-    OMX_U32 nTargetBitrate;
-} OMX_VIDEO_PARAM_BITRATETYPE;
-
-
-/**
- * Enumeration of possible motion vector (MV) types
- */
-typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
-    OMX_Video_MotionVectorPixel,
-    OMX_Video_MotionVectorHalfPel,
-    OMX_Video_MotionVectorQuarterPel,
-    OMX_Video_MotionVectorEighthPel,
-    OMX_Video_MotionVectorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_Video_MotionVectorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_Video_MotionVectorMax = 0x7FFFFFFF
-} OMX_VIDEO_MOTIONVECTORTYPE;
-
-
-/**
- * Structure for configuring the number of motion vectors used as well
- * as their accuracy.
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the struct in bytes
- *  nVersion         : OMX spec version info
- *  nPortIndex       : port that this structure applies to
- *  eAccuracy        : Enumerated MV accuracy
- *  bUnrestrictedMVs : Allow unrestricted MVs
- *  bFourMV          : Allow use of 4 MVs
- *  sXSearchRange    : Search range in horizontal direction for MVs
- *  sYSearchRange    : Search range in vertical direction for MVs
- */
-typedef struct OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_MOTIONVECTORTYPE eAccuracy;
-    OMX_BOOL bUnrestrictedMVs;
-    OMX_BOOL bFourMV;
-    OMX_S32 sXSearchRange;
-    OMX_S32 sYSearchRange;
-} OMX_VIDEO_PARAM_MOTIONVECTORTYPE;
-
-
-/**
- * Enumeration of possible methods to use for Intra Refresh
- */
-typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
-    OMX_VIDEO_IntraRefreshCyclic,
-    OMX_VIDEO_IntraRefreshAdaptive,
-    OMX_VIDEO_IntraRefreshBoth,
-    OMX_VIDEO_IntraRefreshKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_IntraRefreshVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
-} OMX_VIDEO_INTRAREFRESHTYPE;
-
-
-/**
- * Structure for configuring intra refresh mode
- *
- * STRUCT MEMBERS:
- *  nSize        : Size of the structure in bytes
- *  nVersion     : OMX specification version information
- *  nPortIndex   : Port that this structure applies to
- *  eRefreshMode : Cyclic, Adaptive, or Both
- *  nAirMBs      : Number of intra macroblocks to refresh in a frame when
- *                 AIR is enabled
- *  nAirRef      : Number of times a motion marked macroblock has to be
- *                 intra coded
- *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"
- *                 when CIR is enabled
- */
-typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_INTRAREFRESHTYPE eRefreshMode;
-    OMX_U32 nAirMBs;
-    OMX_U32 nAirRef;
-    OMX_U32 nCirMBs;
-} OMX_VIDEO_PARAM_INTRAREFRESHTYPE;
-
-
-/**
- * Structure for enabling various error correction methods for video
- * compression.
- *
- * STRUCT MEMBERS:
- *  nSize                   : Size of the structure in bytes
- *  nVersion                : OMX specification version information
- *  nPortIndex              : Port that this structure applies to
- *  bEnableHEC              : Enable/disable header extension codes (HEC)
- *  bEnableResync           : Enable/disable resynchronization markers
- *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be
- *                            applied in the stream
- *  bEnableDataPartitioning : Enable/disable data partitioning
- *  bEnableRVLC             : Enable/disable reversible variable length
- *                            coding
- */
-typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bEnableHEC;
-    OMX_BOOL bEnableResync;
-    OMX_U32  nResynchMarkerSpacing;
-    OMX_BOOL bEnableDataPartitioning;
-    OMX_BOOL bEnableRVLC;
-} OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;
-
-
-/**
- * Configuration of variable block-size motion compensation (VBSMC)
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  b16x16     : Enable inter block search 16x16
- *  b16x8      : Enable inter block search 16x8
- *  b8x16      : Enable inter block search 8x16
- *  b8x8       : Enable inter block search 8x8
- *  b8x4       : Enable inter block search 8x4
- *  b4x8       : Enable inter block search 4x8
- *  b4x4       : Enable inter block search 4x4
- */
-typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL b16x16;
-    OMX_BOOL b16x8;
-    OMX_BOOL b8x16;
-    OMX_BOOL b8x8;
-    OMX_BOOL b8x4;
-    OMX_BOOL b4x8;
-    OMX_BOOL b4x4;
-} OMX_VIDEO_PARAM_VBSMCTYPE;
-
-
-/**
- * H.263 profile types, each profile indicates support for various
- * performance bounds and different annexes.
- *
- * ENUMS:
- *  Baseline           : Baseline Profile: H.263 (V1), no optional modes
- *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility
- *                       Profile: H.263+ (V2), includes annexes I, J, L.4
- *                       and T
- *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1),
- *                       includes annex F
- *  ISWV2              : Interactive Streaming Wireless Profile: H.263+
- *                       (V2), includes annexes I, J, K and T
- *  ISWV3              : Interactive Streaming Wireless Profile: H.263++
- *                       (V3), includes profile 3 and annexes V and W.6.3.8
- *  HighCompression    : Conversational High Compression Profile: H.263++
- *                       (V3), includes profiles 1 & 2 and annexes D and U
- *  Internet           : Conversational Internet Profile: H.263++ (V3),
- *                       includes profile 5 and annex K
- *  Interlace          : Conversational Interlace Profile: H.263++ (V3),
- *                       includes profile 5 and annex W.6.3.11
- *  HighLatency        : High Latency Profile: H.263++ (V3), includes
- *                       profile 6 and annexes O.1 and P.5
- */
-typedef enum OMX_VIDEO_H263PROFILETYPE {
-    OMX_VIDEO_H263ProfileBaseline            = 0x01,
-    OMX_VIDEO_H263ProfileH320Coding          = 0x02,
-    OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,
-    OMX_VIDEO_H263ProfileISWV2               = 0x08,
-    OMX_VIDEO_H263ProfileISWV3               = 0x10,
-    OMX_VIDEO_H263ProfileHighCompression     = 0x20,
-    OMX_VIDEO_H263ProfileInternet            = 0x40,
-    OMX_VIDEO_H263ProfileInterlace           = 0x80,
-    OMX_VIDEO_H263ProfileHighLatency         = 0x100,
-    OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_H263ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF
-} OMX_VIDEO_H263PROFILETYPE;
-
-
-/**
- * H.263 level types, each level indicates support for various frame sizes,
- * bit rates, decoder frame rates.
- */
-typedef enum OMX_VIDEO_H263LEVELTYPE {
-    OMX_VIDEO_H263Level10  = 0x01,
-    OMX_VIDEO_H263Level20  = 0x02,
-    OMX_VIDEO_H263Level30  = 0x04,
-    OMX_VIDEO_H263Level40  = 0x08,
-    OMX_VIDEO_H263Level45  = 0x10,
-    OMX_VIDEO_H263Level50  = 0x20,
-    OMX_VIDEO_H263Level60  = 0x40,
-    OMX_VIDEO_H263Level70  = 0x80,
-    OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_H263LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_H263LevelMax = 0x7FFFFFFF
-} OMX_VIDEO_H263LEVELTYPE;
-
-
-/**
- * Specifies the picture type. These values should be OR'd to signal all
- * pictures types which are allowed.
- *
- * ENUMS:
- *  Generic Picture Types:          I, P and B
- *  H.263 Specific Picture Types:   SI and SP
- *  H.264 Specific Picture Types:   EI and EP
- *  MPEG-4 Specific Picture Types:  S
- */
-typedef enum OMX_VIDEO_PICTURETYPE {
-    OMX_VIDEO_PictureTypeI   = 0x01,
-    OMX_VIDEO_PictureTypeP   = 0x02,
-    OMX_VIDEO_PictureTypeB   = 0x04,
-    OMX_VIDEO_PictureTypeSI  = 0x08,
-    OMX_VIDEO_PictureTypeSP  = 0x10,
-    OMX_VIDEO_PictureTypeEI  = 0x11,
-    OMX_VIDEO_PictureTypeEP  = 0x12,
-    OMX_VIDEO_PictureTypeS   = 0x14,
-    OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_PictureTypeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
-} OMX_VIDEO_PICTURETYPE;
-
-
-/**
- * H.263 Params
- *
- * STRUCT MEMBERS:
- *  nSize                    : Size of the structure in bytes
- *  nVersion                 : OMX specification version information
- *  nPortIndex               : Port that this structure applies to
- *  nPFrames                 : Number of P frames between each I frame
- *  nBFrames                 : Number of B frames between each I frame
- *  eProfile                 : H.263 profile(s) to use
- *  eLevel                   : H.263 level(s) to use
- *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE
- *                             (specified in the 1998 version of H.263) to
- *                             indicate custom picture sizes or clock
- *                             frequencies
- *  nAllowedPictureTypes     : Specifies the picture types allowed in the
- *                             bitstream
- *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is
- *                             not constrained. It is recommended to change
- *                             the value of the RTYPE bit for each reference
- *                             picture in error-free communication
- *  nPictureHeaderRepetition : Specifies the frequency of picture header
- *                             repetition
- *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB
- *                             headers in units of GOBs
- */
-typedef struct OMX_VIDEO_PARAM_H263TYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nPFrames;
-    OMX_U32 nBFrames;
-    OMX_VIDEO_H263PROFILETYPE eProfile;
-	OMX_VIDEO_H263LEVELTYPE eLevel;
-    OMX_BOOL bPLUSPTYPEAllowed;
-    OMX_U32 nAllowedPictureTypes;
-    OMX_BOOL bForceRoundingTypeToZero;
-    OMX_U32 nPictureHeaderRepetition;
-    OMX_U32 nGOBHeaderInterval;
-} OMX_VIDEO_PARAM_H263TYPE;
-
-
-/**
- * MPEG-2 profile types, each profile indicates support for various
- * performance bounds and different annexes.
- */
-typedef enum OMX_VIDEO_MPEG2PROFILETYPE {
-    OMX_VIDEO_MPEG2ProfileSimple = 0,  /**< Simple Profile */
-    OMX_VIDEO_MPEG2ProfileMain,        /**< Main Profile */
-    OMX_VIDEO_MPEG2Profile422,         /**< 4:2:2 Profile */
-    OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
-    OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
-    OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
-    OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_MPEG2ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF
-} OMX_VIDEO_MPEG2PROFILETYPE;
-
-
-/**
- * MPEG-2 level types, each level indicates support for various frame
- * sizes, bit rates, decoder frame rates.  No need
- */
-typedef enum OMX_VIDEO_MPEG2LEVELTYPE {
-    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */
-    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */
-    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */
-    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */
-    OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_MPEG2LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF
-} OMX_VIDEO_MPEG2LEVELTYPE;
-
-
-/**
- * MPEG-2 params
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nPFrames   : Number of P frames between each I frame
- *  nBFrames   : Number of B frames between each I frame
- *  eProfile   : MPEG-2 profile(s) to use
- *  eLevel     : MPEG-2 levels(s) to use
- */
-typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nPFrames;
-    OMX_U32 nBFrames;
-    OMX_VIDEO_MPEG2PROFILETYPE eProfile;
-	OMX_VIDEO_MPEG2LEVELTYPE eLevel;
-} OMX_VIDEO_PARAM_MPEG2TYPE;
-
-
-/**
- * MPEG-4 profile types, each profile indicates support for various
- * performance bounds and different annexes.
- *
- * ENUMS:
- *  - Simple Profile, Levels 1-3
- *  - Simple Scalable Profile, Levels 1-2
- *  - Core Profile, Levels 1-2
- *  - Main Profile, Levels 2-4
- *  - N-bit Profile, Level 2
- *  - Scalable Texture Profile, Level 1
- *  - Simple Face Animation Profile, Levels 1-2
- *  - Simple Face and Body Animation (FBA) Profile, Levels 1-2
- *  - Basic Animated Texture Profile, Levels 1-2
- *  - Hybrid Profile, Levels 1-2
- *  - Advanced Real Time Simple Profiles, Levels 1-4
- *  - Core Scalable Profile, Levels 1-3
- *  - Advanced Coding Efficiency Profile, Levels 1-4
- *  - Advanced Core Profile, Levels 1-2
- *  - Advanced Scalable Texture, Levels 2-3
- */
-typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
-    OMX_VIDEO_MPEG4ProfileSimple           = 0x01,
-    OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,
-    OMX_VIDEO_MPEG4ProfileCore             = 0x04,
-    OMX_VIDEO_MPEG4ProfileMain             = 0x08,
-    OMX_VIDEO_MPEG4ProfileNbit             = 0x10,
-    OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,
-    OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,
-    OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,
-    OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,
-    OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,
-    OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,
-    OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,
-    OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,
-    OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,
-    OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,
-    OMX_VIDEO_MPEG4ProfileAdvancedSimple   = 0x8000,
-    OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_MPEG4ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF
-} OMX_VIDEO_MPEG4PROFILETYPE;
-
-
-/**
- * MPEG-4 level types, each level indicates support for various frame
- * sizes, bit rates, decoder frame rates.  No need
- */
-typedef enum OMX_VIDEO_MPEG4LEVELTYPE {
-    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */
-    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */
-    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */
-    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */
-    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */
-    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */
-    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */
-    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */
-    OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_MPEG4LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF
-} OMX_VIDEO_MPEG4LEVELTYPE;
-
-
-/**
- * MPEG-4 configuration.  This structure handles configuration options
- * which are specific to MPEG4 algorithms
- *
- * STRUCT MEMBERS:
- *  nSize                : Size of the structure in bytes
- *  nVersion             : OMX specification version information
- *  nPortIndex           : Port that this structure applies to
- *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+
- *                         Annex K). Put zero if not used
- *  bSVH                 : Enable Short Video Header mode
- *  bGov                 : Flag to enable GOV
- *  nPFrames             : Number of P frames between each I frame (also called
- *                         GOV period)
- *  nBFrames             : Number of B frames between each I frame
- *  nIDCVLCThreshold     : Value of intra DC VLC threshold
- *  bACPred              : Flag to use ac prediction
- *  nMaxPacketSize       : Maximum size of packet in bytes.
- *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4.
- *                         Interpreted as described in MPEG4 standard.
- *  eProfile             : MPEG-4 profile(s) to use.
- *  eLevel               : MPEG-4 level(s) to use.
- *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
- *  nHeaderExtension     : Specifies the number of consecutive video packet
- *                         headers within a VOP
- *  bReversibleVLC       : Specifies whether reversible variable length coding
- *                         is in use
- */
-typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nSliceHeaderSpacing;
-    OMX_BOOL bSVH;
-    OMX_BOOL bGov;
-    OMX_U32 nPFrames;
-    OMX_U32 nBFrames;
-    OMX_U32 nIDCVLCThreshold;
-    OMX_BOOL bACPred;
-    OMX_U32 nMaxPacketSize;
-    OMX_U32 nTimeIncRes;
-    OMX_VIDEO_MPEG4PROFILETYPE eProfile;
-    OMX_VIDEO_MPEG4LEVELTYPE eLevel;
-    OMX_U32 nAllowedPictureTypes;
-    OMX_U32 nHeaderExtension;
-    OMX_BOOL bReversibleVLC;
-} OMX_VIDEO_PARAM_MPEG4TYPE;
-
-
-/**
- * WMV Versions
- */
-typedef enum OMX_VIDEO_WMVFORMATTYPE {
-    OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
-    OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
-    OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
-    OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
-    OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_WMFFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
-} OMX_VIDEO_WMVFORMATTYPE;
-
-
-/**
- * WMV Params
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  eFormat    : Version of WMV stream / data
- */
-typedef struct OMX_VIDEO_PARAM_WMVTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_WMVFORMATTYPE eFormat;
-} OMX_VIDEO_PARAM_WMVTYPE;
-
-
-/**
- * Real Video Version
- */
-typedef enum OMX_VIDEO_RVFORMATTYPE {
-    OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
-    OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
-    OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
-    OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
-    OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_RVFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
-} OMX_VIDEO_RVFORMATTYPE;
-
-
-/**
- * Real Video Params
- *
- * STUCT MEMBERS:
- *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information
- *  nPortIndex         : Port that this structure applies to
- *  eFormat            : Version of RV stream / data
- *  nBitsPerPixel      : Bits per pixel coded in the frame
- *  nPaddedWidth       : Padded width in pixel of a video frame
- *  nPaddedHeight      : Padded Height in pixels of a video frame
- *  nFrameRate         : Rate of video in frames per second
- *  nBitstreamFlags    : Flags which internal information about the bitstream
- *  nBitstreamVersion  : Bitstream version
- *  nMaxEncodeFrameSize: Max encoded frame size
- *  bEnablePostFilter  : Turn on/off post filter
- *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
- *  bEnableLatencyMode : When enabled, the decoder does not display a decoded
- *                       frame until it has detected that no enhancement layer
- *  					 frames or dependent B frames will be coming. This
- *  					 detection usually occurs when a subsequent non-B
- *  					 frame is encountered
- */
-typedef struct OMX_VIDEO_PARAM_RVTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_VIDEO_RVFORMATTYPE eFormat;
-    OMX_U16 nBitsPerPixel;
-    OMX_U16 nPaddedWidth;
-    OMX_U16 nPaddedHeight;
-    OMX_U32 nFrameRate;
-    OMX_U32 nBitstreamFlags;
-    OMX_U32 nBitstreamVersion;
-    OMX_U32 nMaxEncodeFrameSize;
-    OMX_BOOL bEnablePostFilter;
-    OMX_BOOL bEnableTemporalInterpolation;
-    OMX_BOOL bEnableLatencyMode;
-} OMX_VIDEO_PARAM_RVTYPE;
-
-
-/**
- * AVC profile types, each profile indicates support for various
- * performance bounds and different annexes.
- */
-typedef enum OMX_VIDEO_AVCPROFILETYPE {
-    OMX_VIDEO_AVCProfileBaseline = 0x01,   /**< Baseline profile */
-    OMX_VIDEO_AVCProfileMain     = 0x02,   /**< Main profile */
-    OMX_VIDEO_AVCProfileExtended = 0x04,   /**< Extended profile */
-    OMX_VIDEO_AVCProfileHigh     = 0x08,   /**< High profile */
-    OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
-    OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
-    OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
-    OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_AVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF
-} OMX_VIDEO_AVCPROFILETYPE;
-
-
-/**
- * AVC level types, each level indicates support for various frame sizes,
- * bit rates, decoder frame rates.  No need
- */
-typedef enum OMX_VIDEO_AVCLEVELTYPE {
-    OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
-    OMX_VIDEO_AVCLevel1b  = 0x02,     /**< Level 1b */
-    OMX_VIDEO_AVCLevel11  = 0x04,     /**< Level 1.1 */
-    OMX_VIDEO_AVCLevel12  = 0x08,     /**< Level 1.2 */
-    OMX_VIDEO_AVCLevel13  = 0x10,     /**< Level 1.3 */
-    OMX_VIDEO_AVCLevel2   = 0x20,     /**< Level 2 */
-    OMX_VIDEO_AVCLevel21  = 0x40,     /**< Level 2.1 */
-    OMX_VIDEO_AVCLevel22  = 0x80,     /**< Level 2.2 */
-    OMX_VIDEO_AVCLevel3   = 0x100,    /**< Level 3 */
-    OMX_VIDEO_AVCLevel31  = 0x200,    /**< Level 3.1 */
-    OMX_VIDEO_AVCLevel32  = 0x400,    /**< Level 3.2 */
-    OMX_VIDEO_AVCLevel4   = 0x800,    /**< Level 4 */
-    OMX_VIDEO_AVCLevel41  = 0x1000,   /**< Level 4.1 */
-    OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
-    OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
-    OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
-    OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_AVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF
-} OMX_VIDEO_AVCLEVELTYPE;
-
-
-/**
- * AVC loop filter modes
- *
- * OMX_VIDEO_AVCLoopFilterEnable               : Enable
- * OMX_VIDEO_AVCLoopFilterDisable              : Disable
- * OMX_VIDEO_AVCLoopFilterDisableSliceBoundary : Disabled on slice boundaries
- */
-typedef enum OMX_VIDEO_AVCLOOPFILTERTYPE {
-    OMX_VIDEO_AVCLoopFilterEnable = 0,
-    OMX_VIDEO_AVCLoopFilterDisable,
-    OMX_VIDEO_AVCLoopFilterDisableSliceBoundary,
-    OMX_VIDEO_AVCLoopFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_AVCLoopFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
-} OMX_VIDEO_AVCLOOPFILTERTYPE;
-
-
-/**
- * AVC params
- *
- * STRUCT MEMBERS:
- *  nSize                     : Size of the structure in bytes
- *  nVersion                  : OMX specification version information
- *  nPortIndex                : Port that this structure applies to
- *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put
- *                              zero if not used
- *  nPFrames                  : Number of P frames between each I frame
- *  nBFrames                  : Number of B frames between each I frame
- *  bUseHadamard              : Enable/disable Hadamard transform
- *  nRefFrames                : Max number of reference frames to use for inter
- *                              motion search (1-16)
- *  nRefIdxTrailing           : Pic param set ref frame index (index into ref
- *                              frame buffer of trailing frames list), B frame
- *                              support
- *  nRefIdxForward            : Pic param set ref frame index (index into ref
- *                              frame buffer of forward frames list), B frame
- *                              support
- *  bEnableUEP                : Enable/disable unequal error protection. This
- *                              is only valid of data partitioning is enabled.
- *  bEnableFMO                : Enable/disable flexible macroblock ordering
- *  bEnableASO                : Enable/disable arbitrary slice ordering
- *  bEnableRS                 : Enable/disable sending of redundant slices
- *  eProfile                  : AVC profile(s) to use
- *  eLevel                    : AVC level(s) to use
- *  nAllowedPictureTypes      : Specifies the picture types allowed in the
- *                              bitstream
- *  bFrameMBsOnly             : specifies that every coded picture of the
- *                              coded video sequence is a coded frame
- *                              containing only frame macroblocks
- *  bMBAFF                    : Enable/disable switching between frame and
- *                              field macroblocks within a picture
- *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the
- *                              syntax elements for which two descriptors appear
- *                              in the syntax tables
- *  bWeightedPPrediction      : Enable/disable weighted prediction shall not
- *                              be applied to P and SP slices
- *  nWeightedBipredicitonMode : Default weighted prediction is applied to B
- *                              slices
- *  bconstIpred               : Enable/disable intra prediction
- *  bDirect8x8Inference       : Specifies the method used in the derivation
- *                              process for luma motion vectors for B_Skip,
- *                              B_Direct_16x16 and B_Direct_8x8 as specified
- *                              in subclause 8.4.1.2 of the AVC spec
- *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
- *                              mode used in B slice coding (related to
- *                              bDirect8x8Inference) . Spatial direct mode is
- *                              more common and should be the default.
- *  nCabacInitIdx             : Index used to init CABAC contexts
- *  eLoopFilterMode           : Enable/disable loop filter
- */
-typedef struct OMX_VIDEO_PARAM_AVCTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nSliceHeaderSpacing;
-    OMX_U32 nPFrames;
-    OMX_U32 nBFrames;
-    OMX_BOOL bUseHadamard;
-    OMX_U32 nRefFrames;
-	OMX_U32 nRefIdx10ActiveMinus1;
-	OMX_U32 nRefIdx11ActiveMinus1;
-    OMX_BOOL bEnableUEP;
-    OMX_BOOL bEnableFMO;
-    OMX_BOOL bEnableASO;
-    OMX_BOOL bEnableRS;
-    OMX_VIDEO_AVCPROFILETYPE eProfile;
-	OMX_VIDEO_AVCLEVELTYPE eLevel;
-    OMX_U32 nAllowedPictureTypes;
-	OMX_BOOL bFrameMBsOnly;
-    OMX_BOOL bMBAFF;
-    OMX_BOOL bEntropyCodingCABAC;
-    OMX_BOOL bWeightedPPrediction;
-    OMX_U32 nWeightedBipredicitonMode;
-    OMX_BOOL bconstIpred ;
-    OMX_BOOL bDirect8x8Inference;
-	OMX_BOOL bDirectSpatialTemporal;
-	OMX_U32 nCabacInitIdc;
-	OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
-} OMX_VIDEO_PARAM_AVCTYPE;
-
-typedef struct OMX_VIDEO_PARAM_PROFILELEVELTYPE {
-   OMX_U32 nSize;
-   OMX_VERSIONTYPE nVersion;
-   OMX_U32 nPortIndex;
-   OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE,
-                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
-   OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE,
-                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
-   OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
-                               This parameter is valid only for
-                               OMX_IndexParamVideoProfileLevelQuerySupported index,
-                               For all other indices this parameter is to be ignored. */
-} OMX_VIDEO_PARAM_PROFILELEVELTYPE;
-
-/**
- * Structure for dynamically configuring bitrate mode of a codec.
- *
- * STRUCT MEMBERS:
- *  nSize          : Size of the struct in bytes
- *  nVersion       : OMX spec version info
- *  nPortIndex     : Port that this struct applies to
- *  nEncodeBitrate : Target average bitrate to be generated in bps
- */
-typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nEncodeBitrate;
-} OMX_VIDEO_CONFIG_BITRATETYPE;
-
-/**
- * Defines Encoder Frame Rate setting
- *
- * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes
- *  nVersion         : OMX specification version information
- *  nPortIndex       : Port that this structure applies to
- *  xEncodeFramerate : Encoding framerate represented in Q16 format
- */
-typedef struct OMX_CONFIG_FRAMERATETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 xEncodeFramerate; /* Q16 format */
-} OMX_CONFIG_FRAMERATETYPE;
-
-typedef struct OMX_CONFIG_INTRAREFRESHVOPTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL IntraRefreshVOP;
-} OMX_CONFIG_INTRAREFRESHVOPTYPE;
-
-typedef struct OMX_CONFIG_MACROBLOCKERRORMAPTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nErrMapSize;           /* Size of the Error Map in bytes */
-    OMX_U8  ErrMap[1];             /* Error map hint */
-} OMX_CONFIG_MACROBLOCKERRORMAPTYPE;
-
-typedef struct OMX_CONFIG_MBERRORREPORTINGTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_BOOL bEnabled;
-} OMX_CONFIG_MBERRORREPORTINGTYPE;
-
-typedef struct OMX_PARAM_MACROBLOCKSTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nMacroblocks;
-} OMX_PARAM_MACROBLOCKSTYPE;
-
-/**
- * AVC Slice Mode modes
- *
- * OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
- * OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
- * OMX_VIDEO_SLICEMODE_AVCByteSlice : NAL mode, number of bytes per frame
- */
-typedef enum OMX_VIDEO_AVCSLICEMODETYPE {
-    OMX_VIDEO_SLICEMODE_AVCDefault = 0,
-    OMX_VIDEO_SLICEMODE_AVCMBSlice,
-    OMX_VIDEO_SLICEMODE_AVCByteSlice,
-    OMX_VIDEO_SLICEMODE_AVCKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
-    OMX_VIDEO_SLICEMODE_AVCVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
-} OMX_VIDEO_AVCSLICEMODETYPE;
-
-/**
- * AVC FMO Slice Mode Params
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nNumSliceGroups : Specifies the number of slice groups
- *  nSliceGroupMapType : Specifies the type of slice groups
- *  eSliceMode : Specifies the type of slice
- */
-typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U8 nNumSliceGroups;
-    OMX_U8 nSliceGroupMapType;
-    OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
-} OMX_VIDEO_PARAM_AVCSLICEFMO;
-
-/**
- * AVC IDR Period Configs
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nIDRPeriod : Specifies periodicity of IDR frames
- *  nPFrames : Specifies internal of coding Intra frames
- */
-typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nIDRPeriod;
-    OMX_U32 nPFrames;
-} OMX_VIDEO_CONFIG_AVCINTRAPERIOD;
-
-/**
- * AVC NAL Size Configs
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nNaluBytes : Specifies the NAL unit size
- */
-typedef struct OMX_VIDEO_CONFIG_NALSIZE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nNaluBytes;
-} OMX_VIDEO_CONFIG_NALSIZE;
-
-/**
- * Vendor Private Configs
- *
- * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to
- *  nCapacity  : Specifies the private unit size
- *  nHolder    : Pointer to private unit address 
- */
-typedef struct OMX_VIDEO_CONFIG_PRI_INFOTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_U32 nCapacity;
-    OMX_PTR nHolder;
-} OMX_VIDEO_CONFIG_PRI_INFOTYPE;
-
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif
-/* File EOF */
-
diff --git a/ilcore/inc/khronos/openmax/include/OMX_VideoExt.h b/ilcore/inc/khronos/openmax/include/OMX_VideoExt.h
deleted file mode 100644
index f97a3bf..0000000
--- a/ilcore/inc/khronos/openmax/include/OMX_VideoExt.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_VideoExt.h - OpenMax IL version 1.1.2
- * The OMX_VideoExt header file contains extensions to the
- * definitions used by both the application and the component to
- * access video items.
- */
-
-#ifndef OMX_VideoExt_h
-#define OMX_VideoExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header shall include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-#include <OMX_Core.h>
-
-/** NALU Formats */
-typedef enum OMX_NALUFORMATSTYPE {
-    OMX_NaluFormatStartCodes = 1,
-    OMX_NaluFormatOneNaluPerBuffer = 2,
-    OMX_NaluFormatOneByteInterleaveLength = 4,
-    OMX_NaluFormatTwoByteInterleaveLength = 8,
-    OMX_NaluFormatFourByteInterleaveLength = 16,
-    OMX_NaluFormatZeroByteInterleaveLength = 32,
-    OMX_NaluFormatStartCodesSeparateFirstHeader = 64,
-    OMX_NaluFormatCodingMax = 0x7FFFFFFF
-} OMX_NALUFORMATSTYPE;
-
-
-/** NAL Stream Format */
-typedef struct OMX_NALSTREAMFORMATTYPE{
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_NALUFORMATSTYPE eNaluFormat;
-} OMX_NALSTREAMFORMATTYPE;
-
-typedef struct OMX_VIDEO_PARAM_BYTESTREAMTYPE {
-     OMX_U32 nSize;                 // Size of the structure
-     OMX_VERSIONTYPE nVersion;      // OMX specification version
-     OMX_U32 nPortIndex;            // Port that this structure applies to
-     OMX_BOOL bBytestream;          // Enable/disable bytestream support
-} OMX_VIDEO_PARAM_BYTESTREAMTYPE;
-
-typedef struct OMX_VIDEO_CONFIG_INTEL_BITRATETYPE {
-     OMX_U32 nSize;
-     OMX_VERSIONTYPE nVersion;
-     OMX_U32 nPortIndex;
-     OMX_U32 nMaxEncodeBitrate;    // Maximum bitrate
-     OMX_U32 nTargetPercentage;    // Target bitrate as percentage of maximum bitrate; e.g. 95 is 95%
-     OMX_U32 nWindowSize;          // Window size in milliseconds allowed for bitrate to reach target
-     OMX_U32 nInitialQP;           // Initial QP for I frames
-     OMX_U32 nMinQP;
-} OMX_VIDEO_CONFIG_INTEL_BITRATETYPE;
-
-typedef enum OMX_VIDEO_INTEL_CONTROLRATETYPE {
-    OMX_Video_Intel_ControlRateDisable,
-    OMX_Video_Intel_ControlRateVariable,
-    OMX_Video_Intel_ControlRateConstant,
-    OMX_Video_Intel_ControlRateVideoConferencingMode,
-    OMX_Video_Intel_ControlRateMax = 0x7FFFFFFF
-} OMX_VIDEO_INTEL_CONTROLRATETYPE;
-
-typedef struct OMX_VIDEO_PARAM_INTEL_BITRATETYPE {
-     OMX_U32 nSize;
-     OMX_VERSIONTYPE nVersion;
-     OMX_U32 nPortIndex;
-     OMX_VIDEO_INTEL_CONTROLRATETYPE eControlRate;
-     OMX_U32 nTargetBitrate;
-} OMX_VIDEO_PARAM_INTEL_BITRATETYPE;
-
-typedef struct OMX_VIDEO_PARAM_INTEL_AVC_DECODE_SETTINGS {
-     OMX_U32 nSize;                       // Size of the structure
-     OMX_VERSIONTYPE nVersion;            // OMX specification version
-     OMX_U32 nPortIndex;                  // Port that this structure applies to
-     OMX_U32 nMaxNumberOfReferenceFrame;  // Maximum number of reference frames
-     OMX_U32 nMaxWidth;                   // Maximum width of video
-     OMX_U32 nMaxHeight;                  // Maximum height of video
-} OMX_VIDEO_PARAM_INTEL_AVC_DECODE_SETTINGS;
-
-
-typedef struct OMX_VIDEO_CONFIG_INTEL_SLICE_NUMBERS {
-     OMX_U32 nSize;                       // Size of the structure
-     OMX_VERSIONTYPE nVersion;            // OMX specification version
-     OMX_U32 nPortIndex;                  // Port that this structure applies to
-     OMX_U32 nISliceNumber;               // I frame slice number
-     OMX_U32 nPSliceNumber;               // P frame slice number
-} OMX_VIDEO_CONFIG_INTEL_SLICE_NUMBERS;
-
-
-typedef struct OMX_VIDEO_CONFIG_INTEL_AIR {
-     OMX_U32 nSize;                       // Size of the structure
-     OMX_VERSIONTYPE nVersion;            // OMX specification version
-     OMX_U32 nPortIndex;                  // Port that this structure applies to
-     OMX_BOOL bAirEnable;                 // Enable AIR
-     OMX_BOOL bAirAuto;                   // AIR auto
-     OMX_U32 nAirMBs;                     // Number of AIR MBs
-     OMX_U32 nAirThreshold;               // AIR Threshold
-
-} OMX_VIDEO_CONFIG_INTEL_AIR;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_VideoExt_h */
-/* File EOF */
diff --git a/ilcore/src/Android.mk b/ilcore/src/Android.mk
deleted file mode 100644
index c8eb6d6..0000000
--- a/ilcore/src/Android.mk
+++ /dev/null
@@ -1,25 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-	wrs_omxcore.cpp
-
-LOCAL_MODULE_TAGS := optional
-LOCAL_MODULE := libwrs_omxil_core_pvwrapped
-
-LOCAL_CFLAGS := $(OMXLOG_CFLAGS) -DLOG_TAG=\"omxil-core\"
-LOCAL_CPPFLAGS :=
-
-LOCAL_LDFLAGS :=
-
-LOCAL_SHARED_LIBRARIES := \
-	libwrs_omxil_common \
-	liblog
-
-LOCAL_C_INCLUDES := \
-	$(WRS_OMXIL_CORE_ROOT)/utils/inc \
-	$(WRS_OMXIL_CORE_ROOT)/base/inc \
-	$(WRS_OMXIL_CORE_ROOT)/core/inc/khronos/openmax/include \
-	$(PV_INCLUDES)
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/ilcore/src/Makefile.am b/ilcore/src/Makefile.am
deleted file mode 100644
index 956dafd..0000000
--- a/ilcore/src/Makefile.am
+++ /dev/null
@@ -1,50 +0,0 @@
-libOmxCore_source_cpp = \
-	wrs_omxcore.cpp \
-	$(NULL)
-
-libOmxCore_source_h = \
-	../inc/khronos/openmax/include/OMX_Audio.h \
-	../inc/khronos/openmax/include/OMX_ContentPipe.h \
-	../inc/khronos/openmax/include/OMX_Image.h \
-	../inc/khronos/openmax/include/OMX_Index.h \
-	../inc/khronos/openmax/include/OMX_IVCommon.h \
-	../inc/khronos/openmax/include/OMX_Types.h \
-	../inc/khronos/openmax/include/OMX_Video.h \
-	../inc/khronos/openmax/include/OMX_Component.h \
-	../inc/khronos/openmax/include/OMX_Core.h \
-	../inc/khronos/openmax/include/OMX_IndexExt.h \
-	../inc/khronos/openmax/include/OMX_IntelErrorTypes.h \
-	../inc/khronos/openmax/include/OMX_Other.h \
-	../inc/khronos/openmax/include/OMX_VideoExt.h \
-	$(NULL)
-
-libOmxCore_source_priv_h = \
-	$(NULL)
-	
-libOmxCore_ldflags = \
-	-version-info 0:5:0 \
-	-no-undefined \
-	$(NULL)
-
-libOmxCore_deps_libs = \
-	$(top_srcdir)/base/src/libomxil_base.la \
-	$(top_srcdir)/utils/src/libomxil_utils.la \
-	-ldl -lpthread \
-	$(NULL)
-
-libOmxCore_deps = \
-	$(top_srcdir)/base/src/libomxil_base.la \
-	$(top_srcdir)/utils/src/libomxil_utils.la \
-	$(NULL)
-
-lib_LTLIBRARIES			= libOmxCore.la
-libOmxCoreincludedir		= ${includedir}/omx
-libOmxCoreinclude_HEADERS	= $(libOmxCore_source_h)
-noinst_HEADERS			= $(libOmxCore_source_h_priv)
-libOmxCore_la_SOURCES		= $(libOmxCore_source_cpp)
-libOmxCore_la_LDFLAGS		= $(libOmxCore_ldflags)
-libOmxCore_la_CPPFLAGS       	= -I../inc -I$(top_srcdir)/utils/inc -I$(top_srcdir)/base/inc -I../inc/khronos/openmax/include
-libOmxCore_la_DEPENDENCIES	= $(libOmxCore_deps)
-libOmxCore_la_LIBADD		= $(libOmxCore_deps_libs)
-
-DISTCLEANFILES = Makefile.in
diff --git a/ilcore/src/ebuild.mk b/ilcore/src/ebuild.mk
deleted file mode 100644
index d2ce4ff..0000000
--- a/ilcore/src/ebuild.mk
+++ /dev/null
@@ -1,21 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-	wrs_omxcore.cpp
-
-LOCAL_MODULE := libwrs_omxil_core
-
-LOCAL_CPPFLAGS :=
-
-LOCAL_LDFLAGS :=
-
-LOCAL_SHARED_LIBRARIES := \
-	libwrs_omxil_common
-
-LOCAL_C_INCLUDES := \
-	$(WRS_OMXIL_CORE_ROOT)/utils/inc \
-	$(WRS_OMXIL_CORE_ROOT)/base/inc \
-	$(WRS_OMXIL_CORE_ROOT)/core/inc/khronos/openmax/include
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/ilcore/src/intel_m4v_config_parser.cpp b/ilcore/src/intel_m4v_config_parser.cpp
deleted file mode 100644
index 4088852..0000000
--- a/ilcore/src/intel_m4v_config_parser.cpp
+++ /dev/null
@@ -1,1316 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-
-//#define LOG_NDEBUG 0
-#define LOG_TAG "intel_m4v_config_parser.cpp"
-#include <utils/Log.h>
-
-
-#include "intel_m4v_config_parser.h"
-#include "oscl_mem.h"
-#include "oscl_dll.h"
-OSCL_DLL_ENTRY_POINT_DEFAULT()
-
-#define PV_CLZ(A,B) while (((B) & 0x8000) == 0) {(B) <<=1; A++;}
-
-static const uint32 mask[33] =
-{
-    0x00000000, 0x00000001, 0x00000003, 0x00000007,
-    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
-    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
-    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
-    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
-    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
-    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
-    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
-    0xffffffff
-};
-
-int32 LocateFrameHeader(uint8 *ptr, int32 size)
-{
-    int32 count = 0;
-    int32 i = size;
-
-    if (size < 1)
-    {
-        return 0;
-    }
-    while (i--)
-    {
-        if ((count > 1) && (*ptr == 0x01))
-        {
-            i += 2;
-            break;
-        }
-
-        if (*ptr++)
-            count = 0;
-        else
-            count++;
-    }
-    return (size - (i + 1));
-}
-
-void movePointerTo(mp4StreamType *psBits, int32 pos)
-{
-    uint32 byte_pos;
-    if (pos < 0)
-    {
-        pos = 0;
-    }
-
-    byte_pos = pos >> 3;
-
-    if (byte_pos > (psBits->numBytes - psBits->bytePos))
-    {
-        byte_pos = (psBits->numBytes - psBits->bytePos);
-    }
-
-    psBits->bytePos = byte_pos & -4;
-    psBits->dataBitPos = psBits->bytePos << 3;
-    FlushBits(psBits, ((pos & 0x7) + ((byte_pos & 0x3) << 3)));
-}
-
-int16 SearchNextM4VFrame(mp4StreamType *psBits)
-{
-    int16 status = 0;
-    uint8 *ptr;
-    int32 i;
-    uint32 initial_byte_aligned_position = (psBits->dataBitPos + 7) >> 3;
-
-    ptr = psBits->data + initial_byte_aligned_position;
-
-    i = LocateFrameHeader(ptr, psBits->numBytes - initial_byte_aligned_position);
-    if (psBits->numBytes <= initial_byte_aligned_position + i)
-    {
-        status = -1;
-    }
-    (void)movePointerTo(psBits, ((i + initial_byte_aligned_position) << 3)); /* ptr + i */
-    return status;
-}
-
-OSCL_EXPORT_REF int16 iGetM4VConfigInfo(uint8 *buffer, int32 length, int32 *width, int32 *height, int32 *display_width, int32 *display_height)
-{
-    int16 status;
-    mp4StreamType psBits;
-    psBits.data = buffer;
-    psBits.numBytes = length;
-    psBits.bitBuf = 0;
-    psBits.bitPos = 32;
-    psBits.bytePos = 0;
-    psBits.dataBitPos = 0;
-    *width = *height = *display_height = *display_width = 0;
-
-    if (length == 0)
-    {
-        return MP4_INVALID_VOL_PARAM;
-    }
-    int32 profilelevel = 0; // dummy value discarded here
-    status = iDecodeVOLHeader(&psBits, width, height, display_width, display_height, &profilelevel);
-    return status;
-}
-
-// name: iDecodeVOLHeader
-// Purpose: decode VOL header
-// return:  error code
-OSCL_EXPORT_REF int16 iDecodeVOLHeader(mp4StreamType *psBits, int32 *width, int32 *height, int32 *display_width, int32 *display_height, int32 *profilelevel)
-{
-    int16 iErrorStat;
-    uint32 codeword;
-    int32 time_increment_resolution, nbits_time_increment;
-    int32 i, j;
-
-    *profilelevel = 0x0000FFFF; // init to some invalid value. When this value is returned, then no profilelevel info is available
-
-    ShowBits(psBits, 32, &codeword);
-
-    if (codeword == VISUAL_OBJECT_SEQUENCE_START_CODE)
-    {
-        //DV: this is the wrong way to skip bits, use FLush or Read psBits->dataBitPos += 32;
-        ReadBits(psBits, 32, &codeword); // skip 32 bits of the Start code
-
-        ReadBits(psBits, 8, &codeword);
-
-        // record profile and level
-        *profilelevel = (int) codeword;
-
-        ShowBits(psBits, 32, &codeword);
-        if (codeword == USER_DATA_START_CODE)
-        {
-            iErrorStat = DecodeUserData(psBits);
-            if (iErrorStat) return MP4_INVALID_VOL_PARAM;
-        }
-
-
-        ReadBits(psBits, 32, &codeword);
-        if (codeword != VISUAL_OBJECT_START_CODE) return MP4_INVALID_VOL_PARAM;
-
-        /*  is_visual_object_identifier            */
-        ReadBits(psBits, 1, &codeword);
-
-        if (codeword)
-        {
-            /* visual_object_verid                            */
-            ReadBits(psBits, 4, &codeword);
-            /* visual_object_priority                         */
-            ReadBits(psBits, 3, &codeword);
-        }
-        /* visual_object_type                                 */
-        ReadBits(psBits, 4, &codeword);
-
-        if (codeword == 1)
-        { /* video_signal_type */
-            ReadBits(psBits, 1, &codeword);
-            if (codeword == 1)
-            {
-                /* video_format */
-                ReadBits(psBits, 3, &codeword);
-                /* video_range  */
-                ReadBits(psBits, 1, &codeword);
-                /* color_description */
-                ReadBits(psBits, 1, &codeword);
-                if (codeword == 1)
-                {
-                    /* color_primaries */
-                    ReadBits(psBits, 8, &codeword);;
-                    /* transfer_characteristics */
-                    ReadBits(psBits, 8, &codeword);
-                    /* matrix_coefficients */
-                    ReadBits(psBits, 8, &codeword);
-                }
-            }
-        }
-        else
-        {
-            int16 status = 0;
-            do
-            {
-                /* Search for VOL_HEADER */
-                status = SearchNextM4VFrame(psBits); /* search 0x00 0x00 0x01 */
-                if (status != 0)
-                    return MP4_INVALID_VOL_PARAM;
-
-                status = ReadBits(psBits, VOL_START_CODE_LENGTH, &codeword);
-            }
-            while ((codeword != VOL_START_CODE) && (status == 0));
-            goto decode_vol;
-        }
-        /* next_start_code() */
-        ByteAlign(psBits);
-
-        ShowBits(psBits, 32, &codeword);
-        if (codeword == USER_DATA_START_CODE)
-        {
-            iErrorStat = DecodeUserData(psBits);
-            if (iErrorStat) return MP4_INVALID_VOL_PARAM;
-        }
-        ShowBits(psBits, 27, &codeword);
-    }
-    else
-    {
-        ShowBits(psBits, 27, &codeword);
-    }
-
-    if (codeword == VO_START_CODE)
-    {
-
-        ReadBits(psBits, 32, &codeword);
-
-        /* video_object_layer_start_code                   */
-        ReadBits(psBits, 28, &codeword);
-        if (codeword != VOL_START_CODE)
-        {
-            if (psBits->dataBitPos >= (psBits->numBytes << 3))
-            {
-                return SHORT_HEADER_MODE; /* SH */
-            }
-            else
-            {
-                int16 status = 0;
-                do
-                {
-                    /* Search for VOL_HEADER */
-                    status = SearchNextM4VFrame(psBits); /* search 0x00 0x00 0x01 */
-                    if (status != 0)
-                        return MP4_INVALID_VOL_PARAM;
-
-                    status = ReadBits(psBits, VOL_START_CODE_LENGTH, &codeword);
-                }
-                while ((codeword != VOL_START_CODE) && (status == 0));
-                goto decode_vol;
-            }
-        }
-decode_vol:
-
-        uint32 vol_id;
-
-        /* vol_id (4 bits) */
-        ReadBits(psBits, 4, & vol_id);
-
-        // RandomAccessibleVOLFlag
-        ReadBits(psBits, 1, &codeword);
-
-        //Video Object Type Indication
-        ReadBits(psBits, 8, &codeword);
-        if (codeword != 1)
-        {
-            return MP4_INVALID_VOL_PARAM;
-        }
-
-        // is_object_layer_identifier
-        ReadBits(psBits, 1, &codeword);
-
-        if (codeword)
-        {
-            ReadBits(psBits, 4, &codeword);
-            ReadBits(psBits, 3, &codeword);
-        }
-
-        // aspect ratio
-        ReadBits(psBits, 4, &codeword);
-
-        if (codeword == 0xF)
-        {
-            // Extended Parameter
-            /* width */
-            ReadBits(psBits, 8, &codeword);
-            /* height */
-            ReadBits(psBits, 8, &codeword);
-        }
-
-        ReadBits(psBits, 1, &codeword);
-
-        if (codeword)
-        {
-            ReadBits(psBits, 2, &codeword);
-            if (codeword != 1)
-            {
-                return MP4_INVALID_VOL_PARAM;
-            }
-
-            ReadBits(psBits, 1, &codeword);
-
-            if (!codeword)
-            {
-                return MP4_INVALID_VOL_PARAM;
-            }
-
-            ReadBits(psBits, 1, &codeword);
-            if (codeword)   /* if (vbv_parameters) {}, page 36 */
-            {
-                ReadBits(psBits, 15, &codeword);
-                ReadBits(psBits, 1, &codeword);
-                if (codeword != 1)
-                    return MP4_INVALID_VOL_PARAM;
-
-                ReadBits(psBits, 15, &codeword);
-                ReadBits(psBits, 1, &codeword);
-                if (codeword != 1)
-                    return MP4_INVALID_VOL_PARAM;
-
-
-                ReadBits(psBits, 19, &codeword);
-                if (!(codeword & 0x8))
-                    return MP4_INVALID_VOL_PARAM;
-
-                ReadBits(psBits, 11, &codeword);
-                ReadBits(psBits, 1, &codeword);
-                if (codeword != 1)
-                    return MP4_INVALID_VOL_PARAM;
-
-                ReadBits(psBits, 15, &codeword);
-                ReadBits(psBits, 1, &codeword);
-                if (codeword != 1)
-                    return MP4_INVALID_VOL_PARAM;
-            }
-
-        }
-
-        ReadBits(psBits, 2, &codeword);
-
-        if (codeword != 0)
-        {
-            return MP4_INVALID_VOL_PARAM;
-        }
-
-        ReadBits(psBits, 1, &codeword);
-        if (codeword != 1)
-            return MP4_INVALID_VOL_PARAM;
-
-        ReadBits(psBits, 16, &codeword);
-        time_increment_resolution = codeword;
-
-
-        ReadBits(psBits, 1, &codeword);
-        if (codeword != 1)
-            return MP4_INVALID_VOL_PARAM;
-
-
-
-        ReadBits(psBits, 1, &codeword);
-
-        if (codeword && time_increment_resolution > 2)
-        {
-            i = time_increment_resolution - 1;
-            j = 1;
-            while (i >>= 1)
-            {
-                j++;
-            }
-            nbits_time_increment = j;
-
-            ReadBits(psBits, nbits_time_increment, &codeword);
-        }
-
-        ReadBits(psBits, 1, &codeword);
-        if (codeword != 1)
-            return MP4_INVALID_VOL_PARAM;
-
-        /* this should be 176 for QCIF */
-        ReadBits(psBits, 13, &codeword);
-        *display_width = (int32)codeword;
-        ReadBits(psBits, 1, &codeword);
-        if (codeword != 1)
-            return MP4_INVALID_VOL_PARAM;
-
-        /* this should be 144 for QCIF */
-        ReadBits(psBits, 13, &codeword);
-        *display_height = (int32)codeword;
-
-        *width = (*display_width + 15) & -16;
-        *height = (*display_height + 15) & -16;
-    }
-    else
-    {
-        /* SHORT_HEADER */
-        ShowBits(psBits, SHORT_VIDEO_START_MARKER_LENGTH, &codeword);
-        if (codeword == SHORT_VIDEO_START_MARKER)
-        {
-            iDecodeShortHeader(psBits, width, height, display_width, display_height);
-        }
-        else
-        {
-            int16 status = 0;
-            do
-            {
-                /* Search for VOL_HEADER */
-                status = SearchNextM4VFrame(psBits); /* search 0x00 0x00 0x01 */
-                if (status != 0)
-                    return MP4_INVALID_VOL_PARAM;
-
-                status = ReadBits(psBits, VOL_START_CODE_LENGTH, &codeword);
-            }
-            while ((codeword != VOL_START_CODE) && (status == 0));
-            goto decode_vol;
-        }
-    }
-    return 0;
-}
-
-
-
-OSCL_EXPORT_REF
-int16 iDecodeShortHeader(mp4StreamType *psBits,
-                         int32 *width,
-                         int32 *height,
-                         int32 *display_width,
-                         int32 *display_height)
-{
-    uint32 codeword;
-    int32   extended_PTYPE = 0;
-    int32 UFEP = 0;
-    int32 custom_PFMT = 0;
-
-    ShowBits(psBits, 22, &codeword);
-
-    if (codeword !=  0x20)
-    {
-        return MP4_INVALID_VOL_PARAM;
-    }
-    FlushBits(psBits, 22);
-    ReadBits(psBits, 8, &codeword);
-
-    ReadBits(psBits, 1, &codeword);
-    if (codeword == 0) return MP4_INVALID_VOL_PARAM;
-
-    ReadBits(psBits, 1, &codeword);
-    if (codeword == 1) return MP4_INVALID_VOL_PARAM;
-
-    ReadBits(psBits, 1, &codeword);
-    if (codeword == 1) return MP4_INVALID_VOL_PARAM;
-
-    ReadBits(psBits, 1, &codeword);
-    if (codeword == 1) return MP4_INVALID_VOL_PARAM;
-
-    ReadBits(psBits, 1, &codeword);
-    if (codeword == 1) return MP4_INVALID_VOL_PARAM;
-
-    /* source format */
-    ReadBits(psBits, 3, &codeword);
-    switch (codeword)
-    {
-        case 1:
-            *width = 128;
-            *height = 96;
-            break;
-
-        case 2:
-            *width = 176;
-            *height = 144;
-            break;
-
-        case 3:
-            *width = 352;
-            *height = 288;
-            break;
-
-        case 4:
-            *width = 704;
-            *height = 576;
-            break;
-
-        case 5:
-            *width = 1408;
-            *height = 1152;
-            break;
-
-        case 7:
-            extended_PTYPE = 1;
-            break;
-        default:
-            /* Msg("H.263 source format not legal\n"); */
-            return MP4_INVALID_VOL_PARAM;
-    }
-
-    if (extended_PTYPE == 0)
-    {
-        *display_width = *width;
-        *display_height = *height;
-        return 0;
-    }
-    /* source format */
-    ReadBits(psBits, 3, &codeword);
-    UFEP = codeword;
-    if (UFEP == 1)
-    {
-        ReadBits(psBits, 3, &codeword);
-        switch (codeword)
-        {
-            case 1:
-                *width = 128;
-                *height = 96;
-                break;
-
-            case 2:
-                *width = 176;
-                *height = 144;
-                break;
-
-            case 3:
-                *width = 352;
-                *height = 288;
-                break;
-
-            case 4:
-                *width = 704;
-                *height = 576;
-                break;
-
-            case 5:
-                *width = 1408;
-                *height = 1152;
-                break;
-
-            case 6:
-                custom_PFMT = 1;
-                break;
-            default:
-                /* Msg("H.263 source format not legal\n"); */
-                return MP4_INVALID_VOL_PARAM;
-        }
-        if (custom_PFMT == 0)
-        {
-            *display_width = *width;
-            *display_height = *height;
-            return 0;
-        }
-        ReadBits(psBits, 1, &codeword);
-        ReadBits(psBits, 1, &codeword);
-        if (codeword) return MP4_INVALID_VOL_PARAM;
-        ReadBits(psBits, 1, &codeword);
-        if (codeword) return MP4_INVALID_VOL_PARAM;
-        ReadBits(psBits, 1, &codeword);
-        if (codeword) return MP4_INVALID_VOL_PARAM;
-        ReadBits(psBits, 3, &codeword);
-        ReadBits(psBits, 3, &codeword);
-        if (codeword) return MP4_INVALID_VOL_PARAM;             /* RPS, ISD, AIV */
-        ReadBits(psBits, 1, &codeword);
-        ReadBits(psBits, 4, &codeword);
-        if (codeword != 8) return MP4_INVALID_VOL_PARAM;
-    }
-    if (UFEP == 0 || UFEP == 1)
-    {
-        ReadBits(psBits, 3, &codeword);
-        if (codeword > 1) return MP4_INVALID_VOL_PARAM;
-        ReadBits(psBits, 1, &codeword);
-        if (codeword) return MP4_INVALID_VOL_PARAM;
-        ReadBits(psBits, 1, &codeword);
-        if (codeword) return MP4_INVALID_VOL_PARAM;
-        ReadBits(psBits, 1, &codeword);
-        ReadBits(psBits, 3, &codeword);
-        if (codeword != 1) return MP4_INVALID_VOL_PARAM;
-    }
-    else
-    {
-        return MP4_INVALID_VOL_PARAM;
-    }
-    ReadBits(psBits, 1, &codeword);
-    if (codeword) return MP4_INVALID_VOL_PARAM; /* CPM */
-    if (custom_PFMT == 1 && UFEP == 1)
-    {
-        ReadBits(psBits, 4, &codeword);
-        if (codeword == 0) return MP4_INVALID_VOL_PARAM;
-        if (codeword == 0xf)
-        {
-            ReadBits(psBits, 8, &codeword);
-            ReadBits(psBits, 8, &codeword);
-        }
-        ReadBits(psBits, 9, &codeword);
-        *display_width = (codeword + 1) << 2;
-        *width = (*display_width + 15) & -16;
-        ReadBits(psBits, 1, &codeword);
-        if (codeword != 1) return MP4_INVALID_VOL_PARAM;
-        ReadBits(psBits, 9, &codeword);
-        if (codeword == 0) return MP4_INVALID_VOL_PARAM;
-        *display_height = codeword << 2;
-        *height = (*display_height + 15) & -16;
-    }
-
-    return 0;
-}
-
-
-int16 ShowBits(
-    mp4StreamType *pStream,           /* Input Stream */
-    uint8 ucNBits,          /* nr of bits to read */
-    uint32 *pulOutData      /* output target */
-)
-{
-    uint8 *bits;
-    uint32 dataBitPos = pStream->dataBitPos;
-    uint32 bitPos = pStream->bitPos;
-    uint32 dataBytePos;
-
-    uint i;
-
-    if (ucNBits > (32 - bitPos))    /* not enough bits */
-    {
-        dataBytePos = dataBitPos >> 3; /* Byte Aligned Position */
-        bitPos = dataBitPos & 7; /* update bit position */
-        if (dataBytePos > pStream->numBytes - 4)
-        {
-            pStream->bitBuf = 0;
-            for (i = 0; i < pStream->numBytes - dataBytePos; i++)
-            {
-                pStream->bitBuf |= pStream->data[dataBytePos+i];
-                pStream->bitBuf <<= 8;
-            }
-            pStream->bitBuf <<= 8 * (3 - i);
-        }
-        else
-        {
-            bits = &pStream->data[dataBytePos];
-            pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
-        }
-        pStream->bitPos = bitPos;
-    }
-
-    bitPos += ucNBits;
-
-    *pulOutData = (pStream->bitBuf >> (32 - bitPos)) & mask[(uint16)ucNBits];
-
-
-    return 0;
-}
-
-int16 FlushBits(
-    mp4StreamType *pStream,           /* Input Stream */
-    uint8 ucNBits                      /* number of bits to flush */
-)
-{
-    uint8 *bits;
-    uint32 dataBitPos = pStream->dataBitPos;
-    uint32 bitPos = pStream->bitPos;
-    uint32 dataBytePos;
-
-
-    if ((dataBitPos + ucNBits) > (uint32)(pStream->numBytes << 3))
-        return (-2); // Buffer over run
-
-    dataBitPos += ucNBits;
-    bitPos     += ucNBits;
-
-    if (bitPos > 32)
-    {
-        dataBytePos = dataBitPos >> 3;    /* Byte Aligned Position */
-        bitPos = dataBitPos & 7; /* update bit position */
-        bits = &pStream->data[dataBytePos];
-        pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
-    }
-
-    pStream->dataBitPos = dataBitPos;
-    pStream->bitPos     = bitPos;
-
-    return 0;
-}
-
-int16 ReadBits(
-    mp4StreamType *pStream,           /* Input Stream */
-    uint8 ucNBits,                     /* nr of bits to read */
-    uint32 *pulOutData                 /* output target */
-)
-{
-    uint8 *bits;
-    uint32 dataBitPos = pStream->dataBitPos;
-    uint32 bitPos = pStream->bitPos;
-    uint32 dataBytePos;
-
-
-    if ((dataBitPos + ucNBits) > (pStream->numBytes << 3))
-    {
-        *pulOutData = 0;
-        return (-2); // Buffer over run
-    }
-
-    //  dataBitPos += ucNBits;
-
-    if (ucNBits > (32 - bitPos))    /* not enough bits */
-    {
-        dataBytePos = dataBitPos >> 3;    /* Byte Aligned Position */
-        bitPos = dataBitPos & 7; /* update bit position */
-        bits = &pStream->data[dataBytePos];
-        pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
-    }
-
-    pStream->dataBitPos += ucNBits;
-    pStream->bitPos      = (unsigned char)(bitPos + ucNBits);
-
-    *pulOutData = (pStream->bitBuf >> (32 - pStream->bitPos)) & mask[(uint16)ucNBits];
-
-    return 0;
-}
-
-
-
-int16 ByteAlign(
-    mp4StreamType *pStream           /* Input Stream */
-)
-{
-    uint8 *bits;
-    uint32 dataBitPos = pStream->dataBitPos;
-    uint32 bitPos = pStream->bitPos;
-    uint32 dataBytePos;
-    uint32 leftBits;
-
-    leftBits =  8 - (dataBitPos & 0x7);
-    if (leftBits == 8)
-    {
-        if ((dataBitPos + 8) > (uint32)(pStream->numBytes << 3))
-            return (-2); // Buffer over run
-        dataBitPos += 8;
-        bitPos += 8;
-    }
-    else
-    {
-        dataBytePos = dataBitPos >> 3;
-        dataBitPos += leftBits;
-        bitPos += leftBits;
-    }
-
-
-    if (bitPos > 32)
-    {
-        dataBytePos = dataBitPos >> 3;    /* Byte Aligned Position */
-        bits = &pStream->data[dataBytePos];
-        pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
-    }
-
-    pStream->dataBitPos = dataBitPos;
-    pStream->bitPos     = bitPos;
-
-    return 0;
-}
-
-int16 DecodeUserData(mp4StreamType *pStream)
-{
-
-    uint32 codeword;
-    int16 iErrorStat;
-
-    iErrorStat = ReadBits(pStream, 32, &codeword);
-    if (iErrorStat) return iErrorStat;
-    iErrorStat = ShowBits(pStream, 24, &codeword);
-    if (iErrorStat) return iErrorStat;
-
-    while (codeword != 1)
-    {
-        /* Discard user data for now. */
-        iErrorStat = ReadBits(pStream, 8, &codeword);
-        if (iErrorStat) return iErrorStat;
-        iErrorStat = ShowBits(pStream, 24, &codeword);
-        if (iErrorStat) return iErrorStat;
-    }
-    return 0;
-}
-
-
-OSCL_EXPORT_REF int16 iGetAVCConfigInfo(uint8 *buffer, int32 length, int32 *width, int32 *height, int32 *display_width, int32 *display_height, int32 *profile_idc, int32 *level_idc)
-{
-    int16 status;
-    mp4StreamType psBits;
-    uint16 sps_length, pps_length;
-    int32 size;
-    int32 i = 0;
-    uint8* sps = NULL;
-    uint8* temp = (uint8 *)OSCL_MALLOC(sizeof(uint8) * length);
-    uint8* pps = NULL;
-
-
-    if (temp)
-    {
-        sps = temp; // Make a copy of the original pointer to be freed later
-        // Successfull allocation... copy input buffer
-        oscl_memcpy(sps, buffer, length);
-    }
-    else
-    {
-        // Allocation failed
-        return MP4_INVALID_VOL_PARAM;
-    }
-
-    if (length < 3)
-    {
-        OSCL_FREE(temp);
-        return MP4_INVALID_VOL_PARAM;
-    }
-
-    *width = *height = *display_height = *display_width = 0;
-
-    if (sps[0] == 0 && sps[1] == 0)
-    {
-        /* find SC at the beginning of the NAL */
-        while (sps[i++] == 0 && i < length)
-        {
-        }
-
-        if (sps[i-1] == 1)
-        {
-            sps += i;
-
-            sps_length = 0;
-            // search for the next start code
-            while (!(sps[sps_length] == 0 && sps[sps_length+1] == 0 && sps[sps_length+2] == 1) &&
-                    sps_length < length - i - 2)
-            {
-                sps_length++;
-            }
-
-            if (sps_length >= length - i - 2)
-            {
-                OSCL_FREE(temp);
-                return MP4_INVALID_VOL_PARAM;
-            }
-
-            pps_length = length - i - sps_length - 3;
-            pps = sps + sps_length + 3;
-        }
-        else
-        {
-            OSCL_FREE(temp);
-            return MP4_INVALID_VOL_PARAM;
-        }
-    }
-    else
-    {
-        sps_length = (uint16)(sps[1] << 8) | sps[0];
-        sps += 2;
-        pps = sps + sps_length;
-        pps_length = (uint16)(pps[1] << 8) | pps[0];
-        pps += 2;
-    }
-
-    if (sps_length + pps_length > length)
-    {
-        OSCL_FREE(temp);
-        return MP4_INVALID_VOL_PARAM;
-    }
-
-    size = sps_length;
-
-    Parser_EBSPtoRBSP(sps, &size);
-
-    psBits.data = sps;
-    psBits.numBytes = size;
-    psBits.bitBuf = 0;
-    psBits.bitPos = 32;
-    psBits.bytePos = 0;
-    psBits.dataBitPos = 0;
-
-    LOGV("intel: --- call to DecodeSPS() begin ---\n");
-    if (DecodeSPS(&psBits, width, height, display_width, display_height, profile_idc, level_idc))
-    {
-        OSCL_FREE(temp);
-        return MP4_INVALID_VOL_PARAM;
-    }
-    LOGV("intel: --- call to DecodeSPS() end ---\n");
-
-    // now do PPS
-    size = pps_length;
-
-    Parser_EBSPtoRBSP(pps, &size);
-    psBits.data = pps;
-    psBits.numBytes = size;
-    psBits.bitBuf = 0;
-    psBits.bitPos = 32;
-    psBits.bytePos = 0;
-    psBits.dataBitPos = 0;
-
-#if 1
-    
-    return 0;
-	
-#else
-
-    LOGV("intel: --- call to DecodePPS() begin ---\n");
-
-    status = DecodePPS(&psBits);
-
-    LOGV("intel: --- call to DecodePPS() end : status = %x ---\n", status);
-
-    OSCL_FREE(temp);
-
-    return status;
-#endif
-}
-
-void scaling_list(mp4StreamType *psBits, uint32 sizeOfScalingList) {
-    uint32 lastScale = 8;
-    uint32 nextScale = 8;
-    int32 delta_scale;
-    uint32 j = 0;
-
-    for (j = 0; j < sizeOfScalingList; j++) {
-        if(nextScale != 0) {
-          /* delta_scale */
-          se_v(psBits, &delta_scale);
-          nextScale = ( lastScale + delta_scale + 256 ) % 256 ;
-        } 
-        lastScale = ( nextScale == 0 ) ? lastScale : nextScale;
-    } 
-}
-
-
-int16 DecodeSPS(mp4StreamType *psBits, int32 *width, int32 *height, int32 *display_width, int32 *display_height, int32 *profile_idc, int32 *level_idc)
-{
-    uint32 temp;
-    int32 temp0;
-    uint left_offset, right_offset, top_offset, bottom_offset;
-    uint i;
-
-    ReadBits(psBits, 8, &temp);
-
-    if ((temp & 0x1F) != 7) {
-          return MP4_INVALID_VOL_PARAM;
-    }
-
-    /* Read profile_idc */
-    ReadBits(psBits, 8, &temp);
-    *profile_idc = temp;
-
-    /* Read Constraint_set0-3_flag */
-    ReadBits(psBits, 1, &temp);
-    ReadBits(psBits, 1, &temp);
-    ReadBits(psBits, 1, &temp);
-    ReadBits(psBits, 1, &temp);
-
-    LOGV("intel: --- profile_idc = %d ---\n", temp);
-
-    /* reserved_zero_4bits */
-    ReadBits(psBits, 4, &temp);
-
-    /* level_idc */ 
-    ReadBits(psBits, 8, &temp);
-    *level_idc = temp;
-
-    if (temp > 51)
-        return MP4_INVALID_VOL_PARAM;
-
-    /* seq_parameter_set_id */
-    ue_v(psBits, &temp);
-    if(*profile_idc == 100 || *profile_idc == 110 || 
-       *profile_idc == 122 || *profile_idc == 144 )
-    {
-    /* chroma_format_idc */ 
-       ue_v(psBits, &temp);
-       if(temp == 3) {
-       /* residual_colour_transform_flag */
-          ReadBits(psBits, 1, &temp);
-       }
-       /* bit_depth_luma_minus8 */
-       ue_v(psBits, &temp);
-  
-       /* bit_depth_chroma_minus8 */
-       ue_v(psBits, &temp);
-   
-       /* qpprime_y_zero_transform_bypass_flag */
-       ReadBits(psBits, 1, &temp);
-
-       /* seq_scaling_matrix_present_flag */
-       ReadBits(psBits, 1, &temp);
- 
-       if(temp) {
-           int i = 0;
-           for(i = 0; i < 8; i++) {
-               ReadBits(psBits, 1, &temp);
-               if(temp) {
-                  if(i < 6 ) {
-                     scaling_list(psBits, 16);
-                  } else {
-                     scaling_list(psBits, 64);
-                  }
-              } 
-           }
-       }
-    }
-
-    /* log2_max_frame_num_minus4 */
-    ue_v(psBits, &temp);
-
-    /* pic_order_cnt_type */
-    ue_v(psBits, &temp);
-
-    if (temp == 0)
-    {
-        ue_v(psBits, &temp);
-    }
-    else if (temp == 1)
-    {
-        ReadBits(psBits, 1, &temp);
-        se_v(psBits, &temp0);
-        se_v(psBits, &temp0);
-        ue_v(psBits, &temp);
-
-        for (i = 0; i < temp; i++)
-        {
-            se_v(psBits, &temp0);
-        }
-    }
-
-    /* num_ref_frames */
-    ue_v(psBits, &temp);
-
-    /* gaps_in_frame_num_value_allowed_flag */
-    ReadBits(psBits, 1, &temp);
-
-
-    /* pic_width_in_mbs_minus1 */
-    ue_v(psBits, &temp);
-    *display_width = *width = (temp + 1) << 4;
-
-    /* pic_height_in_map_units_minus1 */
-    ue_v(psBits, &temp);
-    *display_height = *height = (temp + 1) << 4;
-
-
-    LOGV("---intel: 1 *display_width = %d *display_height = %d\n", *display_width, *display_height);
-
-    /* frame_mbs_only_flag */
-    ReadBits(psBits, 1, &temp);
-
-    if (!temp)
-    {
-       /* mb_adaptive_frame_field_flag */
-        ReadBits(psBits,1, &temp);
-    }
-
-    /* direct_8x8_inference_flag */
-    ReadBits(psBits, 1, &temp);
-    
-    /* frame_cropping_flag */
-    ReadBits(psBits, 1, &temp);
-
-    if (temp)
-    {
-        ue_v(psBits, (uint32*)&left_offset);
-        ue_v(psBits, (uint32*)&right_offset);
-        ue_v(psBits, (uint32*)&top_offset);
-        ue_v(psBits, (uint32*)&bottom_offset);
-
-        *display_width = *width - 2 * (right_offset + left_offset);
-        *display_height = *height - 2 * (top_offset + bottom_offset);
-
-        LOGV("---intel: 2 *display_width = %d *display_height = %d\n", *display_width, *display_height);
-    }
-
-    /*  no need to check further */
-#if USE_LATER
-    ReadBits(psBits, 1, &temp);
-    if (temp)
-    {
-        if (!DecodeVUI(psBits))
-        {
-            return MP4_INVALID_VOL_PARAM;
-        }
-    }
-#endif
-    return 0; // return 0 for success
-}
-
-#if USE_LATER
-/* unused for now */
-int32 DecodeVUI(mp4StreamType *psBits)
-{
-    uint temp;
-    uint32 temp32;
-    uint aspect_ratio_idc, overscan_appopriate_flag, video_format, video_full_range_flag;
-    int32 status;
-
-    ReadBits(psBits, 1, &temp); /* aspect_ratio_info_present_flag */
-    if (temp)
-    {
-        ReadBits(psBits, 8, &aspect_ratio_idc);
-        if (aspect_ratio_idc == 255)
-        {
-            ReadBits(psBits, 16, &temp); /* sar_width */
-            ReadBits(psBits, 16, &temp); /* sar_height */
-        }
-    }
-    ReadBits(psBits, 1, &temp); /* overscan_info_present */
-    if (temp)
-    {
-        ReadBits(psBits, 1, &overscan_appopriate_flag);
-    }
-    ReadBits(psBits, 1, &temp); /* video_signal_type_present_flag */
-    if (temp)
-    {
-        ReadBits(psBits, 3, &video_format);
-        ReadBits(psBits, 1, &video_full_range_flag);
-        ReadBits(psBits, 1, &temp); /* colour_description_present_flag */
-        if (temp)
-        {
-            ReadBits(psBits, 8, &temp); /* colour_primaries */
-            ReadBits(psBits, 8, &temp); /* transfer_characteristics */
-            ReadBits(psBits, 8, &temp); /* matrix coefficients */
-        }
-    }
-    ReadBits(psBits, 1, &temp);/*   chroma_loc_info_present_flag */
-    if (temp)
-    {
-        ue_v(psBits, &temp); /*  chroma_sample_loc_type_top_field */
-        ue_v(psBits, &temp); /*  chroma_sample_loc_type_bottom_field */
-    }
-
-    ReadBits(psBits, 1, &temp); /*  timing_info_present_flag*/
-    if (temp)
-    {
-        ReadBits(psBits, 32, &temp32); /*  num_unit_in_tick*/
-        ReadBits(psBits, 32, &temp32); /*   time_scale */
-        ReadBits(psBits, 1, &temp); /*  fixed_frame_rate_flag */
-    }
-
-    ReadBits(psBits, 1, &temp); /*  nal_hrd_parameters_present_flag */
-    if (temp)
-    {
-        if (!DecodeHRD(psBits))
-        {
-            return 1;
-        }
-    }
-    ReadBits(psBits, 1, &temp32); /*    vcl_hrd_parameters_present_flag*/
-    if (temp32)
-    {
-        if (!DecodeHRD(psBits))
-        {
-            return 1;
-        }
-    }
-    if (temp || temp32)
-    {
-        ReadBits(psBits, 1, &temp);     /*  low_delay_hrd_flag */
-    }
-    ReadBits(psBits, 1, &temp); /*  pic_struct_present_flag */
-    status = ReadBits(psBits, 1, &temp); /* _restriction_flag */
-    if (status != 0) // buffer overrun
-    {
-        return 1;
-    }
-
-    if (temp)
-    {
-        ReadBits(psBits, 1, &temp); /*  motion_vectors_over_pic_boundaries_flag */
-        ue_v(psBits, &temp); /* max_bytes_per_pic_denom */
-        ue_v(psBits, &temp); /* max_bits_per_mb_denom */
-        ue_v(psBits, &temp); /* log2_max_mv_length_horizontal */
-        ue_v(psBits, &temp); /* log2_max_mv_length_vertical */
-        ue_v(psBits, &temp); /* num_reorder_frames */
-        ue_v(psBits, &temp); /* max_dec_frame_buffering */
-    }
-
-    return 0; // 0 for success
-}
-
-/* unused for now */
-int32 DecodeHRD(mp4StreamType *psBits)
-{
-    uint temp;
-    uint cpb_cnt_minus1;
-    uint i;
-    int32 status;
-
-    ue_v(psBits, &cpb_cnt_minus1);
-    ReadBits(psBits, 4, &temp); /*  bit_rate_scale */
-    ReadBits(psBits, 4, &temp); /*  cpb_size_scale */
-    for (i = 0; i <= cpb_cnt_minus1; i++)
-    {
-        ue_v(psBits, &temp); /* bit_rate_value_minus1[i] */
-        ue_v(psBits, &temp); /* cpb_size_value_minus1[i] */
-        ue_v(psBits, &temp); /* cbr_flag[i] */
-    }
-    ReadBits(psBits, 5, &temp); /*  initial_cpb_removal_delay_length_minus1 */
-    ReadBits(psBits, 5, &temp); /*  cpb_removal_delay_length_minus1 */
-    ReadBits(psBits, 5, &temp); /*  dpb_output_delay_length_minus1 */
-    status = ReadBits(psBits, 5, &temp); /* time_offset_length  */
-
-    if (status != 0) // buffer overrun
-    {
-        return 1;
-    }
-
-    return 0; // 0 for success
-}
-#endif
-
-// only check for entropy coding mode
-int32 DecodePPS(mp4StreamType *psBits)
-{
-    uint32 temp, pic_parameter_set_id, seq_parameter_set_id, entropy_coding_mode_flag;
-
-    ReadBits(psBits, 8, &temp);
-
-    if ((temp & 0x1F) != 8) return MP4_INVALID_VOL_PARAM;
-
-    ue_v(psBits, &pic_parameter_set_id);
-    ue_v(psBits, &seq_parameter_set_id);
-
-    ReadBits(psBits, 1, &entropy_coding_mode_flag);
-    if (entropy_coding_mode_flag)
-    {
-        return 1;
-    }
-
-    return 0;
-}
-
-void ue_v(mp4StreamType *psBits, uint32 *codeNum)
-{
-    uint32 temp;
-    uint tmp_cnt;
-    int32 leading_zeros = 0;
-    ShowBits(psBits, 16, &temp);
-
-    tmp_cnt = temp  | 0x1;
-
-    PV_CLZ(leading_zeros, tmp_cnt)
-
-    if (leading_zeros < 8)
-    {
-        *codeNum = (temp >> (15 - (leading_zeros << 1))) - 1;
-
-	FlushBits(psBits, (leading_zeros << 1) + 1);
-	
-    }
-    else
-    {
-        ReadBits(psBits, (leading_zeros << 1) + 1, &temp);
-        *codeNum = temp - 1;
-
-    }
-
-}
-
-
-void se_v(mp4StreamType *psBits, int32 *value)
-{
-    int32 leadingZeros = 0;
-    uint32 temp;
-
-    OSCL_UNUSED_ARG(value);
-
-    ReadBits(psBits, 1, &temp);
-    while (!temp)
-    {
-        leadingZeros++;
-        if (ReadBits(psBits, 1, &temp))
-        {
-            break;
-        }
-    }
-    ReadBits(psBits, leadingZeros, &temp);
-}
-
-void Parser_EBSPtoRBSP(uint8 *nal_unit, int32 *size)
-{
-    int32 i, j;
-    int32 count = 0;
-
-
-    for (i = 0; i < *size; i++)
-    {
-        if (count == 2 && nal_unit[i] == 0x03)
-        {
-            break;
-        }
-
-        if (nal_unit[i])
-            count = 0;
-        else
-            count++;
-    }
-
-    count = 0;
-    j = i++;
-    for (; i < *size; i++)
-    {
-        if (count == 2 && nal_unit[i] == 0x03)
-        {
-            i++;
-            count = 0;
-        }
-        nal_unit[j] = nal_unit[i];
-        if (nal_unit[i])
-            count = 0;
-        else
-            count++;
-        j++;
-    }
-
-    *size = j;
-}
-
-
-
diff --git a/ilcore/src/intel_m4v_config_parser.h b/ilcore/src/intel_m4v_config_parser.h
deleted file mode 100644
index b428740..0000000
--- a/ilcore/src/intel_m4v_config_parser.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-#ifndef PV_M4V_CONFIG_PARSER_H_INCLUDED
-#define PV_M4V_CONFIG_PARSER_H_INCLUDED
-
-#include "oscl_base.h"
-#include "oscl_types.h"
-
-#define USE_LATER 0  // for some code that will be needed in the future
-
-#define MP4_INVALID_VOL_PARAM -1
-#define SHORT_HEADER_MODE -4
-
-
-#define VISUAL_OBJECT_SEQUENCE_START_CODE   0x01B0
-#define VISUAL_OBJECT_SEQUENCE_END_CODE     0x01B1
-#define VISUAL_OBJECT_START_CODE   0x01B5
-#define VO_START_CODE           0x8
-#define VO_HEADER_LENGTH        32
-#define VOL_START_CODE 0x12
-#define VOL_START_CODE_LENGTH 28
-
-#define GROUP_START_CODE    0x01B3
-#define GROUP_START_CODE_LENGTH  32
-
-#define VOP_ID_CODE_LENGTH      5
-#define VOP_TEMP_REF_CODE_LENGTH    16
-
-#define USER_DATA_START_CODE        0x01B2
-#define USER_DATA_START_CODE_LENGTH 32
-
-#define SHORT_VIDEO_START_MARKER        0x20
-#define SHORT_VIDEO_START_MARKER_LENGTH  22
-
-typedef struct
-{
-    uint8 *data;
-    uint32 numBytes;
-    uint32 bytePos;
-    uint32 bitBuf;
-    uint32 dataBitPos;
-    uint32  bitPos;
-} mp4StreamType;
-
-
-int16 ShowBits(
-    mp4StreamType *pStream,
-    uint8 ucNBits,
-    uint32 *pulOutData
-);
-
-int16 FlushBits(
-    mp4StreamType *pStream,
-    uint8 ucNBits
-);
-
-int16 ReadBits(
-    mp4StreamType *pStream,
-    uint8 ucNBits,
-    uint32 *pulOutData
-);
-
-
-
-int16 ByteAlign(
-    mp4StreamType *pStream
-);
-
-
-OSCL_IMPORT_REF int16 iDecodeVOLHeader(mp4StreamType *psBits, int32 *width, int32 *height, int32 *, int32 *, int32 *profilelevel);
-OSCL_IMPORT_REF int16 iGetM4VConfigInfo(uint8 *buffer, int32 length, int32 *width, int32 *height, int32 *, int32 *);
-int16 DecodeUserData(mp4StreamType *pStream);
-OSCL_IMPORT_REF int16 iDecodeShortHeader(mp4StreamType *psBits, int32 *width, int32 *height, int32 *, int32 *);
-OSCL_IMPORT_REF int16 iGetAVCConfigInfo(uint8 *buffer, int32 length, int32 *width, int32 *height, int32 *, int32 *, int32 *profile, int32 *level);
-
-int32 FindNAL(uint8** nal_pnt, uint8* buffer, int32 length);
-int16 DecodeSPS(mp4StreamType *psBits, int32 *width, int32 *height, int32 *display_width, int32 *display_height, int32 *profile_idc, int32 *level_idc);
-#if USE_LATER
-int32 DecodeHRD(mp4StreamType *psBits);
-int32 DecodeVUI(mp4StreamType *psBits);
-#endif
-int32 DecodePPS(mp4StreamType *psBits);
-
-void ue_v(mp4StreamType *psBits, uint32 *codeNum);
-void se_v(mp4StreamType *psBits, int32 *value);
-void Parser_EBSPtoRBSP(uint8 *nal_unit, int32 *size);
-
-#endif //PV_M4V_CONFIG_PARSER_H_INCLUDED
-
-
diff --git a/ilcore/src/intel_omx_config_parser.cpp b/ilcore/src/intel_omx_config_parser.cpp
deleted file mode 100644
index c9c5a06..0000000
--- a/ilcore/src/intel_omx_config_parser.cpp
+++ /dev/null
@@ -1,164 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-
-//#define LOG_NDEBUG 0
-#define LOG_TAG "intel_omx_config_parser"
-#include <utils/Log.h>
-
-
-#include "oscl_stdstring.h"
-
-// Use default DLL entry point
-#ifndef OSCL_DLL_H_INCLUDED
-#include "oscl_dll.h"
-#endif
-
-#include "pv_omx_config_parser.h"
-#include "pv_omxcore.h"
-#include "intel_omx_config_parser.h"
-#include "intel_video_config_parser.h"
-
-
-OSCL_EXPORT_REF OMX_BOOL Intel_OMXConfigParser(
-    OMX_PTR aInputParameters,
-    OMX_PTR aOutputParameters)
-
-{
-    OMXConfigParserInputs* pInputs;
-
-    LOGV("--- Intel_OMXConfigParser() ----\n");
-
-    pInputs = (OMXConfigParserInputs*) aInputParameters;
-
-
-    if (NULL != pInputs->cComponentRole)
-    {
-        if (0 == oscl_strncmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder", oscl_strlen("audio_decoder")))
-        {
-            OMX_S32 Status;
-            pvAudioConfigParserInputs aInputs;
-
-            aInputs.inPtr = pInputs->inPtr;
-            aInputs.inBytes = pInputs->inBytes;
-
-            if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.wma"))
-            {
-                aInputs.iMimeType = PVMF_MIME_WMA;
-
-            }
-            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.aac"))
-            {
-                aInputs.iMimeType = PVMF_MIME_AAC_SIZEHDR;
-
-            }
-            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.amr"))
-            {
-                aInputs.iMimeType = PVMF_MIME_AMR;
-
-            }
-            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.amrnb"))
-            {
-                aInputs.iMimeType = PVMF_MIME_AMR;
-
-            }
-            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.amrwb"))
-            {
-                aInputs.iMimeType = PVMF_MIME_AMRWB;
-
-            }
-            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"audio_decoder.mp3"))
-            {
-                aInputs.iMimeType = PVMF_MIME_MP3;
-
-            }
-            else
-            {
-                return OMX_FALSE;
-            }
-
-
-            Status = pv_audio_config_parser(&aInputs, (pvAudioConfigParserOutputs *)aOutputParameters);
-            if (0 == Status)
-            {
-                return OMX_FALSE;
-            }
-        }
-        else if (0 == oscl_strncmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder", oscl_strlen("video_decoder")))
-        {
-
-            OMX_S32 Status;
-            pvVideoConfigParserInputs aInputs;
-
-            aInputs.inPtr = pInputs->inPtr;
-            aInputs.inBytes = pInputs->inBytes;
-
-            if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder.wmv"))
-            {
-                aInputs.iMimeType = PVMF_MIME_WMV;
-
-            }
-            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder.avc"))
-            {
-                aInputs.iMimeType = PVMF_MIME_H264_VIDEO;
-
-            }
-            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder.mpeg4"))
-            {
-                aInputs.iMimeType = PVMF_MIME_M4V;
-
-            }
-            else if (0 == oscl_strcmp(pInputs->cComponentRole, (OMX_STRING)"video_decoder.h263"))
-            {
-                aInputs.iMimeType = PVMF_MIME_H2632000;
-
-            }
-            else
-            {
-                return OMX_FALSE;
-            }
-
-            if(aInputs.iMimeType == PVMF_MIME_H264_VIDEO || 
-                    aInputs.iMimeType == PVMF_MIME_H2632000 || 
-                    aInputs.iMimeType == PVMF_MIME_H2631998) 
-	    {
-                LOGV("--- intel_video_config_parser() ---\n");
-                Status = intel_video_config_parser(&aInputs, (pvVideoConfigParserOutputs *)aOutputParameters);
-            }
-            else
-            {
-                Status = pv_video_config_parser(&aInputs, (pvVideoConfigParserOutputs *)aOutputParameters);
-            }
-            if (0 != Status)
-            {
-                return OMX_FALSE;
-            }
-        }
-        else
-        {
-            return OMX_FALSE;
-        }
-
-    }
-    else
-    {
-        return OMX_FALSE;
-    }
-
-    return OMX_TRUE;
-}
-
diff --git a/ilcore/src/intel_omx_config_parser.h b/ilcore/src/intel_omx_config_parser.h
deleted file mode 100644
index abd0625..0000000
--- a/ilcore/src/intel_omx_config_parser.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-#ifndef INTEL_OMX_CONFIG_PARSER_H_INCLUDED
-#define INTEL_OMX_CONFIG_PARSER_H_INCLUDED
-
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-    OSCL_IMPORT_REF OMX_BOOL Intel_OMXConfigParser(
-        OMX_PTR aInputParameters,
-        OMX_PTR aOutputParameters);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* INTEL_OMX_CONFIG_PARSER_H_INCLUDED */
-
diff --git a/ilcore/src/intel_video_config_parser.cpp b/ilcore/src/intel_video_config_parser.cpp
deleted file mode 100644
index 835a893..0000000
--- a/ilcore/src/intel_video_config_parser.cpp
+++ /dev/null
@@ -1,288 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-
-#include "intel_video_config_parser.h"
-#include "intel_m4v_config_parser.h"
-#include "oscl_mem.h"
-
-#include "oscl_dll.h"
-
-#define GetUnalignedWord( pb, w ) \
-            (w) = ((uint16) *(pb + 1) << 8) + *pb;
-
-#define GetUnalignedDword( pb, dw ) \
-            (dw) = ((uint32) *(pb + 3) << 24) + \
-                   ((uint32) *(pb + 2) << 16) + \
-                   ((uint16) *(pb + 1) << 8) + *pb;
-
-#define GetUnalignedWordEx( pb, w )     GetUnalignedWord( pb, w ); (pb) += sizeof(uint16);
-#define GetUnalignedDwordEx( pb, dw )   GetUnalignedDword( pb, dw ); (pb) += sizeof(uint32);
-#define GetUnalignedQwordEx( pb, qw )   GetUnalignedQword( pb, qw ); (pb) += sizeof(uint64);
-
-#define LoadBYTE( b, p )    b = *(uint8 *)p;  p += sizeof( uint8 )
-
-#define LoadWORD( w, p )    GetUnalignedWordEx( p, w )
-#define LoadDWORD( dw, p )  GetUnalignedDwordEx( p, dw )
-#define LoadQWORD( qw, p )  GetUnalignedQwordEx( p, qw )
-
-#ifndef MAKEFOURCC_WMC
-#define MAKEFOURCC_WMC(ch0, ch1, ch2, ch3) \
-        ((uint32)(uint8)(ch0) | ((uint32)(uint8)(ch1) << 8) |   \
-        ((uint32)(uint8)(ch2) << 16) | ((uint32)(uint8)(ch3) << 24 ))
-
-#define mmioFOURCC_WMC(ch0, ch1, ch2, ch3)  MAKEFOURCC_WMC(ch0, ch1, ch2, ch3)
-#endif
-
-#define FOURCC_WMV2     mmioFOURCC_WMC('W','M','V','2')
-#define FOURCC_WMV3     mmioFOURCC_WMC('W','M','V','3')
-#define FOURCC_WMVA     mmioFOURCC_WMC('W','M','V','A')
-#define FOURCC_WVC1     mmioFOURCC_WMC('W','V','C','1')
-//For WMVA
-#define ASFBINDING_SIZE                   1   // size of ASFBINDING is 1 byte
-#define FOURCC_MP42     mmioFOURCC_WMC('M','P','4','2')
-#define FOURCC_MP43     mmioFOURCC_WMC('M','P','4','3')
-#define FOURCC_mp42     mmioFOURCC_WMC('m','p','4','2')
-#define FOURCC_mp43     mmioFOURCC_WMC('m','p','4','3')
-
-
-OSCL_DLL_ENTRY_POINT_DEFAULT()
-
-int32 GetNAL_Config(uint8** bitstream, int32* size);
-
-OSCL_EXPORT_REF int16 intel_video_config_parser(pvVideoConfigParserInputs *aInputs, pvVideoConfigParserOutputs *aOutputs)
-{
-    if (aInputs->iMimeType == PVMF_MIME_M4V) //m4v
-    {
-        mp4StreamType psBits;
-        psBits.data = aInputs->inPtr;
-        if (aInputs->inBytes <= 0)
-        {
-            return -1;
-        }
-        psBits.numBytes = aInputs->inBytes;
-        psBits.bytePos = 0;
-        psBits.bitBuf = 0;
-        psBits.dataBitPos = 0;
-        psBits.bitPos = 32;
-
-        int32 width, height, display_width, display_height = 0;
-        int32 profile_level = 0;
-        int16 retval = 0;
-        retval = iDecodeVOLHeader(&psBits, &width, &height, &display_width, &display_height, &profile_level);
-        if (retval != 0)
-        {
-            return retval;
-        }
-        aOutputs->width  = (uint32)display_width;
-        aOutputs->height = (uint32)display_height;
-        aOutputs->profile = (uint32)profile_level; // for mp4, profile/level info is packed
-        aOutputs->level = 0;
-    }
-    else if (aInputs->iMimeType == PVMF_MIME_H2631998 ||
-             aInputs->iMimeType == PVMF_MIME_H2632000)//h263
-    {
-        // Nothing to do for h263
-        aOutputs->width  = 0;
-        aOutputs->height = 0;
-        aOutputs->profile = 0;
-        aOutputs->level = 0;
-    }
-    else if (aInputs->iMimeType == PVMF_MIME_H264_VIDEO ||
-             aInputs->iMimeType == PVMF_MIME_H264_VIDEO_MP4) //avc
-    {
-        int32 width, height, display_width, display_height = 0;
-        int32 profile_idc, level_idc = 0;
-
-        uint8 *tp = aInputs->inPtr;
-
-        if (aInputs->inBytes > 1)
-        {
-            if (tp[0] == 0 && tp[1] == 0)
-            {
-                // ByteStream Format
-                uint8* tmp_ptr = tp;
-                uint8* buffer_begin = tp;
-                int16 length = 0;
-                int initbufsize = aInputs->inBytes;
-                int tConfigSize = 0;
-                do
-                {
-                    tmp_ptr += length;
-                    length = GetNAL_Config(&tmp_ptr, &initbufsize);
-                    buffer_begin[0] = length & 0xFF;
-                    buffer_begin[1] = (length >> 8) & 0xFF;
-                    oscl_memcpy(buffer_begin + 2, tmp_ptr, length);
-                    buffer_begin += (length + 2);
-                    tConfigSize += (length + 2);
-                }
-                while (initbufsize > 0);
-            }
-        }
-
-        // check codec info and get settings
-        int16 retval;
-        retval = iGetAVCConfigInfo(tp,
-                                   aInputs->inBytes,
-                                   (int*) & width,
-                                   (int*) & height,
-                                   (int*) & display_width,
-                                   (int*) & display_height,
-                                   (int*) & profile_idc,
-                                   (int*) & level_idc);
-        if (retval != 0)
-        {
-            return retval;
-        }
-        aOutputs->width  = (uint32)display_width;
-        aOutputs->height = (uint32)display_height;
-        aOutputs->profile = (uint32)profile_idc;
-        aOutputs->level = (uint32) level_idc;
-    }
-    else if (aInputs->iMimeType == PVMF_MIME_WMV) //wmv
-    {
-        uint32 dwdat;
-        uint16 wdat;
-        uint8 bdat;
-        uint8 *pData = aInputs->inPtr;
-
-        LoadDWORD(dwdat, pData); // Window width
-        LoadDWORD(dwdat, pData); // Window height
-        LoadBYTE(bdat, pData);
-        LoadWORD(wdat, pData);  // Size of image info.
-
-        // BITMAPINFOHEADER
-        LoadDWORD(dwdat, pData); // Size of BMAPINFOHDR
-        LoadDWORD(dwdat, pData);
-        aOutputs->width = dwdat;
-        LoadDWORD(dwdat, pData);
-        aOutputs->height = dwdat;
-
-        /* WMV1 and WMV2 are not supported. Rejected here. */
-        /* Code to Check if comp is WMV1 then return not supported */
-        pData += 4;
-        LoadDWORD(dwdat, pData);
-        uint32 NewCompression = dwdat;
-        uint32 NewSeqHeader = 0;
-        uint32 NewProfile = 0;
-        // in case of WMV store "Compression Type as Level"
-        aOutputs->level = NewCompression;
-
-        if (NewCompression != FOURCC_WMV2 &&
-                NewCompression != FOURCC_WMV3 &&
-                NewCompression != FOURCC_WVC1 &&
-                NewCompression != FOURCC_WMVA &&
-                NewCompression != FOURCC_MP42 &&
-                NewCompression != FOURCC_MP43 &&
-                NewCompression != FOURCC_mp42 &&
-                NewCompression != FOURCC_mp43)
-        {
-            return -1;
-        }
-        // get profile etc.
-        // Check sequence header
-        switch (NewCompression)
-        {
-            case FOURCC_WMV3:
-            {
-                // start fresh
-                pData = aInputs->inPtr;
-                pData += (11 + 40); //sizeof(BITMAPINFOHEADER); // position to sequence header
-
-                LoadDWORD(dwdat, pData);
-                NewSeqHeader = dwdat; // this is little endian read sequence header
-
-                NewProfile = (NewSeqHeader & 0xC0) >> 6; // 0 - simple , 1- main, 3 - complex, 2-forbidden
-
-                break;
-            }
-            case FOURCC_WMVA:
-            {
-                pData = aInputs->inPtr;
-                pData += (11 + 40 + ASFBINDING_SIZE); //sizeof(BITMAPINFOHEADER); // position to sequence header
-
-                LoadDWORD(dwdat, pData); // prefix  // this is little endian read sequence header
-                LoadDWORD(dwdat, pData);
-                NewSeqHeader = dwdat;
-
-                NewProfile = (NewSeqHeader & 0xC0) >> 6; // this must be 3
-            }
-            break;
-
-            default:
-
-                NewProfile = 0;
-                break;
-        }
-
-        aOutputs->profile = NewProfile;
-
-    }
-    else
-    {
-        return -1;
-    }
-    return 0;
-}
-
-
-/* This function finds a nal from the SC's, moves the bitstream pointer to the beginning of the NAL unit, returns the
-    size of the NAL, and at the same time, updates the remaining size in the bitstream buffer that is passed in */
-int32 GetNAL_Config(uint8** bitstream, int32* size)
-{
-    int i = 0;
-    int j;
-    uint8* nal_unit = *bitstream;
-    int count = 0;
-
-    /* find SC at the beginning of the NAL */
-    while (nal_unit[i++] == 0 && i < *size)
-    {
-    }
-
-    if (nal_unit[i-1] == 1)
-    {
-        *bitstream = nal_unit + i;
-    }
-    else
-    {
-        j = *size;
-        *size = 0;
-        return j;  // no SC at the beginning, not supposed to happen
-    }
-
-    j = i;
-
-    /* found the SC at the beginning of the NAL, now find the SC at the beginning of the next NAL */
-    while (i < *size)
-    {
-        if (count == 2 && nal_unit[i] == 0x01)
-        {
-            i -= 2;
-            break;
-        }
-
-        if (nal_unit[i])
-            count = 0;
-        else
-            count++;
-        i++;
-    }
-
-    *size -= i;
-    return (i - j);
-}
diff --git a/ilcore/src/intel_video_config_parser.h b/ilcore/src/intel_video_config_parser.h
deleted file mode 100644
index 8042c45..0000000
--- a/ilcore/src/intel_video_config_parser.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-#ifndef INTEL_VIDEO_CONFIG_PARSER_H_INCLUDED
-#define INTEL_VIDEO_CONFIG_PARSER_H_INCLUDED
-/*
-#include "oscl_base.h"
-#include "oscl_types.h"
-#include "pvmf_format_type.h"
-#include "oscl_stdstring.h"
-*/
-#include "pv_video_config_parser.h"
-
-OSCL_IMPORT_REF int16 intel_video_config_parser(pvVideoConfigParserInputs *aInputs, pvVideoConfigParserOutputs *aOutputs);
-
-
-#endif //INTEL_VIDEO_CONFIG_PARSER_H_INCLUDED
-
-
diff --git a/ilcore/src/pv_omx_interface.cpp b/ilcore/src/pv_omx_interface.cpp
deleted file mode 100644
index 3e1b928..0000000
--- a/ilcore/src/pv_omx_interface.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/* ------------------------------------------------------------------
- * Copyright (C) 1998-2009 PacketVideo
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- * -------------------------------------------------------------------
- */
-
-/* Contains changes by Wind River Systems, 2009-2010 */
-
-#include "pvlogger.h"
-
-#include "pv_omxcore.h"
-#include "omx_interface.h"
-#include "intel_omx_config_parser.h"
-
-
-
-class PVOMXInterface : public OMXInterface
-{
-    public:
-        OsclAny* SharedLibraryLookup(const OsclUuid& aInterfaceId)
-        {
-            if (aInterfaceId == OMX_INTERFACE_ID)
-            {
-                // the library lookup was successful
-                return this;
-            }
-            // the ID doesn't match
-            return NULL;
-        };
-
-        static PVOMXInterface* Instance()
-        {
-            return OSCL_NEW(PVOMXInterface, ());
-        };
-
-        bool UnloadWhenNotUsed(void)
-        {
-            // As of 9/22/08, the PV OMX core library can not be
-            // safely unloaded and reloaded when the proxy interface
-            // is enabled.
-            return false;
-        };
-
-    private:
-
-        PVOMXInterface()
-        {
-            // set the pointers to the omx core methods
-            pOMX_Init = OMX_Init;
-            pOMX_Deinit = OMX_Deinit;
-            pOMX_ComponentNameEnum = OMX_ComponentNameEnum;
-            pOMX_GetHandle = OMX_GetHandle;
-            pOMX_FreeHandle = OMX_FreeHandle;
-            pOMX_GetComponentsOfRole = OMX_GetComponentsOfRole;
-            pOMX_GetRolesOfComponent = OMX_GetRolesOfComponent;
-            pOMX_SetupTunnel = OMX_SetupTunnel;
-            pOMX_GetContentPipe = OMX_GetContentPipe;
-            pOMXConfigParser = Intel_OMXConfigParser; 
-        };
-
-};
-
-// function to obtain the interface object from the shared library
-extern "C"
-{
-    OSCL_EXPORT_REF OsclAny* PVGetInterface()
-    {
-        return PVOMXInterface::Instance();
-    }
-    OSCL_EXPORT_REF void PVReleaseInterface(void* interface)
-    {
-        PVOMXInterface* pInterface = (PVOMXInterface*)interface;
-        if (pInterface)
-        {
-            OSCL_DELETE(pInterface);
-        }
-    }
-}
diff --git a/ilcore/src/wrs_omxcore.cpp b/ilcore/src/wrs_omxcore.cpp
deleted file mode 100644
index 9e5de6e..0000000
--- a/ilcore/src/wrs_omxcore.cpp
+++ /dev/null
@@ -1,459 +0,0 @@
-/*
- * wrs_core.cpp, Wind River OpenMax-IL Core
- *
- * Copyright (c) 2009-2010 Wind River Systems, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <pthread.h>
-
-#include <OMX_Core.h>
-#include <OMX_Component.h>
-
-#include <list.h>
-#include <cmodule.h>
-#include <componentbase.h>
-
-#define NUM_COMPONENTS 2
-typedef struct component_handle {
-
-    char comp_name[OMX_MAX_STRINGNAME_SIZE];
-    void * comp_handle;
-    char parser_name[OMX_MAX_STRINGNAME_SIZE];
-    void * parser_handle;
-
-}ComponentHandle, *ComponentHandlePtr;
-
-static unsigned int g_initialized = 0;
-static unsigned int g_nr_instances = 0;
-static struct list *preload_list=NULL;
-
-static struct list *g_module_list = NULL;
-static pthread_mutex_t g_module_lock = PTHREAD_MUTEX_INITIALIZER;
-
-static char *omx_components[NUM_COMPONENTS][2] = {
-    {"libOMXVideoDecoderAVC.so", "libmixvbp-h264.so"},
-    {NULL,NULL}
-};
-
-extern "C" bool preload_components(void)
-{
-    /* this function is called by openMAX-IL client when libraries are to be
-     * loaded at initial stages.  Security features of the operating system require
-     * to load libraries upfront */
-    ComponentHandlePtr component_handle;
-    int index;
-    bool ret = true;
-
-    for (index=0;omx_components[index][0];index++) {
-        struct list *entry;
-        component_handle = (ComponentHandlePtr) malloc(sizeof(ComponentHandle));
-
-        strncpy(component_handle->comp_name, omx_components[index][0], OMX_MAX_STRINGNAME_SIZE);
-        /* parser is not always needed */
-        if (omx_components[index][1])
-            strncpy(component_handle->parser_name, omx_components[index][1], OMX_MAX_STRINGNAME_SIZE);
-
-        /* skip libraries starting with # */
-        if (component_handle->comp_name[0] == '#')
-            continue;
-
-        component_handle->comp_handle = dlopen(component_handle->comp_name, RTLD_NOW);
-        if (!component_handle->comp_handle) {
-            ret=false;
-            goto delete_comphandle;
-        }
-
-
-        if (component_handle->parser_name) {
-            /* some components don't need a parser */
-            component_handle->parser_handle = dlopen(component_handle->parser_name, RTLD_NOW);
-            if (!component_handle->parser_handle) {
-                ret=false;
-                goto delete_comphandle;
-            }
-        }
-
-        entry = list_alloc(component_handle);
-        if (!entry) {
-            ret=false;
-            goto unload_comphandle;
-        }
-        preload_list = __list_add_tail(preload_list, entry);
-
-	omx_infoLog("open component %s and parser %s", component_handle->comp_name,
-			component_handle->parser_name == NULL ?
-			"No parser provided":component_handle->parser_name );
-	continue;
-
-unload_comphandle:
-        dlclose(component_handle->comp_handle);
-delete_comphandle:
-        free(component_handle);
-    }
-    return ret;
-}
-
-static struct list *construct_components(const char *config_file_name)
-{
-    FILE *config_file;
-    char config_file_path[256];
-    int index=0;
-    struct list *head = NULL, *preload_entry;
-    ComponentHandlePtr component_handle;
-
-    list_foreach(preload_list, preload_entry) {
-        CModule *cmodule;
-        struct list *entry;
-        OMX_ERRORTYPE ret;
-
-        component_handle = (ComponentHandlePtr) preload_entry->data;
-
-        /* skip libraries starting with # */
-        if (component_handle->comp_name[0] == '#')
-            continue;
-
-        cmodule = new CModule(component_handle->comp_name);
-        if (!cmodule)
-            continue;
-
-        omx_verboseLog("found component library %s", component_handle->comp_name);
-
-        ret = cmodule->Load(MODULE_NOW, component_handle->comp_handle);
-        if (ret != OMX_ErrorNone)
-            goto delete_cmodule;
-
-        ret = cmodule->SetParser(component_handle->parser_handle);
-        if (ret != OMX_ErrorNone)
-            goto delete_cmodule;
-
-        ret = cmodule->QueryComponentNameAndRoles();
-        if (ret != OMX_ErrorNone)
-            goto unload_cmodule;
-
-        entry = list_alloc(cmodule);
-        if (!entry)
-            goto unload_cmodule;
-        head = __list_add_tail(head, entry);
-
-        // cmodule->Unload();
-        omx_verboseLog("module %s:%s added to component list",
-             cmodule->GetLibraryName(), cmodule->GetComponentName());
-
-        continue;
-
-    unload_cmodule:
-        cmodule->Unload();
-    delete_cmodule:
-        delete cmodule;
-    }
-
-    return head;
-}
-
-static struct list *destruct_components(struct list *head)
-{
-    struct list *entry, *next;
-    ComponentHandlePtr component_handle;
-
-    list_foreach_safe(head, entry, next) {
-        CModule *cmodule = static_cast<CModule *>(entry->data);
-
-        head = __list_delete(head, entry);
-        delete cmodule;
-    }
-
-    return head;
-}
-
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void)
-{
-    int ret;
-
-    omx_verboseLog("%s(): enter", __FUNCTION__);
-
-    pthread_mutex_lock(&g_module_lock);
-    if (!g_initialized) {
-        g_module_list = construct_components("wrs_omxil_components.list");
-        if (!g_module_list) {
-            pthread_mutex_unlock(&g_module_lock);
-            omx_errorLog("%s(): exit failure, construct_components failed",
-                 __FUNCTION__);
-            return OMX_ErrorInsufficientResources;
-        }
-
-        g_initialized = 1;
-    }
-    pthread_mutex_unlock(&g_module_lock);
-
-    omx_verboseLog("%s(): exit done", __FUNCTION__);
-    return OMX_ErrorNone;
-}
-
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void)
-{
-    OMX_ERRORTYPE ret = OMX_ErrorNone;
-
-    omx_verboseLog("%s(): enter", __FUNCTION__);
-
-    pthread_mutex_lock(&g_module_lock);
-    if (!g_nr_instances) {
-        g_module_list = destruct_components(g_module_list);
-        g_initialized = 0;
-    } else
-        ret = OMX_ErrorUndefined;
-    pthread_mutex_unlock(&g_module_lock);
-
-    omx_verboseLog("%s(): exit done (ret : 0x%08x)", __FUNCTION__, ret);
-    return ret;
-}
-
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
-    OMX_OUT OMX_STRING cComponentName,
-    OMX_IN OMX_U32 nNameLength,
-    OMX_IN OMX_U32 nIndex)
-{
-    CModule *cmodule;
-    ComponentBase *cbase;
-    struct list *entry;
-    OMX_STRING cname;
-
-    pthread_mutex_lock(&g_module_lock);
-    entry = __list_entry(g_module_list, nIndex);
-    if (!entry) {
-        pthread_mutex_unlock(&g_module_lock);
-        return OMX_ErrorNoMore;
-    }
-    pthread_mutex_unlock(&g_module_lock);
-
-    cmodule = static_cast<CModule *>(entry->data);
-    cname = cmodule->GetComponentName();
-
-    strncpy(cComponentName, cname, nNameLength);
-
-    omx_verboseLog("%s(): found %luth component %s", __FUNCTION__, nIndex, cname);
-    return OMX_ErrorNone;
-}
-
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
-    OMX_OUT OMX_HANDLETYPE* pHandle,
-    OMX_IN OMX_STRING cComponentName,
-    OMX_IN OMX_PTR pAppData,
-    OMX_IN OMX_CALLBACKTYPE *pCallBacks)
-{
-    struct list *entry;
-    OMX_ERRORTYPE ret;
-
-    omx_verboseLog("%s(): enter, try to get %s", __FUNCTION__, cComponentName);
-
-    pthread_mutex_lock(&g_module_lock);
-    list_foreach(g_module_list, entry) {
-        CModule *cmodule;
-        OMX_STRING cname;
-
-        cmodule = static_cast<CModule *>(entry->data);
-
-        cname = cmodule->GetComponentName();
-        if (!strcmp(cComponentName, cname)) {
-            ComponentBase *cbase = NULL;
-
-            ret = cmodule->InstantiateComponent(&cbase);
-            if (ret != OMX_ErrorNone){
-                omx_errorLog("%s(): exit failure, cmodule->Instantiate failed\n",
-                     __FUNCTION__);
-                goto unload_cmodule;
-            }
-
-            ret = cbase->GetHandle(pHandle, pAppData, pCallBacks);
-            if (ret != OMX_ErrorNone) {
-                omx_errorLog("%s(): exit failure, cbase->GetHandle failed\n",
-                     __FUNCTION__);
-                goto delete_cbase;
-            }
-
-            cbase->SetCModule(cmodule);
-
-            g_nr_instances++;
-            pthread_mutex_unlock(&g_module_lock);
-
-            omx_infoLog("get handle of component %s successfully", cComponentName);
-            omx_verboseLog("%s(): exit done\n", __FUNCTION__);
-            return OMX_ErrorNone;
-
-        delete_cbase:
-            delete cbase;
-        unload_cmodule:
-            cmodule->Unload();
-        unlock_list:
-            pthread_mutex_unlock(&g_module_lock);
-
-            omx_errorLog("%s(): exit failure, (ret : 0x%08x)\n", __FUNCTION__, ret);
-            return ret;
-        }
-    }
-    pthread_mutex_unlock(&g_module_lock);
-
-    omx_errorLog("%s(): exit failure, %s not found", __FUNCTION__, cComponentName);
-    return OMX_ErrorInvalidComponent;
-}
-
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
-    OMX_IN OMX_HANDLETYPE hComponent)
-{
-    ComponentBase *cbase;
-    CModule *cmodule;
-    OMX_ERRORTYPE ret;
-    char cname[OMX_MAX_STRINGNAME_SIZE];
-
-    if (!hComponent)
-        return OMX_ErrorBadParameter;
-
-    cbase = static_cast<ComponentBase *>
-        (((OMX_COMPONENTTYPE *)hComponent)->pComponentPrivate);
-    if (!cbase) {
-        omx_errorLog("%s(): exit failure, cannot find cbase pointer\n",
-             __FUNCTION__);
-        return OMX_ErrorBadParameter;
-    }
-    strcpy(&cname[0], cbase->GetName());
-
-    omx_verboseLog("%s(): enter, try to free %s", __FUNCTION__, cbase->GetName());
-
-
-    ret = cbase->FreeHandle(hComponent);
-    if (ret != OMX_ErrorNone) {
-        omx_errorLog("%s(): exit failure, cbase->FreeHandle() failed (ret = 0x%08x)\n",
-             __FUNCTION__, ret);
-        return ret;
-    }
-
-    pthread_mutex_lock(&g_module_lock);
-    g_nr_instances--;
-    pthread_mutex_unlock(&g_module_lock);
-
-    cmodule = cbase->GetCModule();
-    if (!cmodule)
-        omx_errorLog("fatal error, %s does not have cmodule\n", cbase->GetName());
-
-
-    if (cmodule && !preload_list)
-        cmodule->Unload();
-
-    delete cbase;
-
-    omx_infoLog("free handle of component %s successfully", cname);
-    omx_verboseLog("%s(): exit done", __FUNCTION__);
-    return OMX_ErrorNone;
-}
-
-OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
-    OMX_IN OMX_HANDLETYPE hOutput,
-    OMX_IN OMX_U32 nPortOutput,
-    OMX_IN OMX_HANDLETYPE hInput,
-    OMX_IN OMX_U32 nPortInput)
-{
-    return OMX_ErrorNotImplemented;
-}
-
-OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
-    OMX_OUT OMX_HANDLETYPE *hPipe,
-    OMX_IN OMX_STRING szURI)
-{
-    return OMX_ErrorNotImplemented;
-}
-
-OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole (
-    OMX_IN OMX_STRING role,
-    OMX_INOUT OMX_U32 *pNumComps,
-    OMX_INOUT OMX_U8  **compNames)
-{
-    struct list *entry;
-    OMX_U32 nr_comps = 0, copied_nr_comps = 0;
-
-    pthread_mutex_lock(&g_module_lock);
-    list_foreach(g_module_list, entry) {
-        CModule *cmodule;
-        OMX_STRING cname;
-        bool having_role;
-
-        cmodule = static_cast<CModule *>(entry->data);
-
-        having_role = cmodule->QueryHavingThisRole(role);
-        if (having_role) {
-            if (compNames && compNames[nr_comps]) {
-                cname = cmodule->GetComponentName();
-                strncpy((OMX_STRING)&compNames[nr_comps][0], cname,
-                        OMX_MAX_STRINGNAME_SIZE);
-                copied_nr_comps++;
-                omx_verboseLog("%s(): component %s has %s role", __FUNCTION__,
-                     cname, role);
-            }
-            nr_comps++;
-        }
-    }
-    pthread_mutex_unlock(&g_module_lock);
-
-    if (!copied_nr_comps)
-        *pNumComps = nr_comps;
-    else {
-        if (copied_nr_comps != *pNumComps)
-            return OMX_ErrorBadParameter;
-    }
-
-    return OMX_ErrorNone;
-}
-
-OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent (
-    OMX_IN OMX_STRING compName,
-    OMX_INOUT OMX_U32 *pNumRoles,
-    OMX_OUT OMX_U8 **roles)
-{
-    struct list *entry;
-
-    pthread_mutex_lock(&g_module_lock);
-    list_foreach(g_module_list, entry) {
-        CModule *cmodule;
-        ComponentBase *cbase;
-        OMX_STRING cname;
-        OMX_ERRORTYPE ret;
-
-        cmodule = static_cast<CModule *>(entry->data);
-
-        cname = cmodule->GetComponentName();
-        if (!strcmp(compName, cname)) {
-            pthread_mutex_unlock(&g_module_lock);
-#if LOG_NDEBUG
-            return cmodule->GetComponentRoles(pNumRoles, roles);
-#else
-            ret = cmodule->GetComponentRoles(pNumRoles, roles);
-            if (ret != OMX_ErrorNone) {
-                OMX_U32 i;
-
-                for (i = 0; i < *pNumRoles; i++) {
-                    omx_verboseLog("%s(): component %s has %s role", __FUNCTION__,
-                         compName, &roles[i][0]);
-                }
-            }
-            return ret;
-#endif
-        }
-    }
-    pthread_mutex_unlock(&g_module_lock);
-
-    return OMX_ErrorInvalidComponent;
-}
-- 
1.8.1.2

